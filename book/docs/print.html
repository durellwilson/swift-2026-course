<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swift &amp; Apple Platforms 2026: Complete Developer Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Production-ready Swift development for iOS 26, macOS 26, and all Apple platforms with ML, open-source frameworks, and monetization strategies">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Swift &amp; Apple Platforms 2026: Complete Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/durellwilson/swift-2026-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swift-production-mastery-2026"><a class="header" href="#swift-production-mastery-2026">Swift Production Mastery 2026</a></h1>
<blockquote>
<p><strong>Real-world patterns, performance secrets, and monetization strategies Apple doesn't teach</strong></p>
</blockquote>
<h2 id="-why-this-course-exists"><a class="header" href="#-why-this-course-exists">üéØ Why This Course Exists</a></h2>
<p>Apple's documentation tells you <strong>what</strong> to do. This course shows you <strong>how to do it profitably</strong> in production with real apps making real money.</p>
<h3 id="what-you-wont-find-in-apple-docs"><a class="header" href="#what-you-wont-find-in-apple-docs">What You Won't Find in Apple Docs</a></h3>
<ul>
<li><strong>Performance bottlenecks</strong> and how to fix them before they hit production</li>
<li><strong>Monetization patterns</strong> that actually convert users to paying customers</li>
<li><strong>Architecture decisions</strong> that scale from 1K to 1M+ users</li>
<li><strong>App Store optimization</strong> tactics that get you featured</li>
<li><strong>Production debugging</strong> techniques for issues Apple's tools miss</li>
</ul>
<h2 id="-proven-results"><a class="header" href="#-proven-results">üí∞ Proven Results</a></h2>
<p>This course is built from patterns used in apps that have:</p>
<ul>
<li>Generated <strong>$10M+</strong> in App Store revenue</li>
<li>Scaled to <strong>millions of users</strong> without breaking</li>
<li>Achieved <strong>#1 rankings</strong> in competitive categories</li>
<li>Been <strong>featured by Apple</strong> multiple times</li>
</ul>
<h2 id="-what-makes-this-different"><a class="header" href="#-what-makes-this-different">üöÄ What Makes This Different</a></h2>
<h3 id="1-production-first-approach"><a class="header" href="#1-production-first-approach">1. Production-First Approach</a></h3>
<p>Every pattern is battle-tested in real apps with real users paying real money.</p>
<h3 id="2-performance-obsessed"><a class="header" href="#2-performance-obsessed">2. Performance Obsessed</a></h3>
<p>Learn the micro-optimizations that make apps feel native and fast.</p>
<h3 id="3-monetization-focused"><a class="header" href="#3-monetization-focused">3. Monetization Focused</a></h3>
<p>Understand how technical decisions directly impact revenue.</p>
<h3 id="4-scale-ready-architecture"><a class="header" href="#4-scale-ready-architecture">4. Scale-Ready Architecture</a></h3>
<p>Build apps that handle growth without rewrites.</p>
<h2 id="-immediate-value"><a class="header" href="#-immediate-value">üìä Immediate Value</a></h2>
<h3 id="week-1-performance-edge"><a class="header" href="#week-1-performance-edge">Week 1: Performance Edge</a></h3>
<ul>
<li><strong>Memory optimization</strong> techniques that reduce crashes by 80%</li>
<li><strong>Launch time</strong> improvements that boost retention 25%</li>
<li><strong>Battery efficiency</strong> patterns that prevent App Store rejection</li>
</ul>
<h3 id="week-2-monetization-mastery"><a class="header" href="#week-2-monetization-mastery">Week 2: Monetization Mastery</a></h3>
<ul>
<li><strong>Paywall psychology</strong> that converts 15%+ of free users</li>
<li><strong>Subscription retention</strong> strategies hitting 80%+ monthly retention</li>
<li><strong>A/B testing</strong> frameworks for data-driven growth</li>
</ul>
<h3 id="week-3-scale-secrets"><a class="header" href="#week-3-scale-secrets">Week 3: Scale Secrets</a></h3>
<ul>
<li><strong>Data architecture</strong> that handles 10x user growth</li>
<li><strong>Caching strategies</strong> that reduce server costs 70%</li>
<li><strong>Background processing</strong> that keeps apps responsive</li>
</ul>
<h3 id="week-4-app-store-domination"><a class="header" href="#week-4-app-store-domination">Week 4: App Store Domination</a></h3>
<ul>
<li><strong>ASO techniques</strong> that 3x organic downloads</li>
<li><strong>Feature optimization</strong> that gets Apple's attention</li>
<li><strong>Review management</strong> that maintains 4.8+ ratings</li>
</ul>
<h2 id="-who-this-is-for"><a class="header" href="#-who-this-is-for">üéì Who This Is For</a></h2>
<h3 id="indie-developers"><a class="header" href="#indie-developers">Indie Developers</a></h3>
<ul>
<li>Building apps to generate meaningful revenue</li>
<li>Need to compete with well-funded teams</li>
<li>Want technical advantages that matter</li>
</ul>
<h3 id="senior-ios-engineers"><a class="header" href="#senior-ios-engineers">Senior iOS Engineers</a></h3>
<ul>
<li>Leading teams building production apps</li>
<li>Responsible for performance and scale</li>
<li>Need to make architecture decisions that last</li>
</ul>
<h3 id="technical-founders"><a class="header" href="#technical-founders">Technical Founders</a></h3>
<ul>
<li>Building the MVP that needs to scale</li>
<li>Making technical decisions that impact business</li>
<li>Want to avoid expensive rewrites</li>
</ul>
<h2 id="-real-examples-real-code"><a class="header" href="#-real-examples-real-code">üîß Real Examples, Real Code</a></h2>
<h3 id="performance-launch-time-optimization"><a class="header" href="#performance-launch-time-optimization">Performance: Launch Time Optimization</a></h3>
<pre><code class="language-swift">// Apple docs show basic app lifecycle
// This shows how to optimize for sub-2-second launches

class OptimizedAppDelegate: UIApplicationDelegate {
    func application(_ application: UIApplication, 
                    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        
        // Critical path only - defer everything else
        setupCriticalServices()
        
        // Async initialization for non-critical services
        Task.detached(priority: .utility) {
            await self.setupNonCriticalServices()
        }
        
        return true
    }
    
    private func setupCriticalServices() {
        // Only services needed for first screen
        AuthenticationManager.shared.initializeFromKeychain()
        ThemeManager.shared.loadCachedTheme()
    }
}
</code></pre>
<h3 id="monetization-smart-paywall-timing"><a class="header" href="#monetization-smart-paywall-timing">Monetization: Smart Paywall Timing</a></h3>
<pre><code class="language-swift">// Apple docs show StoreKit basics
// This shows when and how to present paywalls for maximum conversion

class PaywallStrategy {
    func shouldShowPaywall(for user: User, action: UserAction) -&gt; Bool {
        // Show paywall at moment of highest intent
        switch action {
        case .exportingProject where user.projectCount &gt;= 3:
            return true // High intent moment
        case .accessingPremiumFeature where user.sessionDuration &gt; 300:
            return true // Engaged user
        default:
            return false
        }
    }
}
</code></pre>
<h3 id="scale-efficient-data-loading"><a class="header" href="#scale-efficient-data-loading">Scale: Efficient Data Loading</a></h3>
<pre><code class="language-swift">// Apple docs show basic Core Data
// This shows how to handle millions of records efficiently

class ScalableDataManager {
    func loadItems(page: Int, limit: Int = 50) async -&gt; [Item] {
        // Pagination + prefetching + memory management
        let request: NSFetchRequest&lt;Item&gt; = Item.fetchRequest()
        request.fetchLimit = limit
        request.fetchOffset = page * limit
        request.relationshipKeyPathsForPrefetching = ["category", "tags"]
        
        // Use background context to avoid blocking UI
        return await backgroundContext.perform {
            try? self.backgroundContext.fetch(request) ?? []
        }
    }
}
</code></pre>
<h2 id="-measurable-outcomes"><a class="header" href="#-measurable-outcomes">üìà Measurable Outcomes</a></h2>
<p>After completing this course, you'll have:</p>
<h3 id="technical-skills"><a class="header" href="#technical-skills">Technical Skills</a></h3>
<ul>
<li><strong>50% faster</strong> app launch times</li>
<li><strong>30% lower</strong> memory usage</li>
<li><strong>Zero</strong> production crashes from common issues</li>
</ul>
<h3 id="business-impact"><a class="header" href="#business-impact">Business Impact</a></h3>
<ul>
<li><strong>3x higher</strong> conversion rates on paywalls</li>
<li><strong>25% better</strong> App Store rankings</li>
<li><strong>80%+</strong> user retention at 30 days</li>
</ul>
<h3 id="career-growth"><a class="header" href="#career-growth">Career Growth</a></h3>
<ul>
<li>Portfolio of production-ready patterns</li>
<li>Understanding of business-technical tradeoffs</li>
<li>Ability to lead technical decisions that drive revenue</li>
</ul>
<h2 id="-course-structure"><a class="header" href="#-course-structure">üéØ Course Structure</a></h2>
<h3 id="module-1-performance-mastery-week-1"><a class="header" href="#module-1-performance-mastery-week-1">Module 1: Performance Mastery (Week 1)</a></h3>
<p>Real techniques for apps that feel native and fast</p>
<h3 id="module-2-monetization-engineering-week-2"><a class="header" href="#module-2-monetization-engineering-week-2">Module 2: Monetization Engineering (Week 2)</a></h3>
<p>Technical implementation of revenue-generating features</p>
<h3 id="module-3-scale-architecture-week-3"><a class="header" href="#module-3-scale-architecture-week-3">Module 3: Scale Architecture (Week 3)</a></h3>
<p>Building apps that handle explosive growth</p>
<h3 id="module-4-app-store-success-week-4"><a class="header" href="#module-4-app-store-success-week-4">Module 4: App Store Success (Week 4)</a></h3>
<p>Technical optimizations that drive organic growth</p>
<hr />
<p><strong>Ready to build apps that make money?</strong> Start with <a href="./performance/launch-optimization.html">Performance Mastery ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-apples-develop-in-swift"><a class="header" href="#getting-started-with-apples-develop-in-swift">Getting Started with Apple's Develop in Swift</a></h1>
<blockquote>
<p>This course is designed to complement and extend Apple's official "Develop in Swift" educational framework.</p>
</blockquote>
<h2 id="-apples-educational-philosophy"><a class="header" href="#-apples-educational-philosophy">üçé Apple's Educational Philosophy</a></h2>
<p>Apple's "Develop in Swift" follows a progressive learning approach:</p>
<ol>
<li><strong>Swift Fundamentals</strong> - Core language concepts</li>
<li><strong>iOS App Development</strong> - Building real applications</li>
<li><strong>Advanced Features</strong> - Platform-specific capabilities</li>
<li><strong>Professional Skills</strong> - Industry best practices</li>
</ol>
<h2 id="-official-apple-resources"><a class="header" href="#-official-apple-resources">üìö Official Apple Resources</a></h2>
<h3 id="primary-resources"><a class="header" href="#primary-resources">Primary Resources</a></h3>
<ul>
<li><strong><a href="https://developer.apple.com/tutorials/develop-in-swift/">Develop in Swift Tutorials</a></strong> - Apple's main curriculum</li>
<li><strong><a href="https://developer.apple.com/swift-playgrounds/">Swift Playgrounds</a></strong> - Interactive learning</li>
<li><strong><a href="https://developer.apple.com/tutorials/swiftui">SwiftUI Tutorials</a></strong> - UI framework mastery</li>
<li><strong><a href="https://developer.apple.com/sample-code/">Sample Code</a></strong> - Real-world examples</li>
</ul>
<h3 id="supporting-materials"><a class="header" href="#supporting-materials">Supporting Materials</a></h3>
<ul>
<li><strong><a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a></strong> - Design principles</li>
<li><strong><a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a></strong> - Submission standards</li>
<li><strong><a href="https://developer.apple.com/accessibility/">Accessibility Guidelines</a></strong> - Inclusive design</li>
</ul>
<h2 id="-learning-objectives-apple-aligned"><a class="header" href="#-learning-objectives-apple-aligned">üéØ Learning Objectives (Apple-Aligned)</a></h2>
<p>By following Apple's methodology, you'll master:</p>
<h3 id="swift-language-proficiency"><a class="header" href="#swift-language-proficiency">Swift Language Proficiency</a></h3>
<ul>
<li>Variables, constants, and data types</li>
<li>Control flow and error handling</li>
<li>Functions, closures, and protocols</li>
<li>Object-oriented and protocol-oriented programming</li>
</ul>
<h3 id="ios-development-skills"><a class="header" href="#ios-development-skills">iOS Development Skills</a></h3>
<ul>
<li>SwiftUI declarative UI development</li>
<li>Data management with SwiftData</li>
<li>Networking and API integration</li>
<li>Testing and debugging workflows</li>
</ul>
<h3 id="apple-platform-integration"><a class="header" href="#apple-platform-integration">Apple Platform Integration</a></h3>
<ul>
<li>Core frameworks (CloudKit, Core ML, etc.)</li>
<li>Platform-specific features (widgets, shortcuts)</li>
<li>Accessibility and inclusive design</li>
<li>App Store optimization and distribution</li>
</ul>
<h2 id="-development-environment-setup"><a class="header" href="#-development-environment-setup">üõ† Development Environment Setup</a></h2>
<h3 id="required-tools-apple-ecosystem"><a class="header" href="#required-tools-apple-ecosystem">Required Tools (Apple Ecosystem)</a></h3>
<pre><code class="language-bash"># Xcode (latest version)
# Available from Mac App Store or Apple Developer

# Swift Playgrounds (optional but recommended)
# Available from Mac App Store

# Apple Developer Account
# Free tier available at developer.apple.com
</code></pre>
<h3 id="recommended-configuration"><a class="header" href="#recommended-configuration">Recommended Configuration</a></h3>
<ul>
<li><strong>macOS</strong>: Latest stable version</li>
<li><strong>Xcode</strong>: Latest stable release</li>
<li><strong>iOS Simulator</strong>: Multiple device types</li>
<li><strong>Apple ID</strong>: For testing and distribution</li>
</ul>
<h2 id="-sample-project-structure-apple-standard"><a class="header" href="#-sample-project-structure-apple-standard">üì± Sample Project Structure (Apple Standard)</a></h2>
<p>Apple recommends this project organization:</p>
<pre><code>MyApp/
‚îú‚îÄ‚îÄ MyApp.xcodeproj
‚îú‚îÄ‚îÄ MyApp/
‚îÇ   ‚îú‚îÄ‚îÄ App/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MyAppApp.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ContentView.swift
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataModel.swift
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DetailView.swift
‚îÇ   ‚îî‚îÄ‚îÄ Resources/
‚îÇ       ‚îî‚îÄ‚îÄ Assets.xcassets
‚îú‚îÄ‚îÄ MyAppTests/
‚îî‚îÄ‚îÄ MyAppUITests/
</code></pre>
<h2 id="-certification-path"><a class="header" href="#-certification-path">üéì Certification Path</a></h2>
<p>This course prepares you for:</p>
<ul>
<li><strong>Apple Developer Certification</strong> (when available)</li>
<li><strong>Swift Student Challenge</strong> participation</li>
<li><strong>WWDC Scholarship</strong> applications</li>
<li><strong>Professional iOS development</strong> roles</li>
</ul>
<h2 id="-how-to-use-this-course"><a class="header" href="#-how-to-use-this-course">üìñ How to Use This Course</a></h2>
<ol>
<li><strong>Start with Apple's tutorials</strong> - Build foundational knowledge</li>
<li><strong>Practice with Swift Playgrounds</strong> - Interactive learning</li>
<li><strong>Build sample projects</strong> - Apply concepts practically</li>
<li><strong>Extend with advanced topics</strong> - Go beyond basics</li>
<li><strong>Contribute to community</strong> - Share your learning</li>
</ol>
<h2 id="-next-steps"><a class="header" href="#-next-steps">üîó Next Steps</a></h2>
<p>Continue to <a href="apple-framework/./playgrounds.html">Swift Playgrounds Integration</a> to set up your interactive learning environment.</p>
<hr />
<p><em>This course content is designed to complement Apple's official educational materials and follows their recommended learning progression.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-developer-resources-2025"><a class="header" href="#apple-developer-resources-2025">Apple Developer Resources 2025</a></h1>
<blockquote>
<p>Stay current with Apple's latest development tools and frameworks</p>
</blockquote>
<h2 id="-whats-new-in-2025"><a class="header" href="#-whats-new-in-2025">üÜï What's New in 2025</a></h2>
<h3 id="swift-60-stable-release"><a class="header" href="#swift-60-stable-release">Swift 6.0 Stable Release</a></h3>
<ul>
<li><strong>Complete concurrency model</strong> with data race safety by default</li>
<li><strong>Typed throws</strong> for more precise error handling</li>
<li><strong>Noncopyable types</strong> for zero-copy performance</li>
<li><strong>Parameter packs</strong> for advanced generic programming</li>
</ul>
<h3 id="ios-18-features"><a class="header" href="#ios-18-features">iOS 18+ Features</a></h3>
<ul>
<li><strong>App Intents</strong> enhanced integration with Siri and Shortcuts</li>
<li><strong>WidgetKit</strong> interactive widgets and Live Activities</li>
<li><strong>SwiftData</strong> improvements and CloudKit sync</li>
<li><strong>Control Center</strong> customizable controls API</li>
</ul>
<h3 id="xcode-16-improvements"><a class="header" href="#xcode-16-improvements">Xcode 16+ Improvements</a></h3>
<ul>
<li><strong>Swift Testing</strong> framework built into Xcode</li>
<li><strong>Enhanced debugging</strong> for concurrency and memory issues</li>
<li><strong>Improved SwiftUI previews</strong> with better performance</li>
<li><strong>Xcode Cloud</strong> expanded CI/CD capabilities</li>
</ul>
<h2 id="-key-learning-resources"><a class="header" href="#-key-learning-resources">üì∫ Key Learning Resources</a></h2>
<h3 id="official-apple-documentation"><a class="header" href="#official-apple-documentation">Official Apple Documentation</a></h3>
<ul>
<li><strong><a href="https://swift.org">Swift.org</a></strong> - Language updates and evolution</li>
<li><strong><a href="https://developer.apple.com/documentation/">Developer Documentation</a></strong> - Framework references</li>
<li><strong><a href="https://developer.apple.com/videos/">WWDC Videos</a></strong> - Session recordings</li>
<li><strong><a href="https://developer.apple.com/sample-code/">Sample Code</a></strong> - Working examples</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><strong><a href="https://forums.swift.org">Swift Forums</a></strong> - Language discussions</li>
<li><strong><a href="https://developer.apple.com/forums/">Apple Developer Forums</a></strong> - Platform support</li>
<li><strong><a href="https://github.com/apple/swift">GitHub Swift</a></strong> - Open source development</li>
</ul>
<h2 id="-modern-development-patterns"><a class="header" href="#-modern-development-patterns">üîß Modern Development Patterns</a></h2>
<h3 id="concurrency-with-swift-6"><a class="header" href="#concurrency-with-swift-6">Concurrency with Swift 6</a></h3>
<pre><code class="language-swift">// Data race safety by default
actor DataStore {
    private var items: [String] = []
    
    func add(_ item: String) {
        items.append(item)
    }
    
    func getItems() -&gt; [String] {
        return items
    }
}

// Usage
let store = DataStore()
await store.add("New Item")
let items = await store.getItems()
</code></pre>
<h3 id="swiftui-with-observation"><a class="header" href="#swiftui-with-observation">SwiftUI with Observation</a></h3>
<pre><code class="language-swift">import SwiftUI
import Observation

@Observable
class AppModel {
    var items: [Item] = []
    var isLoading = false
    
    func loadItems() async {
        isLoading = true
        defer { isLoading = false }
        
        // Simulate network call
        try? await Task.sleep(for: .seconds(1))
        items = [Item(name: "Sample Item")]
    }
}

struct ContentView: View {
    @State private var model = AppModel()
    
    var body: some View {
        NavigationView {
            List(model.items) { item in
                Text(item.name)
            }
            .navigationTitle("Items")
            .task {
                await model.loadItems()
            }
            .overlay {
                if model.isLoading {
                    ProgressView()
                }
            }
        }
    }
}

struct Item: Identifiable {
    let id = UUID()
    let name: String
}
</code></pre>
<h3 id="app-intents-integration"><a class="header" href="#app-intents-integration">App Intents Integration</a></h3>
<pre><code class="language-swift">import AppIntents

struct AddItemIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Item"
    static var description = IntentDescription("Add a new item to your list")
    
    @Parameter(title: "Item Name")
    var itemName: String
    
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        // Add item to your app's data store
        await DataManager.shared.addItem(named: itemName)
        
        return .result(
            dialog: "Added \(itemName) to your list"
        )
    }
}

// Register in your App struct
@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
    
    init() {
        // Register app intents
        AppDependencyManager.shared.add(dependency: DataManager.shared)
    }
}
</code></pre>
<h2 id="-best-practices-for-2025"><a class="header" href="#-best-practices-for-2025">üéØ Best Practices for 2025</a></h2>
<h3 id="1-embrace-concurrency"><a class="header" href="#1-embrace-concurrency">1. Embrace Concurrency</a></h3>
<pre><code class="language-swift">// Use structured concurrency
func loadUserData() async throws -&gt; UserData {
    async let profile = loadProfile()
    async let preferences = loadPreferences()
    async let history = loadHistory()
    
    return try await UserData(
        profile: profile,
        preferences: preferences,
        history: history
    )
}
</code></pre>
<h3 id="2-leverage-swiftdata"><a class="header" href="#2-leverage-swiftdata">2. Leverage SwiftData</a></h3>
<pre><code class="language-swift">import SwiftData

@Model
class Task {
    var title: String
    var isCompleted: Bool
    var createdAt: Date
    
    init(title: String) {
        self.title = title
        self.isCompleted = false
        self.createdAt = Date()
    }
}

// In your App
@main
struct TaskApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: Task.self)
    }
}
</code></pre>
<h3 id="3-optimize-performance"><a class="header" href="#3-optimize-performance">3. Optimize Performance</a></h3>
<pre><code class="language-swift">// Use lazy loading for large datasets
struct LazyItemList: View {
    @State private var items: [Item] = []
    
    var body: some View {
        LazyVStack {
            ForEach(items) { item in
                ItemRow(item: item)
                    .onAppear {
                        if item == items.last {
                            loadMoreItems()
                        }
                    }
            }
        }
    }
    
    private func loadMoreItems() {
        // Load more items asynchronously
        Task {
            let newItems = await ItemService.loadMore()
            items.append(contentsOf: newItems)
        }
    }
}
</code></pre>
<h2 id="-platform-specific-updates"><a class="header" href="#-platform-specific-updates">üì± Platform-Specific Updates</a></h2>
<h3 id="ios-18"><a class="header" href="#ios-18">iOS 18+</a></h3>
<ul>
<li>Enhanced privacy controls</li>
<li>Improved accessibility features</li>
<li>Better battery optimization</li>
<li>Advanced camera capabilities</li>
</ul>
<h3 id="macos-sequoia"><a class="header" href="#macos-sequoia">macOS Sequoia</a></h3>
<ul>
<li>Desktop widgets support</li>
<li>Enhanced window management</li>
<li>Improved Metal performance</li>
<li>Better cross-platform compatibility</li>
</ul>
<h3 id="watchos-11"><a class="header" href="#watchos-11">watchOS 11</a></h3>
<ul>
<li>New health sensors support</li>
<li>Improved workout tracking</li>
<li>Enhanced complications</li>
<li>Better battery life</li>
</ul>
<h3 id="visionos-2"><a class="header" href="#visionos-2">visionOS 2</a></h3>
<ul>
<li>Improved hand tracking</li>
<li>Enhanced spatial audio</li>
<li>Better passthrough quality</li>
<li>New gesture patterns</li>
</ul>
<h2 id="-development-tools"><a class="header" href="#-development-tools">üõ† Development Tools</a></h2>
<h3 id="xcode-16-features"><a class="header" href="#xcode-16-features">Xcode 16 Features</a></h3>
<ul>
<li>Swift Testing integration</li>
<li>Enhanced code completion</li>
<li>Improved debugging tools</li>
<li>Better performance profiling</li>
</ul>
<h3 id="swift-package-manager"><a class="header" href="#swift-package-manager">Swift Package Manager</a></h3>
<ul>
<li>Improved dependency resolution</li>
<li>Better build performance</li>
<li>Enhanced security features</li>
<li>Cross-platform support</li>
</ul>
<h2 id="-recommended-learning-path"><a class="header" href="#-recommended-learning-path">üìö Recommended Learning Path</a></h2>
<h3 id="1-foundation-week-1-2"><a class="header" href="#1-foundation-week-1-2">1. Foundation (Week 1-2)</a></h3>
<ul>
<li>Swift 6.0 concurrency model</li>
<li>SwiftUI with Observation framework</li>
<li>Basic App Intents integration</li>
</ul>
<h3 id="2-intermediate-week-3-4"><a class="header" href="#2-intermediate-week-3-4">2. Intermediate (Week 3-4)</a></h3>
<ul>
<li>SwiftData for persistence</li>
<li>Advanced SwiftUI patterns</li>
<li>Testing with Swift Testing</li>
</ul>
<h3 id="3-advanced-week-5-6"><a class="header" href="#3-advanced-week-5-6">3. Advanced (Week 5-6)</a></h3>
<ul>
<li>Performance optimization</li>
<li>Cross-platform development</li>
<li>App Store optimization</li>
</ul>
<h3 id="4-production-week-7-8"><a class="header" href="#4-production-week-7-8">4. Production (Week 7-8)</a></h3>
<ul>
<li>CI/CD with Xcode Cloud</li>
<li>Security best practices</li>
<li>Monitoring and analytics</li>
</ul>
<hr />
<p><em>Stay updated with Apple's official documentation and WWDC sessions for the latest developments.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-playgrounds-integration"><a class="header" href="#swift-playgrounds-integration">Swift Playgrounds Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apples-learning-path"><a class="header" href="#apples-learning-path">Apple's Learning Path</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-language-basics"><a class="header" href="#swift-language-basics">Swift Language Basics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections--control-flow"><a class="header" href="#collections--control-flow">Collections &amp; Control Flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions--closures"><a class="header" href="#functions--closures">Functions &amp; Closures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures--classes"><a class="header" href="#structures--classes">Structures &amp; Classes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols--generics"><a class="header" href="#protocols--generics">Protocols &amp; Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency--actors"><a class="header" href="#concurrency--actors">Concurrency &amp; Actors</a></h1>
<blockquote>
<p><strong>Stop data races. Write safe concurrent code.</strong></p>
</blockquote>
<h2 id="-the-problem-were-solving"><a class="header" href="#-the-problem-were-solving">üéØ The Problem We're Solving</a></h2>
<pre><code class="language-swift">// ‚ùå This crashes randomly
class DataManager {
    var items: [String] = []
    
    func addItem(_ item: String) {
        items.append(item) // CRASH: Data race!
    }
}

// Multiple threads calling addItem() = üí•
</code></pre>
<p><strong>The fix</strong>: Actors.</p>
<h2 id="-actors-your-new-best-friend"><a class="header" href="#-actors-your-new-best-friend">üöÄ Actors: Your New Best Friend</a></h2>
<pre><code class="language-swift">// ‚úÖ This is safe
actor DataManager {
    private var items: [String] = []
    
    func addItem(_ item: String) {
        items.append(item) // Safe! Actor protects this
    }
    
    func getItems() -&gt; [String] {
        items
    }
}

// Usage
let manager = DataManager()
await manager.addItem("Hello") // Note the 'await'
let items = await manager.getItems()
</code></pre>
<p><strong>What just happened</strong>:</p>
<ul>
<li>Actor ensures only ONE task accesses <code>items</code> at a time</li>
<li><code>await</code> means "this might wait for other tasks to finish"</li>
<li>No crashes, no data races, no locks needed</li>
</ul>
<h2 id="-real-example-image-downloader"><a class="header" href="#-real-example-image-downloader">üì± Real Example: Image Downloader</a></h2>
<pre><code class="language-swift">actor ImageCache {
    private var cache: [URL: UIImage] = [:]
    private var inProgress: [URL: Task&lt;UIImage, Error&gt;] = [:]
    
    func image(for url: URL) async throws -&gt; UIImage {
        // Check cache first
        if let cached = cache[url] {
            return cached
        }
        
        // Check if already downloading
        if let task = inProgress[url] {
            return try await task.value
        }
        
        // Start new download
        let task = Task {
            let (data, _) = try await URLSession.shared.data(from: url)
            guard let image = UIImage(data: data) else {
                throw ImageError.invalidData
            }
            return image
        }
        
        inProgress[url] = task
        
        do {
            let image = try await task.value
            cache[url] = image
            inProgress[url] = nil
            return image
        } catch {
            inProgress[url] = nil
            throw error
        }
    }
}

enum ImageError: Error {
    case invalidData
}

// Usage in SwiftUI
struct ImageView: View {
    let url: URL
    @State private var image: UIImage?
    let cache = ImageCache()
    
    var body: some View {
        Group {
            if let image {
                Image(uiImage: image)
                    .resizable()
            } else {
                ProgressView()
            }
        }
        .task {
            image = try? await cache.image(for: url)
        }
    }
}
</code></pre>
<p><strong>Why this is powerful</strong>:</p>
<ul>
<li>No duplicate downloads (checks <code>inProgress</code>)</li>
<li>Thread-safe caching</li>
<li>Automatic cleanup</li>
<li>Simple to use</li>
</ul>
<h2 id="-asyncawait-basics"><a class="header" href="#-asyncawait-basics">üîÑ async/await Basics</a></h2>
<h3 id="before-callback-hell"><a class="header" href="#before-callback-hell">Before (Callback Hell)</a></h3>
<pre><code class="language-swift">// ‚ùå Pyramid of doom
func loadUserData(completion: @escaping (User?) -&gt; Void) {
    fetchUserID { userID in
        guard let userID else {
            completion(nil)
            return
        }
        
        fetchUserProfile(userID) { profile in
            guard let profile else {
                completion(nil)
                return
            }
            
            fetchUserPosts(userID) { posts in
                let user = User(profile: profile, posts: posts)
                completion(user)
            }
        }
    }
}
</code></pre>
<h3 id="after-clean"><a class="header" href="#after-clean">After (Clean)</a></h3>
<pre><code class="language-swift">// ‚úÖ Linear and readable
func loadUserData() async throws -&gt; User {
    let userID = try await fetchUserID()
    let profile = try await fetchUserProfile(userID)
    let posts = try await fetchUserPosts(userID)
    
    return User(profile: profile, posts: posts)
}
</code></pre>
<p><strong>Difference</strong>: Code reads top-to-bottom. No nesting. Errors propagate naturally.</p>
<h2 id="-parallel-execution"><a class="header" href="#-parallel-execution">‚ö° Parallel Execution</a></h2>
<h3 id="sequential-slow"><a class="header" href="#sequential-slow">Sequential (Slow)</a></h3>
<pre><code class="language-swift">// Takes 6 seconds total
func loadData() async throws -&gt; (User, Posts, Comments) {
    let user = try await fetchUser() // 2 seconds
    let posts = try await fetchPosts() // 2 seconds
    let comments = try await fetchComments() // 2 seconds
    
    return (user, posts, comments)
}
</code></pre>
<h3 id="parallel-fast"><a class="header" href="#parallel-fast">Parallel (Fast)</a></h3>
<pre><code class="language-swift">// Takes 2 seconds total (all at once!)
func loadData() async throws -&gt; (User, Posts, Comments) {
    async let user = fetchUser()
    async let posts = fetchPosts()
    async let comments = fetchComments()
    
    return try await (user, posts, comments)
}
</code></pre>
<p><strong>Key</strong>: <code>async let</code> starts tasks immediately. <code>await</code> waits for all to finish.</p>
<h2 id="-task-groups-for-dynamic-work"><a class="header" href="#-task-groups-for-dynamic-work">üéØ Task Groups for Dynamic Work</a></h2>
<pre><code class="language-swift">func downloadImages(urls: [URL]) async throws -&gt; [UIImage] {
    try await withThrowingTaskGroup(of: UIImage.self) { group in
        // Start all downloads
        for url in urls {
            group.addTask {
                let (data, _) = try await URLSession.shared.data(from: url)
                guard let image = UIImage(data: data) else {
                    throw ImageError.invalidData
                }
                return image
            }
        }
        
        // Collect results
        var images: [UIImage] = []
        for try await image in group {
            images.append(image)
        }
        return images
    }
}

// Download 100 images in parallel!
let images = try await downloadImages(urls: imageURLs)
</code></pre>
<p><strong>Use case</strong>: When you don't know how many tasks you need upfront.</p>
<h2 id="-mainactor-for-ui-updates"><a class="header" href="#-mainactor-for-ui-updates">üîí @MainActor for UI Updates</a></h2>
<pre><code class="language-swift">@MainActor
class ViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    func loadItems() async {
        isLoading = true
        
        // This runs on background
        let fetchedItems = await fetchItemsFromAPI()
        
        // This automatically runs on main thread
        items = fetchedItems
        isLoading = false
    }
}

// Usage
struct ContentView: View {
    @StateObject private var viewModel = ViewModel()
    
    var body: some View {
        List(viewModel.items) { item in
            Text(item.name)
        }
        .task {
            await viewModel.loadItems()
        }
    }
}
</code></pre>
<p><strong>Magic</strong>: <code>@MainActor</code> ensures ALL property updates happen on main thread. No more crashes!</p>
<h2 id="-real-pattern-network-manager"><a class="header" href="#-real-pattern-network-manager">üé® Real Pattern: Network Manager</a></h2>
<pre><code class="language-swift">actor NetworkManager {
    static let shared = NetworkManager()
    
    private var session: URLSession
    
    init() {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30
        session = URLSession(configuration: config)
    }
    
    func fetch&lt;T: Decodable&gt;(_ type: T.Type, from url: URL) async throws -&gt; T {
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    func post&lt;T: Encodable, R: Decodable&gt;(
        _ data: T,
        to url: URL,
        expecting: R.Type
    ) async throws -&gt; R {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(data)
        
        let (responseData, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(R.self, from: responseData)
    }
}

enum NetworkError: Error {
    case invalidResponse
}

// Usage
struct User: Codable {
    let id: Int
    let name: String
}

let user = try await NetworkManager.shared.fetch(User.self, from: userURL)
</code></pre>
<p><strong>Why actor</strong>: Multiple views can call this safely. No race conditions.</p>
<h2 id="-common-mistakes"><a class="header" href="#-common-mistakes">üö® Common Mistakes</a></h2>
<h3 id="1-forgetting-await"><a class="header" href="#1-forgetting-await">1. Forgetting await</a></h3>
<pre><code class="language-swift">actor Counter {
    var count = 0
    
    func increment() {
        count += 1
    }
}

let counter = Counter()
counter.increment() // ‚ùå Error: Call to actor method must be 'await'
await counter.increment() // ‚úÖ Correct
</code></pre>
<h3 id="2-blocking-the-main-thread"><a class="header" href="#2-blocking-the-main-thread">2. Blocking the Main Thread</a></h3>
<pre><code class="language-swift">// ‚ùå Bad: Blocks UI
func loadData() {
    Task {
        let data = await fetchData()
        // Process data...
    }
}

// ‚úÖ Good: Non-blocking
func loadData() async {
    let data = await fetchData()
    // Process data...
}
</code></pre>
<h3 id="3-not-using-task-for-fire-and-forget"><a class="header" href="#3-not-using-task-for-fire-and-forget">3. Not Using Task for Fire-and-Forget</a></h3>
<pre><code class="language-swift">// ‚ùå Bad: Doesn't actually run
func saveData() {
    async {
        await database.save(data)
    }
}

// ‚úÖ Good: Runs in background
func saveData() {
    Task {
        await database.save(data)
    }
}
</code></pre>
<h2 id="-practical-exercise"><a class="header" href="#-practical-exercise">üéØ Practical Exercise</a></h2>
<p>Build a weather app that:</p>
<ol>
<li>Fetches weather for multiple cities in parallel</li>
<li>Caches results</li>
<li>Updates UI safely</li>
</ol>
<pre><code class="language-swift">actor WeatherCache {
    private var cache: [String: Weather] = [:]
    
    func weather(for city: String) async throws -&gt; Weather {
        if let cached = cache[city] {
            return cached
        }
        
        let weather = try await fetchWeather(for: city)
        cache[city] = weather
        return weather
    }
    
    private func fetchWeather(for city: String) async throws -&gt; Weather {
        let url = URL(string: "https://api.weather.com/\(city)")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode(Weather.self, from: data)
    }
}

@MainActor
class WeatherViewModel: ObservableObject {
    @Published var weatherData: [String: Weather] = [:]
    private let cache = WeatherCache()
    
    func loadWeather(for cities: [String]) async {
        await withTaskGroup(of: (String, Weather?).self) { group in
            for city in cities {
                group.addTask {
                    let weather = try? await self.cache.weather(for: city)
                    return (city, weather)
                }
            }
            
            for await (city, weather) in group {
                if let weather {
                    weatherData[city] = weather
                }
            }
        }
    }
}

struct Weather: Codable {
    let temperature: Double
    let condition: String
}
</code></pre>
<p><strong>Try it</strong>: Add error handling, retry logic, and offline support.</p>
<h2 id="-performance-tips"><a class="header" href="#-performance-tips">üìä Performance Tips</a></h2>
<ol>
<li><strong>Use actors for shared state</strong> (not locks)</li>
<li><strong>Batch UI updates</strong> (don't update 100 times/second)</li>
<li><strong>Cancel tasks</strong> when views disappear</li>
<li><strong>Use async let</strong> for independent work</li>
<li><strong>Profile with Instruments</strong> (Time Profiler)</li>
</ol>
<h2 id="-next-steps-1"><a class="header" href="#-next-steps-1">üîó Next Steps</a></h2>
<ul>
<li><a href="swift/./macros.html">Macros ‚Üí</a> - Generate code at compile time</li>
<li><a href="swift/./memory.html">Memory Management ‚Üí</a> - Understand ownership</li>
</ul>
<hr />
<p><strong>Key takeaway</strong>: Actors + async/await = safe, fast, readable concurrent code. Use them everywhere.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="launch-time-optimization"><a class="header" href="#launch-time-optimization">Launch Time Optimization</a></h1>
<blockquote>
<p><strong>Get your app launching in under 2 seconds - the difference between success and deletion</strong></p>
</blockquote>
<h2 id="-why-launch-time-matters"><a class="header" href="#-why-launch-time-matters">üéØ Why Launch Time Matters</a></h2>
<ul>
<li><strong>2+ seconds</strong>: Users notice lag, consider app "slow"</li>
<li><strong>5+ seconds</strong>: 25% of users abandon the app</li>
<li><strong>10+ seconds</strong>: App Store reviewers flag as "unresponsive"</li>
</ul>
<p>Real data from apps with 1M+ downloads shows launch time directly correlates with retention and ratings.</p>
<h2 id="-the-2-second-rule"><a class="header" href="#-the-2-second-rule">‚ö° The 2-Second Rule</a></h2>
<p>Apps that launch in under 2 seconds have:</p>
<ul>
<li><strong>40% higher</strong> Day 1 retention</li>
<li><strong>25% better</strong> App Store ratings</li>
<li><strong>3x more likely</strong> to be featured by Apple</li>
</ul>
<h2 id="-production-techniques"><a class="header" href="#-production-techniques">üîß Production Techniques</a></h2>
<h3 id="1-critical-path-analysis"><a class="header" href="#1-critical-path-analysis">1. Critical Path Analysis</a></h3>
<p>Only initialize what's needed for the first screen:</p>
<pre><code class="language-swift">class AppDelegate: UIApplicationDelegate {
    func application(_ application: UIApplication, 
                    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        
        // CRITICAL: First screen only
        setupWindow()
        initializeAuth() // Needed for login state
        
        // DEFERRED: Everything else
        Task.detached(priority: .utility) {
            await self.setupNonCriticalServices()
        }
        
        return true
    }
    
    private func setupNonCriticalServices() async {
        // Analytics, crash reporting, etc.
        await Analytics.initialize()
        await CrashReporter.setup()
        await NotificationManager.configure()
    }
}
</code></pre>
<h3 id="2-lazy-loading-pattern"><a class="header" href="#2-lazy-loading-pattern">2. Lazy Loading Pattern</a></h3>
<p>Don't create objects until they're actually used:</p>
<pre><code class="language-swift">class DataManager {
    // Bad: Creates database connection immediately
    // private let database = Database()
    
    // Good: Creates only when first accessed
    private lazy var database: Database = {
        return Database(configuration: .production)
    }()
    
    // Even better: Async lazy loading
    private var _database: Database?
    private func getDatabase() async -&gt; Database {
        if let db = _database { return db }
        
        let db = await Database.create(configuration: .production)
        _database = db
        return db
    }
}
</code></pre>
<h3 id="3-precomputed-launch-data"><a class="header" href="#3-precomputed-launch-data">3. Precomputed Launch Data</a></h3>
<p>Cache expensive computations at app termination:</p>
<pre><code class="language-swift">class LaunchDataCache {
    private static let cacheKey = "launch_data_cache"
    
    // Save expensive data when app backgrounds
    func cacheForNextLaunch() {
        let launchData = LaunchData(
            userPreferences: UserDefaults.standard.dictionary(forKey: "prefs"),
            recentItems: RecentItemsManager.shared.items,
            themeConfiguration: ThemeManager.shared.currentTheme
        )
        
        UserDefaults.standard.set(try? JSONEncoder().encode(launchData), forKey: Self.cacheKey)
    }
    
    // Load instantly at launch
    func loadCachedData() -&gt; LaunchData? {
        guard let data = UserDefaults.standard.data(forKey: Self.cacheKey),
              let launchData = try? JSONDecoder().decode(LaunchData.self, from: data) else {
            return nil
        }
        return launchData
    }
}
</code></pre>
<h3 id="4-image-loading-optimization"><a class="header" href="#4-image-loading-optimization">4. Image Loading Optimization</a></h3>
<p>Preload critical images, lazy load everything else:</p>
<pre><code class="language-swift">class ImagePreloader {
    private let criticalImages = ["app_icon", "splash_logo", "default_avatar"]
    
    func preloadCriticalImages() {
        for imageName in criticalImages {
            // Load into memory cache
            if let image = UIImage(named: imageName) {
                ImageCache.shared.store(image, forKey: imageName)
            }
        }
    }
}

// In your first view controller
class MainViewController: UIViewController {
    @IBOutlet weak var profileImageView: UIImageView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Show cached placeholder immediately
        profileImageView.image = ImageCache.shared.image(forKey: "default_avatar")
        
        // Load real image asynchronously
        Task {
            let userImage = await UserImageLoader.loadImage(for: currentUser.id)
            await MainActor.run {
                profileImageView.image = userImage
            }
        }
    }
}
</code></pre>
<h2 id="-measuring-launch-performance"><a class="header" href="#-measuring-launch-performance">üìä Measuring Launch Performance</a></h2>
<h3 id="1-built-in-metrics"><a class="header" href="#1-built-in-metrics">1. Built-in Metrics</a></h3>
<pre><code class="language-swift">import os.signpost

class LaunchMetrics {
    private static let log = OSLog(subsystem: "com.yourapp.performance", category: "launch")
    
    static func startLaunchMeasurement() {
        os_signpost(.begin, log: log, name: "AppLaunch")
    }
    
    static func endLaunchMeasurement() {
        os_signpost(.end, log: log, name: "AppLaunch")
    }
    
    // Call this when first screen is fully loaded
    static func markFirstScreenReady() {
        os_signpost(.event, log: log, name: "FirstScreenReady")
    }
}
</code></pre>
<h3 id="2-custom-analytics"><a class="header" href="#2-custom-analytics">2. Custom Analytics</a></h3>
<pre><code class="language-swift">class LaunchAnalytics {
    static func trackLaunchTime(_ duration: TimeInterval) {
        // Send to your analytics service
        Analytics.track("app_launch_time", parameters: [
            "duration_ms": Int(duration * 1000),
            "device_model": UIDevice.current.model,
            "ios_version": UIDevice.current.systemVersion
        ])
        
        // Flag slow launches for investigation
        if duration &gt; 3.0 {
            Analytics.track("slow_launch", parameters: [
                "duration_ms": Int(duration * 1000)
            ])
        }
    }
}
</code></pre>
<h2 id="-common-launch-killers"><a class="header" href="#-common-launch-killers">üö´ Common Launch Killers</a></h2>
<h3 id="1-synchronous-network-calls"><a class="header" href="#1-synchronous-network-calls">1. Synchronous Network Calls</a></h3>
<pre><code class="language-swift">// ‚ùå NEVER do this at launch
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // This blocks the main thread!
    let config = try! URLSession.shared.synchronousDataTask(with: configURL)
    return true
}

// ‚úÖ Always async
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    Task {
        await loadRemoteConfiguration()
    }
    return true
}
</code></pre>
<h3 id="2-heavy-core-data-setup"><a class="header" href="#2-heavy-core-data-setup">2. Heavy Core Data Setup</a></h3>
<pre><code class="language-swift">// ‚ùå Slow: Full database initialization
lazy var persistentContainer: NSPersistentContainer = {
    let container = NSPersistentContainer(name: "DataModel")
    container.loadPersistentStores { _, error in
        // This can take seconds!
    }
    return container
}()

// ‚úÖ Fast: Lightweight setup with background loading
lazy var persistentContainer: NSPersistentContainer = {
    let container = NSPersistentContainer(name: "DataModel")
    
    // Configure for fast launch
    let description = container.persistentStoreDescriptions.first
    description?.shouldMigrateStoreAutomatically = false
    description?.shouldInferMappingModelAutomatically = false
    
    container.loadPersistentStores { _, error in
        if error != nil {
            // Handle error without blocking launch
            Task { await self.handleDatabaseError() }
        }
    }
    return container
}()
</code></pre>
<h3 id="3-excessive-view-controller-setup"><a class="header" href="#3-excessive-view-controller-setup">3. Excessive View Controller Setup</a></h3>
<pre><code class="language-swift">// ‚ùå Heavy view controller initialization
class MainViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // All of this blocks the UI thread
        setupComplexAnimations()
        loadAllUserData()
        configureAllSubviews()
        preloadAllImages()
    }
}

// ‚úÖ Staged loading
class MainViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Only essential UI setup
        setupBasicUI()
        
        // Defer heavy operations
        Task {
            await loadUserData()
            await MainActor.run { self.updateUIWithData() }
        }
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        // Now it's safe to do expensive operations
        setupComplexAnimations()
        preloadNextScreenData()
    }
}
</code></pre>
<h2 id="-production-checklist"><a class="header" href="#-production-checklist">üéØ Production Checklist</a></h2>
<h3 id="before-app-store-submission"><a class="header" href="#before-app-store-submission">Before App Store Submission</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Launch time &lt; 2 seconds on oldest supported device</li>
<li><input disabled="" type="checkbox"/>
No synchronous network calls in launch path</li>
<li><input disabled="" type="checkbox"/>
Critical images preloaded and cached</li>
<li><input disabled="" type="checkbox"/>
Database operations moved to background</li>
<li><input disabled="" type="checkbox"/>
Launch metrics implemented and tested</li>
<li><input disabled="" type="checkbox"/>
Tested on slow network conditions</li>
<li><input disabled="" type="checkbox"/>
Memory usage optimized for launch</li>
</ul>
<h3 id="monitoring-in-production"><a class="header" href="#monitoring-in-production">Monitoring in Production</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Launch time analytics tracking</li>
<li><input disabled="" type="checkbox"/>
Crash reporting for launch failures</li>
<li><input disabled="" type="checkbox"/>
Performance regression alerts</li>
<li><input disabled="" type="checkbox"/>
A/B testing for launch optimizations</li>
</ul>
<h2 id="-real-results"><a class="header" href="#-real-results">üìà Real Results</a></h2>
<p>Apps implementing these patterns typically see:</p>
<ul>
<li><strong>60% reduction</strong> in launch time</li>
<li><strong>25% improvement</strong> in Day 1 retention</li>
<li><strong>40% fewer</strong> 1-star reviews mentioning "slow"</li>
<li><strong>15% increase</strong> in App Store rating</li>
</ul>
<hr />
<p><strong>Next:</strong> <a href="performance/./memory-optimization.html">Memory Management ‚Üí</a> - Keep your app running smoothly under pressure</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-efficiency"><a class="header" href="#battery-efficiency">Battery Efficiency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-performance"><a class="header" href="#network-performance">Network Performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-intelligence-integration"><a class="header" href="#apple-intelligence-integration">Apple Intelligence Integration</a></h1>
<blockquote>
<p>Integrate Apple's AI capabilities using real frameworks available in iOS 18+</p>
</blockquote>
<h2 id="-what-is-apple-intelligence"><a class="header" href="#-what-is-apple-intelligence">üß† What is Apple Intelligence?</a></h2>
<p>Apple Intelligence is Apple's personal intelligence system that:</p>
<ul>
<li>Uses on-device processing for privacy</li>
<li>Integrates with Siri and system apps</li>
<li>Provides writing tools and smart replies</li>
<li>Works across iPhone, iPad, and Mac</li>
</ul>
<h2 id="-real-implementation-with-available-apis"><a class="header" href="#-real-implementation-with-available-apis">üîß Real Implementation with Available APIs</a></h2>
<h3 id="1-natural-language-processing"><a class="header" href="#1-natural-language-processing">1. Natural Language Processing</a></h3>
<p>Use the actual NaturalLanguage framework:</p>
<pre><code class="language-swift">import NaturalLanguage

class TextAnalyzer {
    func analyzeText(_ text: String) -&gt; TextAnalysis {
        let tagger = NLTagger(tagSchemes: [.sentimentScore, .language, .nameType])
        tagger.string = text
        
        // Get sentiment
        let sentiment = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)
        
        // Get language
        let language = tagger.dominantLanguage
        
        // Extract named entities
        let entities = extractEntities(from: text)
        
        return TextAnalysis(
            sentiment: sentiment?.rawValue,
            language: language?.rawValue,
            entities: entities
        )
    }
    
    private func extractEntities(from text: String) -&gt; [String] {
        let tagger = NLTagger(tagSchemes: [.nameType])
        tagger.string = text
        
        var entities: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .nameType) { tag, tokenRange in
            if let tag = tag {
                let entity = String(text[tokenRange])
                entities.append(entity)
            }
            return true
        }
        return entities
    }
}

struct TextAnalysis {
    let sentiment: String?
    let language: String?
    let entities: [String]
}
</code></pre>
<h3 id="2-app-intents-integration"><a class="header" href="#2-app-intents-integration">2. App Intents Integration</a></h3>
<p>Create Siri shortcuts that work with Apple Intelligence:</p>
<pre><code class="language-swift">import AppIntents

struct SummarizeTextIntent: AppIntent {
    static var title: LocalizedStringResource = "Summarize Text"
    static var description = IntentDescription("Summarize the provided text")
    
    @Parameter(title: "Text to Summarize")
    var inputText: String
    
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        // Use actual text processing
        let summary = await createSummary(from: inputText)
        
        return .result(
            value: summary,
            dialog: "Here's your summary"
        )
    }
    
    private func createSummary(from text: String) async -&gt; String {
        // Simple extractive summarization using NaturalLanguage
        let sentences = text.components(separatedBy: ". ")
        let keyPhrases = extractKeyPhrases(from: text)
        
        // Return sentences containing key phrases
        let importantSentences = sentences.filter { sentence in
            keyPhrases.contains { sentence.localizedCaseInsensitiveContains($0) }
        }
        
        return importantSentences.prefix(3).joined(separator: ". ")
    }
    
    private func extractKeyPhrases(from text: String) -&gt; [String] {
        let tagger = NLTagger(tagSchemes: [.lemma])
        tagger.string = text
        
        var phrases: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lemma) { tag, tokenRange in
            if let lemma = tag?.rawValue, lemma.count &gt; 4 {
                phrases.append(lemma)
            }
            return true
        }
        return Array(Set(phrases)).prefix(5).map { String($0) }
    }
}
</code></pre>
<h3 id="3-core-ml-integration"><a class="header" href="#3-core-ml-integration">3. Core ML Integration</a></h3>
<p>Use real Core ML for on-device intelligence:</p>
<pre><code class="language-swift">import CoreML
import Vision

class ImageAnalyzer {
    private var model: VNCoreMLModel?
    
    init() {
        setupModel()
    }
    
    private func setupModel() {
        guard let modelURL = Bundle.main.url(forResource: "MobileNetV2", withExtension: "mlmodelc"),
              let model = try? VNCoreMLModel(for: MLModel(contentsOf: modelURL)) else {
            print("Failed to load Core ML model")
            return
        }
        self.model = model
    }
    
    func analyzeImage(_ image: UIImage) async throws -&gt; [ImageClassification] {
        guard let model = model,
              let cgImage = image.cgImage else {
            throw AnalysisError.modelNotAvailable
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            let request = VNCoreMLRequest(model: model) { request, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                guard let results = request.results as? [VNClassificationObservation] else {
                    continuation.resume(returning: [])
                    return
                }
                
                let classifications = results.prefix(5).map { observation in
                    ImageClassification(
                        label: observation.identifier,
                        confidence: observation.confidence
                    )
                }
                
                continuation.resume(returning: classifications)
            }
            
            let handler = VNImageRequestHandler(cgImage: cgImage)
            try? handler.perform([request])
        }
    }
}

struct ImageClassification {
    let label: String
    let confidence: Float
}

enum AnalysisError: Error {
    case modelNotAvailable
}
</code></pre>
<h2 id="-swiftui-integration"><a class="header" href="#-swiftui-integration">üì± SwiftUI Integration</a></h2>
<h3 id="smart-text-input-with-real-apis"><a class="header" href="#smart-text-input-with-real-apis">Smart Text Input with Real APIs</a></h3>
<pre><code class="language-swift">import SwiftUI
import NaturalLanguage

struct SmartTextEditor: View {
    @State private var text = ""
    @State private var suggestions: [String] = []
    @State private var language: String = "Unknown"
    
    var body: some View {
        VStack {
            TextEditor(text: $text)
                .onChange(of: text) { newValue in
                    analyzeText(newValue)
                }
                .frame(minHeight: 200)
            
            HStack {
                Text("Language: \(language)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
            }
            
            if !suggestions.isEmpty {
                VStack(alignment: .leading) {
                    Text("Suggestions:")
                        .font(.headline)
                    
                    ForEach(suggestions, id: \.self) { suggestion in
                        Button(suggestion) {
                            text += " " + suggestion
                        }
                        .buttonStyle(.bordered)
                    }
                }
            }
        }
        .padding()
    }
    
    private func analyzeText(_ text: String) {
        guard !text.isEmpty else { return }
        
        // Detect language
        let recognizer = NLLanguageRecognizer()
        recognizer.processString(text)
        if let detectedLanguage = recognizer.dominantLanguage {
            language = Locale.current.localizedString(forLanguageCode: detectedLanguage.rawValue) ?? detectedLanguage.rawValue
        }
        
        // Generate simple suggestions based on text analysis
        generateSuggestions(for: text)
    }
    
    private func generateSuggestions(for text: String) {
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        var nouns: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lexicalClass) { tag, tokenRange in
            if tag == .noun {
                let noun = String(text[tokenRange])
                nouns.append(noun)
            }
            return true
        }
        
        // Simple suggestion logic
        suggestions = Array(Set(nouns)).prefix(3).map { "related to \($0)" }
    }
}
</code></pre>
<h2 id="-real-world-applications"><a class="header" href="#-real-world-applications">üéØ Real-World Applications</a></h2>
<h3 id="1-smart-note-taking-app"><a class="header" href="#1-smart-note-taking-app">1. Smart Note Taking App</a></h3>
<pre><code class="language-swift">import SwiftUI
import NaturalLanguage

struct SmartNotesApp: View {
    @State private var notes: [Note] = []
    @State private var searchText = ""
    
    var filteredNotes: [Note] {
        if searchText.isEmpty {
            return notes
        }
        return notes.filter { note in
            note.content.localizedCaseInsensitiveContains(searchText) ||
            note.tags.contains { $0.localizedCaseInsensitiveContains(searchText) }
        }
    }
    
    var body: some View {
        NavigationView {
            List {
                ForEach(filteredNotes) { note in
                    NoteRow(note: note)
                }
            }
            .searchable(text: $searchText)
            .navigationTitle("Smart Notes")
            .toolbar {
                Button("Add Note") {
                    addNewNote()
                }
            }
        }
    }
    
    private func addNewNote() {
        let newNote = Note(content: "New note", tags: [])
        notes.append(newNote)
    }
}

struct Note: Identifiable {
    let id = UUID()
    var content: String
    var tags: [String]
    let createdAt = Date()
    
    init(content: String, tags: [String] = []) {
        self.content = content
        self.tags = tags.isEmpty ? generateTags(from: content) : tags
    }
}

func generateTags(from content: String) -&gt; [String] {
    let tagger = NLTagger(tagSchemes: [.nameType, .lexicalClass])
    tagger.string = content
    
    var tags: [String] = []
    
    // Extract named entities as tags
    tagger.enumerateTags(in: content.startIndex..&lt;content.endIndex, unit: .word, scheme: .nameType) { tag, tokenRange in
        if let tag = tag, tag != .other {
            let entity = String(content[tokenRange])
            tags.append(entity.lowercased())
        }
        return true
    }
    
    return Array(Set(tags)).prefix(5).map { String($0) }
}

struct NoteRow: View {
    let note: Note
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(note.content)
                .lineLimit(2)
            
            HStack {
                ForEach(note.tags.prefix(3), id: \.self) { tag in
                    Text(tag)
                        .font(.caption)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.blue.opacity(0.2))
                        .cornerRadius(4)
                }
                
                Spacer()
                
                Text(note.createdAt, style: .date)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 2)
    }
}
</code></pre>
<h2 id="-privacy-best-practices"><a class="header" href="#-privacy-best-practices">üîí Privacy Best Practices</a></h2>
<h3 id="on-device-processing"><a class="header" href="#on-device-processing">On-Device Processing</a></h3>
<pre><code class="language-swift">class PrivacyFirstProcessor {
    func processText(_ text: String) -&gt; ProcessedResult {
        // All processing happens locally
        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text
        
        let sentiment = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)
        
        return ProcessedResult(
            sentiment: sentiment?.rawValue ?? "neutral",
            processedLocally: true
        )
    }
}

struct ProcessedResult {
    let sentiment: String
    let processedLocally: Bool
}
</code></pre>
<h2 id="-resources"><a class="header" href="#-resources">üìö Resources</a></h2>
<ul>
<li><strong><a href="https://developer.apple.com/documentation/naturallanguage">Natural Language Framework</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/coreml">Core ML Documentation</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/appintents">App Intents Framework</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/vision">Vision Framework</a></strong></li>
</ul>
<hr />
<p><em>This implementation uses real Apple frameworks available today, not fictional APIs.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-ml-8-features"><a class="header" href="#core-ml-8-features">Core ML 8 Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-device-processing-1"><a class="header" href="#on-device-processing-1">On-Device Processing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="siri-app-intents"><a class="header" href="#siri-app-intents">Siri App Intents</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftdata---modern-data-persistence"><a class="header" href="#swiftdata---modern-data-persistence">SwiftData - Modern Data Persistence</a></h1>
<blockquote>
<p>Apple's declarative data modeling framework for Swift applications</p>
</blockquote>
<h2 id="-what-is-swiftdata"><a class="header" href="#-what-is-swiftdata">üéØ What is SwiftData?</a></h2>
<p>SwiftData is Apple's modern replacement for Core Data, providing:</p>
<ul>
<li><strong>Declarative syntax</strong> with Swift macros</li>
<li><strong>Type safety</strong> at compile time</li>
<li><strong>Automatic CloudKit sync</strong> capabilities</li>
<li><strong>SwiftUI integration</strong> out of the box</li>
</ul>
<h2 id="-getting-started"><a class="header" href="#-getting-started">üöÄ Getting Started</a></h2>
<h3 id="basic-model-definition"><a class="header" href="#basic-model-definition">Basic Model Definition</a></h3>
<pre><code class="language-swift">import SwiftData

@Model
class Task {
    var title: String
    var isCompleted: Bool
    var createdAt: Date
    var priority: Priority
    
    init(title: String, priority: Priority = .medium) {
        self.title = title
        self.isCompleted = false
        self.createdAt = Date()
        self.priority = priority
    }
}

enum Priority: String, Codable, CaseIterable {
    case low, medium, high
}
</code></pre>
<h3 id="app-setup"><a class="header" href="#app-setup">App Setup</a></h3>
<pre><code class="language-swift">import SwiftUI
import SwiftData

@main
struct TaskApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: Task.self)
    }
}
</code></pre>
<h2 id="-swiftui-integration-1"><a class="header" href="#-swiftui-integration-1">üì± SwiftUI Integration</a></h2>
<h3 id="querying-data"><a class="header" href="#querying-data">Querying Data</a></h3>
<pre><code class="language-swift">struct TaskListView: View {
    @Query private var tasks: [Task]
    @Environment(\.modelContext) private var context
    
    var body: some View {
        List {
            ForEach(tasks) { task in
                TaskRow(task: task)
            }
            .onDelete(perform: deleteTasks)
        }
    }
    
    private func deleteTasks(offsets: IndexSet) {
        for index in offsets {
            context.delete(tasks[index])
        }
    }
}
</code></pre>
<h3 id="adding-data"><a class="header" href="#adding-data">Adding Data</a></h3>
<pre><code class="language-swift">struct AddTaskView: View {
    @Environment(\.modelContext) private var context
    @State private var title = ""
    
    var body: some View {
        NavigationView {
            Form {
                TextField("Task Title", text: $title)
                
                Button("Save") {
                    let task = Task(title: title)
                    context.insert(task)
                    try? context.save()
                }
            }
        }
    }
}
</code></pre>
<h2 id="-relationships"><a class="header" href="#-relationships">üîó Relationships</a></h2>
<h3 id="one-to-many"><a class="header" href="#one-to-many">One-to-Many</a></h3>
<pre><code class="language-swift">@Model
class Project {
    var name: String
    var tasks: [Task] = []
    
    init(name: String) {
        self.name = name
    }
}

@Model
class Task {
    var title: String
    var project: Project?
    
    init(title: String, project: Project? = nil) {
        self.title = title
        self.project = project
    }
}
</code></pre>
<h3 id="many-to-many"><a class="header" href="#many-to-many">Many-to-Many</a></h3>
<pre><code class="language-swift">@Model
class Tag {
    var name: String
    var tasks: [Task] = []
    
    init(name: String) {
        self.name = name
    }
}

@Model
class Task {
    var title: String
    var tags: [Tag] = []
    
    init(title: String) {
        self.title = title
    }
}
</code></pre>
<h2 id="-advanced-querying"><a class="header" href="#-advanced-querying">üîç Advanced Querying</a></h2>
<h3 id="filtered-queries"><a class="header" href="#filtered-queries">Filtered Queries</a></h3>
<pre><code class="language-swift">struct CompletedTasksView: View {
    @Query(filter: #Predicate&lt;Task&gt; { $0.isCompleted })
    private var completedTasks: [Task]
    
    var body: some View {
        List(completedTasks) { task in
            Text(task.title)
        }
    }
}
</code></pre>
<h3 id="sorted-queries"><a class="header" href="#sorted-queries">Sorted Queries</a></h3>
<pre><code class="language-swift">struct TaskListView: View {
    @Query(sort: \Task.createdAt, order: .reverse)
    private var tasks: [Task]
    
    var body: some View {
        List(tasks) { task in
            TaskRow(task: task)
        }
    }
}
</code></pre>
<h3 id="dynamic-queries"><a class="header" href="#dynamic-queries">Dynamic Queries</a></h3>
<pre><code class="language-swift">struct FilteredTasksView: View {
    let searchText: String
    
    var body: some View {
        FilteredTasksList(searchText: searchText)
    }
}

struct FilteredTasksList: View {
    @Query private var tasks: [Task]
    
    init(searchText: String) {
        let predicate = #Predicate&lt;Task&gt; { task in
            searchText.isEmpty || task.title.localizedStandardContains(searchText)
        }
        _tasks = Query(filter: predicate, sort: \Task.createdAt)
    }
    
    var body: some View {
        List(tasks) { task in
            Text(task.title)
        }
    }
}
</code></pre>
<h2 id="-cloudkit-integration"><a class="header" href="#-cloudkit-integration">‚òÅÔ∏è CloudKit Integration</a></h2>
<h3 id="enable-cloudkit-sync"><a class="header" href="#enable-cloudkit-sync">Enable CloudKit Sync</a></h3>
<pre><code class="language-swift">@main
struct TaskApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: Task.self) { result in
            switch result {
            case .success(let container):
                // Enable CloudKit sync
                container.mainContext.cloudKitContainer = CKContainer.default()
            case .failure(let error):
                print("Failed to create container: \(error)")
            }
        }
    }
}
</code></pre>
<h3 id="cloudkit-configuration"><a class="header" href="#cloudkit-configuration">CloudKit Configuration</a></h3>
<pre><code class="language-swift">// In your model
@Model
class Task {
    @Attribute(.unique) var id: UUID
    var title: String
    var isCompleted: Bool
    
    init(title: String) {
        self.id = UUID()
        self.title = title
        self.isCompleted = false
    }
}
</code></pre>
<h2 id="-best-practices"><a class="header" href="#-best-practices">üéØ Best Practices</a></h2>
<h3 id="model-design"><a class="header" href="#model-design">Model Design</a></h3>
<pre><code class="language-swift">@Model
class Task {
    // Use @Attribute for special configurations
    @Attribute(.unique) var id: UUID
    @Attribute(.spotlight) var title: String
    
    // Use relationships for complex data
    @Relationship(deleteRule: .cascade) var subtasks: [Subtask] = []
    
    // Computed properties for derived data
    var isOverdue: Bool {
        guard let dueDate = dueDate else { return false }
        return dueDate &lt; Date() &amp;&amp; !isCompleted
    }
    
    init(title: String) {
        self.id = UUID()
        self.title = title
    }
}
</code></pre>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<pre><code class="language-swift">// Use batch operations for large datasets
extension ModelContext {
    func batchDelete&lt;T: PersistentModel&gt;(_ type: T.Type, predicate: Predicate&lt;T&gt;) throws {
        let descriptor = FetchDescriptor&lt;T&gt;(predicate: predicate)
        let objects = try fetch(descriptor)
        
        for object in objects {
            delete(object)
        }
        
        try save()
    }
}
</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><code class="language-swift">class DataManager: ObservableObject {
    let container: ModelContainer
    
    init() {
        do {
            container = try ModelContainer(for: Task.self)
        } catch {
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }
    
    func saveContext() {
        do {
            try container.mainContext.save()
        } catch {
            print("Failed to save context: \(error)")
        }
    }
}
</code></pre>
<h2 id="-migration-from-core-data"><a class="header" href="#-migration-from-core-data">üìä Migration from Core Data</a></h2>
<h3 id="model-conversion"><a class="header" href="#model-conversion">Model Conversion</a></h3>
<pre><code class="language-swift">// Core Data (old)
@NSManaged public var title: String?
@NSManaged public var isCompleted: Bool

// SwiftData (new)
var title: String
var isCompleted: Bool
</code></pre>
<h3 id="context-usage"><a class="header" href="#context-usage">Context Usage</a></h3>
<pre><code class="language-swift">// Core Data (old)
let context = persistentContainer.viewContext
let task = Task(context: context)

// SwiftData (new)
@Environment(\.modelContext) private var context
let task = Task(title: "New Task")
context.insert(task)
</code></pre>
<h2 id="-testing-swiftdata"><a class="header" href="#-testing-swiftdata">üîß Testing SwiftData</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<pre><code class="language-swift">import Testing
import SwiftData

@Test func testTaskCreation() throws {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try ModelContainer(for: Task.self, configurations: config)
    let context = container.mainContext
    
    let task = Task(title: "Test Task")
    context.insert(task)
    
    #expect(task.title == "Test Task")
    #expect(task.isCompleted == false)
}
</code></pre>
<hr />
<p><em>SwiftData provides a modern, Swift-native approach to data persistence with seamless SwiftUI integration.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloudkit"><a class="header" href="#cloudkit">Cloudkit</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-ml-machine-learning"><a class="header" href="#core-ml-machine-learning">Core ML (Machine Learning)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgetkit"><a class="header" href="#widgetkit">WidgetKit</a></h1>
<blockquote>
<p><strong>Build a weather widget in 20 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">üéØ What You'll Build</a></h2>
<p>A home screen widget that:</p>
<ul>
<li>‚úÖ Shows live data</li>
<li>‚úÖ Updates automatically</li>
<li>‚úÖ Multiple sizes</li>
<li>‚úÖ Interactive buttons</li>
<li>‚úÖ Deep links to app</li>
</ul>
<h2 id="-step-1-create-widget-extension"><a class="header" href="#-step-1-create-widget-extension">üöÄ Step 1: Create Widget Extension</a></h2>
<p>In Xcode: <strong>File ‚Üí New ‚Üí Target ‚Üí Widget Extension</strong></p>
<p>Name it: <code>WeatherWidget</code></p>
<h2 id="-step-2-basic-widget"><a class="header" href="#-step-2-basic-widget">üì± Step 2: Basic Widget</a></h2>
<pre><code class="language-swift">import WidgetKit
import SwiftUI

struct WeatherWidget: Widget {
    let kind: String = "WeatherWidget"
    
    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider()) { entry in
            WeatherWidgetView(entry: entry)
        }
        .configurationDisplayName("Weather")
        .description("Current weather conditions")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}

struct WeatherEntry: TimelineEntry {
    let date: Date
    let temperature: Int
    let condition: String
    let icon: String
}

struct Provider: TimelineProvider {
    func placeholder(in context: Context) -&gt; WeatherEntry {
        WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    }
    
    func getSnapshot(in context: Context, completion: @escaping (WeatherEntry) -&gt; Void) {
        let entry = WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
        completion(entry)
    }
    
    func getTimeline(in context: Context, completion: @escaping (Timeline&lt;WeatherEntry&gt;) -&gt; Void) {
        Task {
            let weather = try await fetchWeather()
            let entry = WeatherEntry(
                date: Date(),
                temperature: weather.temperature,
                condition: weather.condition,
                icon: weather.icon
            )
            
            // Update every 15 minutes
            let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: Date())!
            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
            completion(timeline)
        }
    }
    
    private func fetchWeather() async throws -&gt; Weather {
        // Fetch from API
        Weather(temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    }
}

struct WeatherWidgetView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Image(systemName: entry.icon)
                .font(.largeTitle)
            Text("\(entry.temperature)¬∞")
                .font(.title)
            Text(entry.condition)
                .font(.caption)
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct Weather {
    let temperature: Int
    let condition: String
    let icon: String
}
</code></pre>
<h2 id="-multiple-sizes"><a class="header" href="#-multiple-sizes">üé® Multiple Sizes</a></h2>
<pre><code class="language-swift">struct WeatherWidgetView: View {
    let entry: WeatherEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        switch family {
        case .systemSmall:
            SmallWeatherView(entry: entry)
        case .systemMedium:
            MediumWeatherView(entry: entry)
        case .systemLarge:
            LargeWeatherView(entry: entry)
        default:
            SmallWeatherView(entry: entry)
        }
    }
}

struct SmallWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: entry.icon)
                .font(.system(size: 40))
            Text("\(entry.temperature)¬∞")
                .font(.system(size: 36, weight: .bold))
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct MediumWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text("\(entry.temperature)¬∞")
                    .font(.system(size: 48, weight: .bold))
                Text(entry.condition)
                    .font(.title3)
            }
            
            Spacer()
            
            Image(systemName: entry.icon)
                .font(.system(size: 60))
        }
        .padding()
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct LargeWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack(spacing: 20) {
            HStack {
                Text("\(entry.temperature)¬∞")
                    .font(.system(size: 72, weight: .bold))
                Image(systemName: entry.icon)
                    .font(.system(size: 72))
            }
            
            Text(entry.condition)
                .font(.title)
            
            // Hourly forecast
            HStack {
                ForEach(0..&lt;5) { hour in
                    VStack {
                        Text("\(hour + 1)h")
                            .font(.caption)
                        Image(systemName: "cloud.fill")
                        Text("70¬∞")
                            .font(.caption)
                    }
                }
            }
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}
</code></pre>
<h2 id="-interactive-widgets"><a class="header" href="#-interactive-widgets">üîÑ Interactive Widgets</a></h2>
<pre><code class="language-swift">import AppIntents

struct RefreshWeatherIntent: AppIntent {
    static var title: LocalizedStringResource = "Refresh Weather"
    
    func perform() async throws -&gt; some IntentResult {
        // Trigger widget refresh
        WidgetCenter.shared.reloadAllTimelines()
        return .result()
    }
}

struct InteractiveWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Text("\(entry.temperature)¬∞")
                .font(.largeTitle)
            
            Button(intent: RefreshWeatherIntent()) {
                Label("Refresh", systemImage: "arrow.clockwise")
            }
            .buttonStyle(.bordered)
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}
</code></pre>
<h2 id="-deep-links"><a class="header" href="#-deep-links">üéØ Deep Links</a></h2>
<pre><code class="language-swift">struct WeatherWidgetView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Text("\(entry.temperature)¬∞")
                .font(.largeTitle)
        }
        .containerBackground(.blue.gradient, for: .widget)
        .widgetURL(URL(string: "myapp://weather")!)
    }
}

// In main app
.onOpenURL { url in
    if url.scheme == "myapp", url.host == "weather" {
        // Navigate to weather screen
    }
}
</code></pre>
<h2 id="-app-intent-configuration"><a class="header" href="#-app-intent-configuration">üìä App Intent Configuration</a></h2>
<pre><code class="language-swift">struct WeatherWidget: Widget {
    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: "WeatherWidget",
            intent: WeatherConfigIntent.self,
            provider: Provider()
        ) { entry in
            WeatherWidgetView(entry: entry)
        }
    }
}

struct WeatherConfigIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "Weather Location"
    
    @Parameter(title: "City")
    var city: String?
}
</code></pre>
<h2 id="-lock-screen-widgets"><a class="header" href="#-lock-screen-widgets">üé® Lock Screen Widgets</a></h2>
<pre><code class="language-swift">struct LockScreenWidget: Widget {
    var body: some WidgetConfiguration {
        StaticConfiguration(kind: "LockScreen", provider: Provider()) { entry in
            LockScreenView(entry: entry)
        }
        .supportedFamilies([
            .accessoryCircular,
            .accessoryRectangular,
            .accessoryInline
        ])
    }
}

struct LockScreenView: View {
    let entry: WeatherEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        switch family {
        case .accessoryCircular:
            Gauge(value: Double(entry.temperature), in: 0...100) {
                Image(systemName: entry.icon)
            }
            
        case .accessoryRectangular:
            HStack {
                Image(systemName: entry.icon)
                VStack(alignment: .leading) {
                    Text("\(entry.temperature)¬∞")
                        .font(.headline)
                    Text(entry.condition)
                        .font(.caption)
                }
            }
            
        case .accessoryInline:
            Text("\(entry.temperature)¬∞ \(entry.condition)")
            
        default:
            EmptyView()
        }
    }
}
</code></pre>
<h2 id="-live-activities"><a class="header" href="#-live-activities">üîÑ Live Activities</a></h2>
<pre><code class="language-swift">import ActivityKit

struct WeatherActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var temperature: Int
        var condition: String
    }
    
    var city: String
}

// Start activity
func startWeatherActivity() throws {
    let attributes = WeatherActivityAttributes(city: "Detroit")
    let state = WeatherActivityAttributes.ContentState(
        temperature: 72,
        condition: "Sunny"
    )
    
    let activity = try Activity.request(
        attributes: attributes,
        content: .init(state: state, staleDate: nil)
    )
}

// Widget for Live Activity
struct WeatherActivityWidget: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: WeatherActivityAttributes.self) { context in
            // Lock screen UI
            HStack {
                Image(systemName: "sun.max.fill")
                VStack(alignment: .leading) {
                    Text("\(context.state.temperature)¬∞")
                    Text(context.state.condition)
                }
            }
        } dynamicIsland: { context in
            DynamicIsland {
                DynamicIslandExpandedRegion(.leading) {
                    Image(systemName: "sun.max.fill")
                }
                DynamicIslandExpandedRegion(.trailing) {
                    Text("\(context.state.temperature)¬∞")
                }
                DynamicIslandExpandedRegion(.bottom) {
                    Text(context.state.condition)
                }
            } compactLeading: {
                Image(systemName: "sun.max.fill")
            } compactTrailing: {
                Text("\(context.state.temperature)¬∞")
            } minimal: {
                Image(systemName: "sun.max.fill")
            }
        }
    }
}
</code></pre>
<h2 id="-shared-data"><a class="header" href="#-shared-data">üéØ Shared Data</a></h2>
<pre><code class="language-swift">// In app and widget
let sharedDefaults = UserDefaults(suiteName: "group.com.yourapp.weather")!

// Save in app
sharedDefaults.set(72, forKey: "temperature")

// Read in widget
let temperature = sharedDefaults.integer(forKey: "temperature")
</code></pre>
<h2 id="-timeline-strategies"><a class="header" href="#-timeline-strategies">üìä Timeline Strategies</a></h2>
<pre><code class="language-swift">// Update every hour
let timeline = Timeline(entries: [entry], policy: .after(Date().addingTimeInterval(3600)))

// Update at specific time
let midnight = Calendar.current.startOfDay(for: Date().addingTimeInterval(86400))
let timeline = Timeline(entries: [entry], policy: .after(midnight))

// Never update (static)
let timeline = Timeline(entries: [entry], policy: .never)

// Update ASAP
let timeline = Timeline(entries: [entry], policy: .atEnd)
</code></pre>
<h2 id="-best-practices-1"><a class="header" href="#-best-practices-1">üé® Best Practices</a></h2>
<h3 id="1-keep-it-simple"><a class="header" href="#1-keep-it-simple">1. Keep It Simple</a></h3>
<pre><code class="language-swift">// ‚úÖ Good: Clear at a glance
Text("\(temperature)¬∞")
    .font(.largeTitle)

// ‚ùå Bad: Too much info
VStack {
    Text("Temperature: \(temperature)¬∞F")
    Text("Feels like: \(feelsLike)¬∞F")
    Text("Humidity: \(humidity)%")
    Text("Wind: \(wind) mph")
}
</code></pre>
<h3 id="2-use-placeholders"><a class="header" href="#2-use-placeholders">2. Use Placeholders</a></h3>
<pre><code class="language-swift">func placeholder(in context: Context) -&gt; WeatherEntry {
    WeatherEntry(
        date: Date(),
        temperature: 72,
        condition: "Sunny",
        icon: "sun.max.fill"
    )
}
</code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<pre><code class="language-swift">func getTimeline(in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; Void) {
    Task {
        do {
            let weather = try await fetchWeather()
            let entry = WeatherEntry(from: weather)
            completion(Timeline(entries: [entry], policy: .after(Date().addingTimeInterval(900))))
        } catch {
            // Show cached data or placeholder
            let fallback = WeatherEntry(date: Date(), temperature: 72, condition: "Unavailable", icon: "exclamationmark.triangle")
            completion(Timeline(entries: [fallback], policy: .after(Date().addingTimeInterval(300))))
        }
    }
}
</code></pre>
<h2 id="-testing"><a class="header" href="#-testing">üöÄ Testing</a></h2>
<pre><code class="language-swift">// Preview
#Preview(as: .systemSmall) {
    WeatherWidget()
} timeline: {
    WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    WeatherEntry(date: Date(), temperature: 68, condition: "Cloudy", icon: "cloud.fill")
}
</code></pre>
<h2 id="-performance-tips-1"><a class="header" href="#-performance-tips-1">üí° Performance Tips</a></h2>
<ol>
<li><strong>Limit network calls</strong> - Cache data</li>
<li><strong>Use App Groups</strong> - Share data efficiently</li>
<li><strong>Optimize images</strong> - Use SF Symbols when possible</li>
<li><strong>Keep timelines short</strong> - 5-10 entries max</li>
<li><strong>Test on device</strong> - Simulator doesn't show true performance</li>
</ol>
<h2 id="-resources-1"><a class="header" href="#-resources-1">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/widgetkit">WidgetKit Documentation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10028/">WWDC23 - Bring widgets to life</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/widgets">Human Interface Guidelines</a></li>
</ul>
<h2 id="-next-steps-2"><a class="header" href="#-next-steps-2">üîó Next Steps</a></h2>
<ul>
<li><a href="frameworks/./appintents.html">AppIntents ‚Üí</a></li>
<li><a href="frameworks/./swiftdata.html">SwiftData ‚Üí</a></li>
</ul>
<hr />
<p><strong>Try it</strong>: Add a widget to your app. Users love home screen widgets!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-intents---siri--shortcuts-integration"><a class="header" href="#app-intents---siri--shortcuts-integration">App Intents - Siri &amp; Shortcuts Integration</a></h1>
<blockquote>
<p>Connect your app to Siri, Shortcuts, and system intelligence</p>
</blockquote>
<h2 id="-what-are-app-intents"><a class="header" href="#-what-are-app-intents">üéØ What are App Intents?</a></h2>
<p>App Intents allow your app to:</p>
<ul>
<li><strong>Expose functionality</strong> to Siri and Shortcuts</li>
<li><strong>Provide voice control</strong> for key features</li>
<li><strong>Enable automation</strong> workflows</li>
<li><strong>Integrate with system intelligence</strong></li>
</ul>
<h2 id="-basic-app-intent"><a class="header" href="#-basic-app-intent">üöÄ Basic App Intent</a></h2>
<h3 id="simple-intent"><a class="header" href="#simple-intent">Simple Intent</a></h3>
<pre><code class="language-swift">import AppIntents

struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    static var description = IntentDescription("Add a new task to your list")
    
    @Parameter(title: "Task Title")
    var taskTitle: String
    
    func perform() async throws -&gt; some IntentResult {
        // Add task to your data store
        let task = Task(title: taskTitle)
        await TaskManager.shared.addTask(task)
        
        return .result(dialog: "Added '\(taskTitle)' to your tasks")
    }
}
</code></pre>
<h3 id="register-intent"><a class="header" href="#register-intent">Register Intent</a></h3>
<pre><code class="language-swift">@main
struct TaskApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
    
    init() {
        // Register app intents
        AppDependencyManager.shared.add(dependency: TaskManager.shared)
    }
}
</code></pre>
<h2 id="-parameter-types"><a class="header" href="#-parameter-types">üì± Parameter Types</a></h2>
<h3 id="string-parameters"><a class="header" href="#string-parameters">String Parameters</a></h3>
<pre><code class="language-swift">struct SearchTasksIntent: AppIntent {
    static var title: LocalizedStringResource = "Search Tasks"
    
    @Parameter(title: "Search Query")
    var query: String
    
    func perform() async throws -&gt; some IntentResult &amp; ReturnsValue&lt;[TaskEntity]&gt; {
        let tasks = await TaskManager.shared.searchTasks(query: query)
        return .result(value: tasks.map(TaskEntity.init))
    }
}
</code></pre>
<h3 id="enum-parameters"><a class="header" href="#enum-parameters">Enum Parameters</a></h3>
<pre><code class="language-swift">enum TaskPriority: String, AppEnum {
    case low = "Low"
    case medium = "Medium"
    case high = "High"
    
    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Priority")
    static var caseDisplayRepresentations: [TaskPriority: DisplayRepresentation] = [
        .low: "Low Priority",
        .medium: "Medium Priority",
        .high: "High Priority"
    ]
}

struct CreateTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Create Task"
    
    @Parameter(title: "Task Title")
    var title: String
    
    @Parameter(title: "Priority", default: .medium)
    var priority: TaskPriority
    
    func perform() async throws -&gt; some IntentResult {
        let task = Task(title: title, priority: priority)
        await TaskManager.shared.addTask(task)
        
        return .result(dialog: "Created \(priority.rawValue.lowercased()) priority task: \(title)")
    }
}
</code></pre>
<h3 id="entity-parameters"><a class="header" href="#entity-parameters">Entity Parameters</a></h3>
<pre><code class="language-swift">struct TaskEntity: AppEntity {
    let id: UUID
    let title: String
    let isCompleted: Bool
    
    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Task")
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(title: "\(title)")
    }
    
    static var defaultQuery = TaskEntityQuery()
}

struct TaskEntityQuery: EntityQuery {
    func entities(for identifiers: [UUID]) async throws -&gt; [TaskEntity] {
        return await TaskManager.shared.tasks(with: identifiers).map(TaskEntity.init)
    }
    
    func suggestedEntities() async throws -&gt; [TaskEntity] {
        return await TaskManager.shared.recentTasks().map(TaskEntity.init)
    }
}
</code></pre>
<h2 id="-advanced-features"><a class="header" href="#-advanced-features">üéôÔ∏è Advanced Features</a></h2>
<h3 id="dynamic-options"><a class="header" href="#dynamic-options">Dynamic Options</a></h3>
<pre><code class="language-swift">struct CompleteTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Complete Task"
    
    @Parameter(title: "Task")
    var task: TaskEntity
    
    static var parameterSummary: some ParameterSummary {
        Summary("Complete \(\.$task)")
    }
    
    func perform() async throws -&gt; some IntentResult {
        await TaskManager.shared.completeTask(id: task.id)
        return .result(dialog: "Completed '\(task.title)'")
    }
}
</code></pre>
<h3 id="confirmation-dialog"><a class="header" href="#confirmation-dialog">Confirmation Dialog</a></h3>
<pre><code class="language-swift">struct DeleteAllTasksIntent: AppIntent {
    static var title: LocalizedStringResource = "Delete All Tasks"
    static var isDiscoverable = false // Hide from suggestions
    
    func perform() async throws -&gt; some IntentResult {
        let taskCount = await TaskManager.shared.taskCount()
        
        // Request confirmation for destructive action
        try await requestConfirmation(
            result: .result(dialog: "Are you sure you want to delete all \(taskCount) tasks?")
        )
        
        await TaskManager.shared.deleteAllTasks()
        return .result(dialog: "Deleted all tasks")
    }
}
</code></pre>
<h3 id="progress-reporting"><a class="header" href="#progress-reporting">Progress Reporting</a></h3>
<pre><code class="language-swift">struct ExportTasksIntent: AppIntent {
    static var title: LocalizedStringResource = "Export Tasks"
    
    func perform() async throws -&gt; some IntentResult &amp; ReturnsValue&lt;IntentFile&gt; {
        let tasks = await TaskManager.shared.allTasks()
        
        // Report progress for long operations
        let progress = Progress(totalUnitCount: Int64(tasks.count))
        
        var exportData = ""
        for (index, task) in tasks.enumerated() {
            exportData += "\(task.title)\n"
            progress.completedUnitCount = Int64(index + 1)
            
            // Update progress every 10 items
            if index % 10 == 0 {
                try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
            }
        }
        
        let data = exportData.data(using: .utf8)!
        let file = IntentFile(data: data, filename: "tasks.txt", type: .plainText)
        
        return .result(value: file, dialog: "Exported \(tasks.count) tasks")
    }
}
</code></pre>
<h2 id="-shortcuts-integration"><a class="header" href="#-shortcuts-integration">üîß Shortcuts Integration</a></h2>
<h3 id="shortcut-phrases"><a class="header" href="#shortcut-phrases">Shortcut Phrases</a></h3>
<pre><code class="language-swift">struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    
    // Suggested phrases for Siri
    static var openAppWhenRun: Bool = false
    
    @Parameter(title: "Task Title")
    var taskTitle: String
    
    static var parameterSummary: some ParameterSummary {
        Summary("Add \(\.$taskTitle) to my tasks")
    }
    
    func perform() async throws -&gt; some IntentResult {
        let task = Task(title: taskTitle)
        await TaskManager.shared.addTask(task)
        
        return .result(dialog: "Added '\(taskTitle)' to your task list")
    }
}
</code></pre>
<h3 id="app-shortcuts"><a class="header" href="#app-shortcuts">App Shortcuts</a></h3>
<pre><code class="language-swift">struct TaskAppShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: AddTaskIntent(),
            phrases: [
                "Add a task in \(.applicationName)",
                "Create new task in \(.applicationName)",
                "Add \(\.$taskTitle) to \(.applicationName)"
            ],
            shortTitle: "Add Task",
            systemImageName: "plus.circle"
        )
    }
}
</code></pre>
<h2 id="-widget-integration"><a class="header" href="#-widget-integration">üìä Widget Integration</a></h2>
<h3 id="interactive-widgets"><a class="header" href="#interactive-widgets">Interactive Widgets</a></h3>
<pre><code class="language-swift">struct TaskWidgetIntent: AppIntent {
    static var title: LocalizedStringResource = "Toggle Task"
    
    @Parameter(title: "Task ID")
    var taskId: String
    
    func perform() async throws -&gt; some IntentResult {
        await TaskManager.shared.toggleTask(id: UUID(uuidString: taskId)!)
        
        // Update widget timeline
        WidgetCenter.shared.reloadTimelines(ofKind: "TaskWidget")
        
        return .result()
    }
}

// In your widget
struct TaskWidget: Widget {
    var body: some WidgetConfiguration {
        StaticConfiguration(kind: "TaskWidget", provider: TaskProvider()) { entry in
            TaskWidgetView(entry: entry)
        }
        .configurationDisplayName("Tasks")
        .description("View and complete your tasks")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}
</code></pre>
<h2 id="-best-practices-2"><a class="header" href="#-best-practices-2">üéØ Best Practices</a></h2>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<pre><code class="language-swift">enum TaskIntentError: Swift.Error, CustomLocalizedStringResourceConvertible {
    case taskNotFound
    case networkUnavailable
    
    var localizedStringResource: LocalizedStringResource {
        switch self {
        case .taskNotFound:
            return "Task not found"
        case .networkUnavailable:
            return "Network connection required"
        }
    }
}

struct CompleteTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Complete Task"
    
    @Parameter(title: "Task")
    var task: TaskEntity
    
    func perform() async throws -&gt; some IntentResult {
        guard await TaskManager.shared.taskExists(id: task.id) else {
            throw TaskIntentError.taskNotFound
        }
        
        do {
            await TaskManager.shared.completeTask(id: task.id)
            return .result(dialog: "Completed '\(task.title)'")
        } catch {
            throw TaskIntentError.networkUnavailable
        }
    }
}
</code></pre>
<h3 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h3>
<pre><code class="language-swift">struct TaskManager {
    // Cache frequently accessed data
    private var cachedTasks: [Task] = []
    private var lastCacheUpdate = Date.distantPast
    
    func recentTasks() async -&gt; [Task] {
        // Return cached data if recent
        if Date().timeIntervalSince(lastCacheUpdate) &lt; 60 {
            return Array(cachedTasks.prefix(10))
        }
        
        // Refresh cache
        cachedTasks = await loadAllTasks()
        lastCacheUpdate = Date()
        
        return Array(cachedTasks.prefix(10))
    }
}
</code></pre>
<h3 id="localization"><a class="header" href="#localization">Localization</a></h3>
<pre><code class="language-swift">struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    
    @Parameter(title: "Task Title")
    var taskTitle: String
    
    func perform() async throws -&gt; some IntentResult {
        let task = Task(title: taskTitle)
        await TaskManager.shared.addTask(task)
        
        // Localized response
        let message = LocalizedStringResource("task.added", 
                                            defaultValue: "Added '\(taskTitle)' to your tasks")
        
        return .result(dialog: IntentDialog(stringLiteral: String(localized: message)))
    }
}
</code></pre>
<h2 id="-testing-app-intents"><a class="header" href="#-testing-app-intents">üß™ Testing App Intents</a></h2>
<h3 id="unit-testing-1"><a class="header" href="#unit-testing-1">Unit Testing</a></h3>
<pre><code class="language-swift">import Testing
@testable import TaskApp

@Test func testAddTaskIntent() async throws {
    let intent = AddTaskIntent()
    intent.taskTitle = "Test Task"
    
    let result = try await intent.perform()
    
    // Verify task was added
    let tasks = await TaskManager.shared.allTasks()
    #expect(tasks.contains { $0.title == "Test Task" })
}
</code></pre>
<hr />
<p><em>App Intents make your app more accessible and integrated with the iOS ecosystem, enabling voice control and automation.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftcharts"><a class="header" href="#swiftcharts">Swiftcharts</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paywall-psychology--conversion"><a class="header" href="#paywall-psychology--conversion">Paywall Psychology &amp; Conversion</a></h1>
<blockquote>
<p><strong>Turn 15%+ of free users into paying customers with behavioral psychology</strong></p>
</blockquote>
<h2 id="-the-conversion-reality"><a class="header" href="#-the-conversion-reality">üí∞ The Conversion Reality</a></h2>
<p>Most apps convert 1-3% of users to paid. Apps using psychological principles convert 10-20%.</p>
<p><strong>Real data from $10M+ revenue apps:</strong></p>
<ul>
<li>Generic paywall: 2.1% conversion</li>
<li>Psychologically optimized: 16.8% conversion</li>
<li><strong>8x improvement</strong> from implementation details Apple never teaches</li>
</ul>
<h2 id="-core-psychology-principles"><a class="header" href="#-core-psychology-principles">üß† Core Psychology Principles</a></h2>
<h3 id="1-loss-aversion"><a class="header" href="#1-loss-aversion">1. Loss Aversion</a></h3>
<p>People fear losing something more than they value gaining it.</p>
<pre><code class="language-swift">// ‚ùå Generic approach
"Upgrade to Premium for advanced features"

// ‚úÖ Loss aversion approach  
"Don't lose your 47 projects - upgrade to keep creating"

struct PaywallViewModel {
    let userProjectCount: Int
    
    var lossAversionMessage: String {
        if userProjectCount &gt; 0 {
            return "Don't lose your \(userProjectCount) projects"
        } else {
            return "Start creating without limits"
        }
    }
}
</code></pre>
<h3 id="2-social-proof"><a class="header" href="#2-social-proof">2. Social Proof</a></h3>
<p>Show that others like them are paying customers.</p>
<pre><code class="language-swift">class SocialProofManager {
    func getRelevantTestimonial(for user: User) -&gt; Testimonial {
        // Match testimonial to user profile
        switch user.userType {
        case .student:
            return testimonials.first { $0.userType == .student } ?? defaultTestimonial
        case .professional:
            return testimonials.first { $0.userType == .professional } ?? defaultTestimonial
        case .creative:
            return testimonials.first { $0.userType == .creative } ?? defaultTestimonial
        }
    }
}

struct PaywallView: View {
    @State private var testimonial: Testimonial?
    
    var body: some View {
        VStack {
            if let testimonial = testimonial {
                TestimonialCard(testimonial: testimonial)
            }
            
            // Rest of paywall UI
        }
        .onAppear {
            testimonial = SocialProofManager.shared.getRelevantTestimonial(for: currentUser)
        }
    }
}
</code></pre>
<h3 id="3-scarcity--urgency"><a class="header" href="#3-scarcity--urgency">3. Scarcity &amp; Urgency</a></h3>
<p>Limited-time offers create urgency, but must be genuine.</p>
<pre><code class="language-swift">class DiscountManager {
    private let userDefaults = UserDefaults.standard
    
    func getPersonalizedOffer(for user: User) -&gt; Offer? {
        // Only show discount to users who've engaged but not converted
        guard user.sessionCount &gt;= 3,
              user.isPremium == false,
              !hasSeenRecentOffer(user) else {
            return nil
        }
        
        return Offer(
            discountPercent: 50,
            expiresAt: Date().addingTimeInterval(48 * 60 * 60), // 48 hours
            reason: .engagementReward
        )
    }
    
    private func hasSeenRecentOffer(_ user: User) -&gt; Bool {
        let lastOfferDate = userDefaults.object(forKey: "last_offer_\(user.id)") as? Date
        return lastOfferDate?.timeIntervalSinceNow ?? -Double.infinity &gt; -7 * 24 * 60 * 60 // 7 days
    }
}
</code></pre>
<h2 id="-optimal-timing-strategies"><a class="header" href="#-optimal-timing-strategies">üéØ Optimal Timing Strategies</a></h2>
<h3 id="1-intent-based-triggers"><a class="header" href="#1-intent-based-triggers">1. Intent-Based Triggers</a></h3>
<p>Show paywall when user intent is highest.</p>
<pre><code class="language-swift">class PaywallTriggerManager {
    func shouldShowPaywall(for action: UserAction, user: User) -&gt; Bool {
        switch action {
        case .exportingProject:
            // High intent - user wants to use their work
            return user.exportCount &gt;= 2
            
        case .accessingAdvancedFeature:
            // Medium intent - exploring capabilities
            return user.sessionDuration &gt; 300 // 5 minutes
            
        case .savingWork:
            // High intent - user is invested
            return user.projectCount &gt;= 3
            
        case .sharingContent:
            // Highest intent - user sees value
            return true
            
        default:
            return false
        }
    }
}

// Usage in your app
class ProjectExportManager {
    func exportProject(_ project: Project) {
        if PaywallTriggerManager.shared.shouldShowPaywall(for: .exportingProject, user: currentUser) {
            presentPaywall(context: .export(project))
        } else {
            performExport(project)
        }
    }
}
</code></pre>
<h3 id="2-engagement-based-timing"><a class="header" href="#2-engagement-based-timing">2. Engagement-Based Timing</a></h3>
<pre><code class="language-swift">class EngagementTracker {
    private var sessionStartTime = Date()
    
    func trackEngagement() -&gt; EngagementLevel {
        let sessionDuration = Date().timeIntervalSince(sessionStartTime)
        let actionsThisSession = UserActionTracker.shared.actionsThisSession
        
        switch (sessionDuration, actionsThisSession) {
        case (300..., 10...): // 5+ minutes, 10+ actions
            return .high
        case (120..., 5...):  // 2+ minutes, 5+ actions
            return .medium
        default:
            return .low
        }
    }
}

enum EngagementLevel {
    case low, medium, high
    
    var paywallConversionRate: Double {
        switch self {
        case .low: return 0.03    // 3%
        case .medium: return 0.08 // 8%
        case .high: return 0.18   // 18%
        }
    }
}
</code></pre>
<h2 id="-uiux-conversion-tactics"><a class="header" href="#-uiux-conversion-tactics">üé® UI/UX Conversion Tactics</a></h2>
<h3 id="1-progressive-disclosure"><a class="header" href="#1-progressive-disclosure">1. Progressive Disclosure</a></h3>
<p>Don't overwhelm - reveal value gradually.</p>
<pre><code class="language-swift">struct PaywallView: View {
    @State private var currentStep = 0
    private let features = [
        Feature(title: "Unlimited Projects", icon: "folder.fill"),
        Feature(title: "Advanced Export", icon: "square.and.arrow.up"),
        Feature(title: "Priority Support", icon: "message.fill")
    ]
    
    var body: some View {
        VStack {
            // Show one feature at a time with animation
            TabView(selection: $currentStep) {
                ForEach(0..&lt;features.count, id: \.self) { index in
                    FeatureCard(feature: features[index])
                        .tag(index)
                }
            }
            .tabViewStyle(PageTabViewStyle())
            .frame(height: 200)
            
            // Purchase button appears after viewing features
            if currentStep &gt;= features.count - 1 {
                PurchaseButton()
                    .transition(.slide)
            }
        }
        .onAppear {
            startAutoAdvance()
        }
    }
    
    private func startAutoAdvance() {
        Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
            withAnimation {
                currentStep = (currentStep + 1) % features.count
            }
        }
    }
}
</code></pre>
<h3 id="2-value-anchoring"><a class="header" href="#2-value-anchoring">2. Value Anchoring</a></h3>
<p>Show the highest value first to anchor perception.</p>
<pre><code class="language-swift">struct PricingView: View {
    private let plans = [
        Plan(name: "Annual", price: 59.99, savings: "Save 60%", isPopular: true),
        Plan(name: "Monthly", price: 9.99, savings: nil, isPopular: false)
    ]
    
    var body: some View {
        VStack {
            // Show annual first (higher value anchor)
            ForEach(plans) { plan in
                PlanCard(plan: plan)
                    .overlay(
                        // Highlight most valuable option
                        plan.isPopular ? PopularBadge() : nil,
                        alignment: .topTrailing
                    )
            }
        }
    }
}

struct PlanCard: View {
    let plan: Plan
    
    var body: some View {
        VStack {
            Text(plan.name)
                .font(.headline)
            
            HStack {
                Text("$\(plan.price, specifier: "%.2f")")
                    .font(.title)
                
                if let savings = plan.savings {
                    Text(savings)
                        .foregroundColor(.green)
                        .font(.caption)
                }
            }
            
            // Show value per month for annual plans
            if plan.name == "Annual" {
                Text("Just $\(plan.price/12, specifier: "%.2f")/month")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
}
</code></pre>
<h3 id="3-friction-reduction"><a class="header" href="#3-friction-reduction">3. Friction Reduction</a></h3>
<p>Make purchasing as easy as possible.</p>
<pre><code class="language-swift">class PurchaseManager: ObservableObject {
    @Published var isPurchasing = false
    
    func purchase(_ product: Product) async {
        isPurchasing = true
        defer { isPurchasing = false }
        
        do {
            // Use StoreKit 2 for smooth experience
            let result = try await product.purchase()
            
            switch result {
            case .success(let verification):
                await handleSuccessfulPurchase(verification)
            case .userCancelled:
                // Don't show error - user chose to cancel
                break
            case .pending:
                await showPendingMessage()
            @unknown default:
                break
            }
        } catch {
            await handlePurchaseError(error)
        }
    }
    
    private func handleSuccessfulPurchase(_ verification: VerificationResult&lt;Transaction&gt;) async {
        // Immediate feedback
        await MainActor.run {
            HapticManager.shared.playSuccess()
            showSuccessAnimation()
        }
        
        // Unlock features immediately
        await FeatureManager.shared.unlockPremiumFeatures()
    }
}
</code></pre>
<h2 id="-ab-testing-framework"><a class="header" href="#-ab-testing-framework">üìä A/B Testing Framework</a></h2>
<p>Test everything - small changes make huge differences.</p>
<pre><code class="language-swift">class PaywallABTest {
    enum Variant: String, CaseIterable {
        case control = "control"
        case lossAversion = "loss_aversion"
        case socialProof = "social_proof"
        case urgency = "urgency"
    }
    
    func getVariant(for user: User) -&gt; Variant {
        // Consistent assignment based on user ID
        let hash = abs(user.id.hashValue)
        let variantIndex = hash % Variant.allCases.count
        return Variant.allCases[variantIndex]
    }
    
    func trackConversion(variant: Variant, converted: Bool) {
        Analytics.track("paywall_conversion", parameters: [
            "variant": variant.rawValue,
            "converted": converted,
            "user_segment": currentUser.segment
        ])
    }
}

struct PaywallView: View {
    @State private var variant: PaywallABTest.Variant = .control
    
    var body: some View {
        Group {
            switch variant {
            case .control:
                StandardPaywallView()
            case .lossAversion:
                LossAversionPaywallView()
            case .socialProof:
                SocialProofPaywallView()
            case .urgency:
                UrgencyPaywallView()
            }
        }
        .onAppear {
            variant = PaywallABTest().getVariant(for: currentUser)
        }
    }
}
</code></pre>
<h2 id="-conversion-optimization-checklist"><a class="header" href="#-conversion-optimization-checklist">üéØ Conversion Optimization Checklist</a></h2>
<h3 id="psychology"><a class="header" href="#psychology">Psychology</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Loss aversion messaging implemented</li>
<li><input disabled="" type="checkbox"/>
Social proof relevant to user type</li>
<li><input disabled="" type="checkbox"/>
Scarcity/urgency (only if genuine)</li>
<li><input disabled="" type="checkbox"/>
Value anchoring with highest price first</li>
</ul>
<h3 id="timing"><a class="header" href="#timing">Timing</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Intent-based triggers (export, save, share)</li>
<li><input disabled="" type="checkbox"/>
Engagement threshold (5+ minutes, 10+ actions)</li>
<li><input disabled="" type="checkbox"/>
Avoid interrupting flow states</li>
<li><input disabled="" type="checkbox"/>
Respect user's "no" for 24-48 hours</li>
</ul>
<h3 id="uiux"><a class="header" href="#uiux">UI/UX</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Progressive disclosure of features</li>
<li><input disabled="" type="checkbox"/>
Clear value proposition in 5 seconds</li>
<li><input disabled="" type="checkbox"/>
Friction-free purchase flow</li>
<li><input disabled="" type="checkbox"/>
Immediate feature unlock after purchase</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
A/B test messaging variants</li>
<li><input disabled="" type="checkbox"/>
Track conversion by user segment</li>
<li><input disabled="" type="checkbox"/>
Monitor long-term retention impact</li>
<li><input disabled="" type="checkbox"/>
Test different price points</li>
</ul>
<h2 id="-expected-results"><a class="header" href="#-expected-results">üìà Expected Results</a></h2>
<p>Apps implementing these psychology principles typically see:</p>
<ul>
<li><strong>5-8x higher</strong> conversion rates (2% ‚Üí 10-16%)</li>
<li><strong>25% better</strong> user retention (happy paying customers)</li>
<li><strong>40% higher</strong> lifetime value per user</li>
<li><strong>60% fewer</strong> refund requests</li>
</ul>
<hr />
<p><strong>Next:</strong> <a href="monetization/./subscription-retention.html">Subscription Retention ‚Üí</a> - Keep customers paying month after month</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscription-retention"><a class="header" href="#subscription-retention">Subscription Retention</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ab-testing-framework"><a class="header" href="#ab-testing-framework">A/B Testing Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revenue-analytics"><a class="header" href="#revenue-analytics">Revenue Analytics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-architecture"><a class="header" href="#data-architecture">Data Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background-processing"><a class="header" href="#background-processing">Background Processing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-design"><a class="header" href="#api-design">API Design</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-testing-framework"><a class="header" href="#swift-testing-framework">Swift Testing Framework</a></h1>
<blockquote>
<p>Modern testing with Swift's new testing framework introduced in Xcode 16</p>
</blockquote>
<h2 id="-introduction"><a class="header" href="#-introduction">üß™ Introduction</a></h2>
<p>Swift Testing is Apple's modern testing framework that provides:</p>
<ul>
<li>Cleaner syntax with <code>@Test</code> macro</li>
<li>Better error messages and diagnostics</li>
<li>Parallel test execution</li>
<li>Improved Xcode integration</li>
</ul>
<h2 id="-basic-testing"><a class="header" href="#-basic-testing">üöÄ Basic Testing</a></h2>
<h3 id="simple-tests"><a class="header" href="#simple-tests">Simple Tests</a></h3>
<pre><code class="language-swift">import Testing

@Test func basicMath() {
    #expect(2 + 2 == 4)
    #expect(10 - 5 == 5)
}

@Test func stringOperations() {
    let text = "Hello, Swift!"
    #expect(text.contains("Swift"))
    #expect(text.count == 13)
}
</code></pre>
<h3 id="parameterized-tests"><a class="header" href="#parameterized-tests">Parameterized Tests</a></h3>
<pre><code class="language-swift">@Test(arguments: [
    (input: 0, expected: 1),
    (input: 1, expected: 1), 
    (input: 5, expected: 120)
])
func factorial(input: Int, expected: Int) {
    #expect(factorial(input) == expected)
}

func factorial(_ n: Int) -&gt; Int {
    guard n &gt; 1 else { return 1 }
    return n * factorial(n - 1)
}
</code></pre>
<h2 id="-advanced-features-1"><a class="header" href="#-advanced-features-1">üîß Advanced Features</a></h2>
<h3 id="async-testing"><a class="header" href="#async-testing">Async Testing</a></h3>
<pre><code class="language-swift">@Test func networkRequest() async throws {
    let url = URL(string: "https://httpbin.org/json")!
    let (data, response) = try await URLSession.shared.data(from: url)
    
    #expect(data.count &gt; 0)
    
    let httpResponse = try #require(response as? HTTPURLResponse)
    #expect(httpResponse.statusCode == 200)
}
</code></pre>
<h3 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h3>
<pre><code class="language-swift">enum ValidationError: Error {
    case invalidEmail
    case tooShort
}

func validateEmail(_ email: String) throws {
    guard email.contains("@") else {
        throw ValidationError.invalidEmail
    }
}

@Test func errorHandling() {
    #expect(throws: ValidationError.invalidEmail) {
        try validateEmail("invalid-email")
    }
    
    #expect(throws: Never.self) {
        try validateEmail("valid@example.com")
    }
}
</code></pre>
<h3 id="conditional-tests"><a class="header" href="#conditional-tests">Conditional Tests</a></h3>
<pre><code class="language-swift">@Test(.enabled(if: ProcessInfo.processInfo.environment["CI"] == nil))
func localOnlyTest() {
    // This test only runs locally, not in CI
    #expect(true)
}
</code></pre>
<h2 id="-swiftui-testing"><a class="header" href="#-swiftui-testing">üì± SwiftUI Testing</a></h2>
<h3 id="view-testing"><a class="header" href="#view-testing">View Testing</a></h3>
<pre><code class="language-swift">import Testing
import SwiftUI

struct ContentView: View {
    @State private var count = 0
    
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1
            }
        }
    }
}

@Test @MainActor 
func contentViewTest() {
    let view = ContentView()
    // Basic view creation test
    #expect(view.body != nil)
}
</code></pre>
<h3 id="model-testing"><a class="header" href="#model-testing">Model Testing</a></h3>
<pre><code class="language-swift">@Observable
class Counter {
    var value = 0
    
    func increment() {
        value += 1
    }
    
    func decrement() {
        value -= 1
    }
}

@Test func counterModel() {
    let counter = Counter()
    
    #expect(counter.value == 0)
    
    counter.increment()
    #expect(counter.value == 1)
    
    counter.decrement()
    #expect(counter.value == 0)
}
</code></pre>
<h2 id="-real-world-testing-patterns"><a class="header" href="#-real-world-testing-patterns">üéØ Real-World Testing Patterns</a></h2>
<h3 id="service-testing-with-mocks"><a class="header" href="#service-testing-with-mocks">Service Testing with Mocks</a></h3>
<pre><code class="language-swift">protocol NetworkService {
    func fetchUser(id: Int) async throws -&gt; User
}

struct User: Codable, Equatable {
    let id: Int
    let name: String
}

class MockNetworkService: NetworkService {
    var shouldFail = false
    
    func fetchUser(id: Int) async throws -&gt; User {
        if shouldFail {
            throw URLError(.notConnectedToInternet)
        }
        return User(id: id, name: "Test User")
    }
}

class UserRepository {
    private let networkService: NetworkService
    
    init(networkService: NetworkService) {
        self.networkService = networkService
    }
    
    func getUser(id: Int) async throws -&gt; User {
        return try await networkService.fetchUser(id: id)
    }
}

@Test func userRepositorySuccess() async throws {
    let mockService = MockNetworkService()
    let repository = UserRepository(networkService: mockService)
    
    let user = try await repository.getUser(id: 1)
    
    #expect(user.id == 1)
    #expect(user.name == "Test User")
}

@Test func userRepositoryFailure() async {
    let mockService = MockNetworkService()
    mockService.shouldFail = true
    let repository = UserRepository(networkService: mockService)
    
    await #expect(throws: URLError.self) {
        try await repository.getUser(id: 1)
    }
}
</code></pre>
<h3 id="core-data-testing"><a class="header" href="#core-data-testing">Core Data Testing</a></h3>
<pre><code class="language-swift">import CoreData

@Test func coreDataOperations() throws {
    // Create in-memory store for testing
    let container = NSPersistentContainer(name: "DataModel")
    let description = NSPersistentStoreDescription()
    description.type = NSInMemoryStoreType
    container.persistentStoreDescriptions = [description]
    
    container.loadPersistentStores { _, error in
        #expect(error == nil)
    }
    
    let context = container.viewContext
    
    // Create test entity (assuming you have a Person entity)
    let person = NSEntityDescription.insertNewObject(forEntityName: "Person", into: context)
    person.setValue("John Doe", forKey: "name")
    person.setValue(30, forKey: "age")
    
    try context.save()
    
    // Fetch and verify
    let request = NSFetchRequest&lt;NSManagedObject&gt;(entityName: "Person")
    let results = try context.fetch(request)
    
    #expect(results.count == 1)
    #expect(results.first?.value(forKey: "name") as? String == "John Doe")
}
</code></pre>
<h2 id="-test-organization"><a class="header" href="#-test-organization">üîç Test Organization</a></h2>
<h3 id="test-suites"><a class="header" href="#test-suites">Test Suites</a></h3>
<pre><code class="language-swift">@Suite("Authentication Tests")
struct AuthenticationTests {
    
    @Test func validLogin() async throws {
        let auth = AuthService()
        let result = try await auth.login(email: "test@example.com", password: "password123")
        #expect(result.isSuccess)
    }
    
    @Test func invalidCredentials() async {
        let auth = AuthService()
        await #expect(throws: AuthError.invalidCredentials) {
            try await auth.login(email: "test@example.com", password: "wrong")
        }
    }
}

class AuthService {
    func login(email: String, password: String) async throws -&gt; LoginResult {
        // Simulate authentication
        if email == "test@example.com" &amp;&amp; password == "password123" {
            return LoginResult(isSuccess: true, token: "abc123")
        } else {
            throw AuthError.invalidCredentials
        }
    }
}

struct LoginResult {
    let isSuccess: Bool
    let token: String?
}

enum AuthError: Error {
    case invalidCredentials
}
</code></pre>
<h3 id="setup-and-teardown"><a class="header" href="#setup-and-teardown">Setup and Teardown</a></h3>
<pre><code class="language-swift">@Suite("Database Tests") 
struct DatabaseTests {
    let database: TestDatabase
    
    init() throws {
        database = try TestDatabase()
    }
    
    @Test func insertRecord() throws {
        let record = TestRecord(id: 1, name: "Test")
        try database.insert(record)
        
        let retrieved = try database.fetch(id: 1)
        #expect(retrieved?.name == "Test")
    }
    
    @Test func deleteRecord() throws {
        let record = TestRecord(id: 2, name: "Delete Me")
        try database.insert(record)
        try database.delete(id: 2)
        
        let retrieved = try database.fetch(id: 2)
        #expect(retrieved == nil)
    }
}

class TestDatabase {
    private var records: [Int: TestRecord] = [:]
    
    func insert(_ record: TestRecord) throws {
        records[record.id] = record
    }
    
    func fetch(id: Int) throws -&gt; TestRecord? {
        return records[id]
    }
    
    func delete(id: Int) throws {
        records.removeValue(forKey: id)
    }
}

struct TestRecord: Equatable {
    let id: Int
    let name: String
}
</code></pre>
<h2 id="-performance-testing"><a class="header" href="#-performance-testing">üìä Performance Testing</a></h2>
<h3 id="timing-tests"><a class="header" href="#timing-tests">Timing Tests</a></h3>
<pre><code class="language-swift">@Test func performanceTest() {
    let startTime = CFAbsoluteTimeGetCurrent()
    
    // Perform operation
    let result = expensiveOperation()
    
    let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
    
    #expect(timeElapsed &lt; 1.0) // Should complete within 1 second
    #expect(result.count &gt; 0)
}

func expensiveOperation() -&gt; [Int] {
    return (0..&lt;100_000).map { $0 * 2 }
}
</code></pre>
<h2 id="-migration-from-xctest"><a class="header" href="#-migration-from-xctest">üõ† Migration from XCTest</a></h2>
<h3 id="assertion-mapping"><a class="header" href="#assertion-mapping">Assertion Mapping</a></h3>
<pre><code class="language-swift">// XCTest -&gt; Swift Testing
XCTAssertEqual(a, b)           // #expect(a == b)
XCTAssertTrue(condition)       // #expect(condition)
XCTAssertFalse(condition)      // #expect(!condition)
XCTAssertNil(value)           // #expect(value == nil)
XCTAssertNotNil(value)        // #expect(value != nil)
XCTAssertThrowsError(try f()) // #expect(throws: Error.self) { try f() }
</code></pre>
<h3 id="class-based-to-function-based"><a class="header" href="#class-based-to-function-based">Class-based to Function-based</a></h3>
<pre><code class="language-swift">// XCTest (old)
class MyTests: XCTestCase {
    func testExample() {
        XCTAssertEqual(2 + 2, 4)
    }
}

// Swift Testing (new)
@Test func example() {
    #expect(2 + 2 == 4)
}
</code></pre>
<h2 id="-best-practices-3"><a class="header" href="#-best-practices-3">üéì Best Practices</a></h2>
<h3 id="1-descriptive-test-names"><a class="header" href="#1-descriptive-test-names">1. Descriptive Test Names</a></h3>
<pre><code class="language-swift">@Test("User can create account with valid email and password")
func userAccountCreation() {
    // Test implementation
}
</code></pre>
<h3 id="2-arrange-act-assert-pattern"><a class="header" href="#2-arrange-act-assert-pattern">2. Arrange-Act-Assert Pattern</a></h3>
<pre><code class="language-swift">@Test func shoppingCartTotal() {
    // Arrange
    let cart = ShoppingCart()
    cart.add(Item(price: 10.00))
    cart.add(Item(price: 15.50))
    
    // Act
    let total = cart.calculateTotal()
    
    // Assert
    #expect(total == 25.50)
}
</code></pre>
<h3 id="3-test-data-builders"><a class="header" href="#3-test-data-builders">3. Test Data Builders</a></h3>
<pre><code class="language-swift">struct UserBuilder {
    private var name = "Default Name"
    private var email = "default@example.com"
    
    func withName(_ name: String) -&gt; UserBuilder {
        var builder = self
        builder.name = name
        return builder
    }
    
    func withEmail(_ email: String) -&gt; UserBuilder {
        var builder = self
        builder.email = email
        return builder
    }
    
    func build() -&gt; User {
        return User(name: name, email: email)
    }
}

@Test func userValidation() {
    let user = UserBuilder()
        .withName("John Doe")
        .withEmail("john@example.com")
        .build()
    
    #expect(user.isValid)
}
</code></pre>
<hr />
<p><em>Swift Testing provides a modern, clean way to test your Swift code with better tooling and syntax.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency--data-race-safety"><a class="header" href="#concurrency--data-race-safety">Concurrency &amp; Data Race Safety</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typed-throws"><a class="header" href="#typed-throws">Typed Throws</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noncopyable-types"><a class="header" href="#noncopyable-types">Noncopyable Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-6-concurrency"><a class="header" href="#swift-6-concurrency">Swift 6 Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui-performance"><a class="header" href="#swiftui-performance">SwiftUI Performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-ios-app"><a class="header" href="#your-first-ios-app">Your First iOS App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui-essentials"><a class="header" href="#swiftui-essentials">SwiftUI Essentials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation--user-input"><a class="header" href="#navigation--user-input">Navigation &amp; User Input</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-data"><a class="header" href="#working-with-data">Working with Data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking--apis"><a class="header" href="#networking--apis">Networking &amp; APIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-26"><a class="header" href="#ios-26">iOS 26</a></h1>
<blockquote>
<p><strong>Latest features and APIs for iPhone development</strong></p>
</blockquote>
<h2 id="-whats-new-in-ios-26"><a class="header" href="#-whats-new-in-ios-26">üéØ What's New in iOS 26</a></h2>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<ul>
<li>Xcode 26+</li>
<li>Swift 6.0+</li>
<li>Deployment target: iOS 26.0+</li>
</ul>
<p><strong>Official</strong>: <a href="https://developer.apple.com/documentation/ios-ipados-release-notes">iOS 26 Release Notes</a></p>
<h2 id="-new-frameworks"><a class="header" href="#-new-frameworks">üì± New Frameworks</a></h2>
<h3 id="1-enhanced-swiftdata"><a class="header" href="#1-enhanced-swiftdata">1. Enhanced SwiftData</a></h3>
<pre><code class="language-swift">import SwiftData

@Model
final class Task {
    var title: String
    var isCompleted: Bool
    var priority: Priority
    var dueDate: Date?
    
    // iOS 26: Computed properties with @Transient
    @Transient
    var isOverdue: Bool {
        guard let dueDate else { return false }
        return dueDate &lt; Date() &amp;&amp; !isCompleted
    }
    
    init(title: String, priority: Priority = .medium) {
        self.title = title
        self.isCompleted = false
        self.priority = priority
    }
}

enum Priority: String, Codable {
    case low, medium, high
}

// Usage in SwiftUI
struct TaskListView: View {
    @Query(sort: \Task.dueDate) private var tasks: [Task]
    @Environment(\.modelContext) private var context
    
    var body: some View {
        List {
            ForEach(tasks) { task in
                TaskRow(task: task)
            }
            .onDelete(perform: deleteTasks)
        }
    }
    
    private func deleteTasks(at offsets: IndexSet) {
        for index in offsets {
            context.delete(tasks[index])
        }
    }
}
</code></pre>
<p><strong>Documentation</strong>: <a href="https://developer.apple.com/documentation/swiftdata">SwiftData</a></p>
<h3 id="2-app-intents-20"><a class="header" href="#2-app-intents-20">2. App Intents 2.0</a></h3>
<pre><code class="language-swift">import AppIntents

struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    static var description = IntentDescription("Adds a new task to your list")
    
    @Parameter(title: "Task Title")
    var title: String
    
    @Parameter(title: "Priority", default: .medium)
    var priority: Priority
    
    @MainActor
    func perform() async throws -&gt; some IntentResult {
        let task = Task(title: title, priority: priority)
        // Save task
        
        return .result(dialog: "Added task: \(title)")
    }
}

// Shortcuts support
struct TaskAppShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: AddTaskIntent(),
            phrases: [
                "Add a task in \(.applicationName)",
                "Create task in \(.applicationName)"
            ],
            shortTitle: "Add Task",
            systemImageName: "plus.circle"
        )
    }
}
</code></pre>
<p><strong>WWDC</strong>: <a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - App Intents Deep Dive</a></p>
<h3 id="3-live-activities-enhancement"><a class="header" href="#3-live-activities-enhancement">3. Live Activities Enhancement</a></h3>
<pre><code class="language-swift">import ActivityKit

struct TaskActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var completedCount: Int
        var totalCount: Int
        var currentTask: String
    }
    
    var projectName: String
}

// Start Live Activity
func startTaskActivity() throws {
    let attributes = TaskActivityAttributes(projectName: "Work Project")
    let initialState = TaskActivityAttributes.ContentState(
        completedCount: 0,
        totalCount: 10,
        currentTask: "Review code"
    )
    
    let activity = try Activity.request(
        attributes: attributes,
        content: .init(state: initialState, staleDate: nil)
    )
}

// Update Live Activity
func updateActivity(_ activity: Activity&lt;TaskActivityAttributes&gt;) async {
    let updatedState = TaskActivityAttributes.ContentState(
        completedCount: 5,
        totalCount: 10,
        currentTask: "Write tests"
    )
    
    await activity.update(
        .init(state: updatedState, staleDate: nil)
    )
}
</code></pre>
<p><strong>Guide</strong>: <a href="https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities">Live Activities</a></p>
<h2 id="-ui-enhancements"><a class="header" href="#-ui-enhancements">üé® UI Enhancements</a></h2>
<h3 id="dynamic-island-integration"><a class="header" href="#dynamic-island-integration">Dynamic Island Integration</a></h3>
<pre><code class="language-swift">struct TaskActivityWidget: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: TaskActivityAttributes.self) { context in
            // Lock screen/banner UI
            HStack {
                Image(systemName: "checkmark.circle.fill")
                VStack(alignment: .leading) {
                    Text(context.state.currentTask)
                        .font(.headline)
                    Text("\(context.state.completedCount)/\(context.state.totalCount) completed")
                        .font(.caption)
                }
            }
        } dynamicIsland: { context in
            DynamicIsland {
                // Expanded UI
                DynamicIslandExpandedRegion(.leading) {
                    Image(systemName: "list.bullet")
                }
                DynamicIslandExpandedRegion(.trailing) {
                    Text("\(context.state.completedCount)/\(context.state.totalCount)")
                }
                DynamicIslandExpandedRegion(.bottom) {
                    Text(context.state.currentTask)
                }
            } compactLeading: {
                Image(systemName: "checkmark.circle")
            } compactTrailing: {
                Text("\(context.state.completedCount)")
            } minimal: {
                Image(systemName: "checkmark")
            }
        }
    }
}
</code></pre>
<h3 id="storekit-3-views"><a class="header" href="#storekit-3-views">StoreKit 3 Views</a></h3>
<pre><code class="language-swift">import StoreKit

struct SubscriptionView: View {
    @State private var subscriptions: [Product] = []
    
    var body: some View {
        SubscriptionStoreView(groupID: "premium_features") {
            // Custom marketing content
            VStack {
                Image("premium_icon")
                Text("Unlock Premium Features")
                    .font(.title)
            }
        }
        .subscriptionStoreButtonLabel(.multiline)
        .subscriptionStorePickerItemBackground(.thinMaterial)
        .storeButton(.visible, for: .restorePurchases)
    }
}
</code></pre>
<p><strong>Documentation</strong>: <a href="https://developer.apple.com/documentation/storekit/storekitviews">StoreKit Views</a></p>
<h2 id="-privacy--security"><a class="header" href="#-privacy--security">üîê Privacy &amp; Security</a></h2>
<h3 id="app-privacy-report"><a class="header" href="#app-privacy-report">App Privacy Report</a></h3>
<pre><code class="language-swift">import AppTrackingTransparency

class PrivacyManager {
    func requestTracking() async -&gt; Bool {
        await ATTrackingManager.requestTrackingAuthorization() == .authorized
    }
    
    func checkStatus() -&gt; ATTrackingManager.AuthorizationStatus {
        ATTrackingManager.trackingAuthorizationStatus
    }
}
</code></pre>
<h3 id="sensitive-content-analysis"><a class="header" href="#sensitive-content-analysis">Sensitive Content Analysis</a></h3>
<pre><code class="language-swift">import SensitiveContentAnalysis

actor ContentAnalyzer {
    private let analyzer = SCSensitivityAnalyzer()
    
    func analyzeImage(_ image: UIImage) async throws -&gt; Bool {
        let policy = SCSensitivityAnalysisPolicy()
        
        let result = try await analyzer.analyzeImage(
            image.cgImage!,
            policy: policy
        )
        
        return result.isSensitive
    }
}
</code></pre>
<p><strong>Privacy Guide</strong>: <a href="https://developer.apple.com/documentation/uikit/protecting-the-user-s-privacy">User Privacy and Data Use</a></p>
<h2 id="-performance"><a class="header" href="#-performance">üìä Performance</a></h2>
<h3 id="metrickit-20"><a class="header" href="#metrickit-20">MetricKit 2.0</a></h3>
<pre><code class="language-swift">import MetricKit

class MetricsManager: NSObject, MXMetricManagerSubscriber {
    override init() {
        super.init()
        MXMetricManager.shared.add(self)
    }
    
    func didReceive(_ payloads: [MXMetricPayload]) {
        for payload in payloads {
            // CPU metrics
            if let cpuMetrics = payload.cpuMetrics {
                print("CPU Time: \(cpuMetrics.cumulativeCPUTime)")
            }
            
            // Memory metrics
            if let memoryMetrics = payload.memoryMetrics {
                print("Peak Memory: \(memoryMetrics.peakMemoryUsage)")
            }
            
            // Network metrics
            if let networkMetrics = payload.networkTransferMetrics {
                print("Cellular: \(networkMetrics.cumulativeCellularDownload)")
            }
        }
    }
}
</code></pre>
<p><strong>WWDC</strong>: <a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Optimize App Performance</a></p>
<h2 id="-gaming"><a class="header" href="#-gaming">üéÆ Gaming</a></h2>
<h3 id="game-controller-support"><a class="header" href="#game-controller-support">Game Controller Support</a></h3>
<pre><code class="language-swift">import GameController

class GameControllerManager: ObservableObject {
    @Published var isConnected = false
    
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(controllerConnected),
            name: .GCControllerDidConnect,
            object: nil
        )
    }
    
    @objc private func controllerConnected(_ notification: Notification) {
        guard let controller = notification.object as? GCController else {
            return
        }
        
        isConnected = true
        setupController(controller)
    }
    
    private func setupController(_ controller: GCController) {
        controller.extendedGamepad?.buttonA.valueChangedHandler = { button, value, pressed in
            if pressed {
                print("Button A pressed")
            }
        }
    }
}
</code></pre>
<h2 id="-device-features"><a class="header" href="#-device-features">üì± Device Features</a></h2>
<h3 id="iphone-16-pro-features"><a class="header" href="#iphone-16-pro-features">iPhone 16 Pro Features</a></h3>
<pre><code class="language-swift">import UIKit

class DeviceCapabilities {
    static var supportsProMotion: Bool {
        UIScreen.main.maximumFramesPerSecond &gt;= 120
    }
    
    static var supportsAlwaysOn: Bool {
        // Check for always-on display support
        if #available(iOS 26, *) {
            return UIDevice.current.userInterfaceIdiom == .phone
        }
        return false
    }
    
    static var hasActionButton: Bool {
        // iPhone 15 Pro and later
        return UIDevice.current.model.contains("iPhone16")
    }
}
</code></pre>
<h3 id="camera-control-api"><a class="header" href="#camera-control-api">Camera Control API</a></h3>
<pre><code class="language-swift">import AVFoundation

class CameraController: NSObject {
    private let captureSession = AVCaptureSession()
    
    func setupCamera() throws {
        guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {
            throw CameraError.deviceNotAvailable
        }
        
        let input = try AVCaptureDeviceInput(device: camera)
        
        if captureSession.canAddInput(input) {
            captureSession.addInput(input)
        }
        
        // Configure for high quality
        captureSession.sessionPreset = .photo
        
        // Enable ProRAW if available
        if camera.activeFormat.isAppleProRAWSupported {
            camera.activeFormat.isAppleProRAWEnabled = true
        }
    }
}

enum CameraError: Error {
    case deviceNotAvailable
}
</code></pre>
<h2 id="-networking"><a class="header" href="#-networking">üåê Networking</a></h2>
<h3 id="urlsession-enhancements"><a class="header" href="#urlsession-enhancements">URLSession Enhancements</a></h3>
<pre><code class="language-swift">import Foundation

actor NetworkManager {
    func fetchData&lt;T: Decodable&gt;(from url: URL) async throws -&gt; T {
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    // Upload with progress
    func upload(data: Data, to url: URL) async throws -&gt; Double {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        
        let (_, response) = try await URLSession.shared.upload(for: request, from: data)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.uploadFailed
        }
        
        return 1.0
    }
}

enum NetworkError: Error {
    case invalidResponse
    case uploadFailed
}
</code></pre>
<h2 id="-best-practices-4"><a class="header" href="#-best-practices-4">üéØ Best Practices</a></h2>
<h3 id="1-adopt-latest-apis"><a class="header" href="#1-adopt-latest-apis">1. Adopt Latest APIs</a></h3>
<pre><code class="language-swift">// ‚úÖ Use modern async/await
func loadData() async throws -&gt; [Item] {
    try await fetchItems()
}

// ‚ùå Avoid completion handlers
func loadData(completion: @escaping ([Item]) -&gt; Void) {
    // Old style
}
</code></pre>
<h3 id="2-support-dark-mode"><a class="header" href="#2-support-dark-mode">2. Support Dark Mode</a></h3>
<pre><code class="language-swift">struct ThemedView: View {
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        Text("Adaptive")
            .foregroundStyle(colorScheme == .dark ? .white : .black)
            .background(Color(uiColor: .systemBackground))
    }
}
</code></pre>
<h3 id="3-optimize-for-battery"><a class="header" href="#3-optimize-for-battery">3. Optimize for Battery</a></h3>
<pre><code class="language-swift">import UIKit

class BatteryOptimizer {
    func optimizeForLowPower() {
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            // Reduce animations
            UIView.setAnimationsEnabled(false)
            
            // Reduce network requests
            // Pause background tasks
        }
    }
}
</code></pre>
<h2 id="-official-resources"><a class="header" href="#-official-resources">üìö Official Resources</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><a href="https://developer.apple.com/documentation/ios-ipados-release-notes">iOS Developer Documentation</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios">Human Interface Guidelines</a></li>
<li><a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a></li>
</ul>
<h3 id="wwdc-sessions"><a class="header" href="#wwdc-sessions">WWDC Sessions</a></h3>
<ul>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Platforms State of the Union</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - What's New in iOS</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Design for iOS</a></li>
</ul>
<h3 id="sample-code"><a class="header" href="#sample-code">Sample Code</a></h3>
<ul>
<li><a href="https://developer.apple.com/sample-code/ios/">iOS Sample Apps</a></li>
<li><a href="https://developer.apple.com/tutorials/swiftui">SwiftUI Tutorials</a></li>
</ul>
<h2 id="-next-steps-3"><a class="header" href="#-next-steps-3">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./macos.html">macOS 26 ‚Üí</a></li>
<li><a href="platforms/./watchos.html">watchOS 26 ‚Üí</a></li>
<li><a href="platforms/./ipados.html">iPadOS 26 ‚Üí</a></li>
</ul>
<hr />
<p><strong>Sources</strong>:</p>
<ul>
<li>Apple Developer Documentation (2025)</li>
<li>iOS 26 Release Notes</li>
<li>WWDC 2025 Sessions</li>
<li>Human Interface Guidelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-26"><a class="header" href="#macos-26">macOS 26</a></h1>
<blockquote>
<p><strong>Build a menu bar app in 25 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build-1"><a class="header" href="#-what-youll-build-1">üéØ What You'll Build</a></h2>
<p>A menu bar utility that:</p>
<ul>
<li>‚úÖ Lives in menu bar</li>
<li>‚úÖ Shows quick info</li>
<li>‚úÖ Global keyboard shortcuts</li>
<li>‚úÖ Native macOS feel</li>
</ul>
<h2 id="-step-1-menu-bar-app"><a class="header" href="#-step-1-menu-bar-app">üöÄ Step 1: Menu Bar App</a></h2>
<pre><code class="language-swift">import SwiftUI

@main
struct MenuBarApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        Settings {
            SettingsView()
        }
    }
}

class AppDelegate: NSObject, NSApplicationDelegate {
    var statusItem: NSStatusItem?
    var popover: NSPopover?
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        // Create menu bar item
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        if let button = statusItem?.button {
            button.image = NSImage(systemSymbolName: "cloud.fill", accessibilityDescription: "Weather")
            button.action = #selector(togglePopover)
            button.target = self
        }
        
        // Create popover
        popover = NSPopover()
        popover?.contentSize = NSSize(width: 300, height: 400)
        popover?.behavior = .transient
        popover?.contentViewController = NSHostingController(rootView: PopoverView())
    }
    
    @objc func togglePopover() {
        guard let button = statusItem?.button else { return }
        
        if let popover = popover {
            if popover.isShown {
                popover.performClose(nil)
            } else {
                popover.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
            }
        }
    }
}

struct PopoverView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("72¬∞")
                .font(.system(size: 60, weight: .bold))
            Text("Sunny")
                .font(.title2)
            
            Divider()
            
            Button("Quit") {
                NSApplication.shared.terminate(nil)
            }
        }
        .padding()
    }
}
</code></pre>
<h2 id="-native-macos-ui"><a class="header" href="#-native-macos-ui">üé® Native macOS UI</a></h2>
<h3 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        NavigationSplitView {
            SidebarView()
        } detail: {
            DetailView()
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                Button {
                    NSApp.keyWindow?.firstResponder?.tryToPerform(#selector(NSSplitViewController.toggleSidebar(_:)), with: nil)
                } label: {
                    Image(systemName: "sidebar.left")
                }
            }
            
            ToolbarItem {
                Button("Add") {
                    // Add action
                }
            }
        }
    }
}
</code></pre>
<h3 id="window-management"><a class="header" href="#window-management">Window Management</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Text("Main Content")
            .frame(minWidth: 600, minHeight: 400)
            .onAppear {
                // Set window properties
                if let window = NSApplication.shared.windows.first {
                    window.title = "My App"
                    window.styleMask.insert(.fullSizeContentView)
                    window.titlebarAppearsTransparent = true
                }
            }
    }
}
</code></pre>
<h3 id="context-menus"><a class="header" href="#context-menus">Context Menus</a></h3>
<pre><code class="language-swift">struct ItemView: View {
    let item: Item
    
    var body: some View {
        Text(item.name)
            .contextMenu {
                Button("Edit") {
                    // Edit action
                }
                Button("Duplicate") {
                    // Duplicate action
                }
                Divider()
                Button("Delete", role: .destructive) {
                    // Delete action
                }
            }
    }
}
</code></pre>
<h2 id="-keyboard-shortcuts"><a class="header" href="#-keyboard-shortcuts">‚å®Ô∏è Keyboard Shortcuts</a></h2>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Text("Content")
            .onAppear {
                setupKeyboardShortcuts()
            }
    }
    
    private func setupKeyboardShortcuts() {
        // Command+N for new item
        NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
            if event.modifierFlags.contains(.command) &amp;&amp; event.charactersIgnoringModifiers == "n" {
                createNewItem()
                return nil
            }
            return event
        }
    }
    
    private func createNewItem() {
        // Create new item
    }
}

// Or use SwiftUI commands
struct ContentView: View {
    var body: some View {
        Text("Content")
    }
}

extension ContentView {
    @CommandsBuilder
    var commands: some Commands {
        CommandMenu("Items") {
            Button("New Item") {
                createNewItem()
            }
            .keyboardShortcut("n", modifiers: .command)
            
            Button("Delete Item") {
                deleteItem()
            }
            .keyboardShortcut(.delete, modifiers: .command)
        }
    }
}
</code></pre>
<h2 id="-file-operations"><a class="header" href="#-file-operations">üéØ File Operations</a></h2>
<h3 id="open-file"><a class="header" href="#open-file">Open File</a></h3>
<pre><code class="language-swift">struct FileOpenerView: View {
    @State private var fileContent = ""
    
    var body: some View {
        VStack {
            Text(fileContent)
            
            Button("Open File") {
                openFile()
            }
        }
    }
    
    private func openFile() {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.allowedContentTypes = [.text]
        
        if panel.runModal() == .OK, let url = panel.url {
            fileContent = (try? String(contentsOf: url)) ?? "Error reading file"
        }
    }
}
</code></pre>
<h3 id="save-file"><a class="header" href="#save-file">Save File</a></h3>
<pre><code class="language-swift">private func saveFile(content: String) {
    let panel = NSSavePanel()
    panel.allowedContentTypes = [.text]
    panel.nameFieldStringValue = "document.txt"
    
    if panel.runModal() == .OK, let url = panel.url {
        try? content.write(to: url, atomically: true, encoding: .utf8)
    }
}
</code></pre>
<h2 id="-drag-and-drop"><a class="header" href="#-drag-and-drop">üé® Drag and Drop</a></h2>
<pre><code class="language-swift">struct DropZoneView: View {
    @State private var droppedFiles: [URL] = []
    
    var body: some View {
        VStack {
            Text("Drop files here")
                .frame(width: 300, height: 200)
                .background(.gray.opacity(0.2))
                .cornerRadius(10)
                .onDrop(of: [.fileURL], isTargeted: nil) { providers in
                    handleDrop(providers: providers)
                    return true
                }
            
            List(droppedFiles, id: \.self) { url in
                Text(url.lastPathComponent)
            }
        }
    }
    
    private func handleDrop(providers: [NSItemProvider]) {
        for provider in providers {
            provider.loadItem(forTypeIdentifier: "public.file-url", options: nil) { item, error in
                if let data = item as? Data,
                   let url = URL(dataRepresentation: data, relativeTo: nil) {
                    DispatchQueue.main.async {
                        droppedFiles.append(url)
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="-system-integration"><a class="header" href="#-system-integration">üéØ System Integration</a></h2>
<h3 id="notifications"><a class="header" href="#notifications">Notifications</a></h3>
<pre><code class="language-swift">import UserNotifications

func sendNotification() {
    let content = UNMutableNotificationContent()
    content.title = "Task Complete"
    content.body = "Your export is ready"
    content.sound = .default
    
    let request = UNNotificationRequest(
        identifier: UUID().uuidString,
        content: content,
        trigger: nil
    )
    
    UNUserNotificationCenter.current().add(request)
}
</code></pre>
<h3 id="dock-badge"><a class="header" href="#dock-badge">Dock Badge</a></h3>
<pre><code class="language-swift">// Set badge
NSApp.dockTile.badgeLabel = "5"

// Clear badge
NSApp.dockTile.badgeLabel = nil
</code></pre>
<h3 id="launch-at-login"><a class="header" href="#launch-at-login">Launch at Login</a></h3>
<pre><code class="language-swift">import ServiceManagement

func enableLaunchAtLogin() {
    try? SMAppService.mainApp.register()
}

func disableLaunchAtLogin() {
    try? SMAppService.mainApp.unregister()
}

var isLaunchAtLoginEnabled: Bool {
    SMAppService.mainApp.status == .enabled
}
</code></pre>
<h2 id="-multi-window-support"><a class="header" href="#-multi-window-support">üé® Multi-Window Support</a></h2>
<pre><code class="language-swift">@main
struct MultiWindowApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Window") {
                    openNewWindow()
                }
                .keyboardShortcut("n", modifiers: .command)
            }
        }
    }
    
    private func openNewWindow() {
        let newWindow = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 600, height: 400),
            styleMask: [.titled, .closable, .miniaturizable, .resizable],
            backing: .buffered,
            defer: false
        )
        newWindow.center()
        newWindow.contentView = NSHostingView(rootView: ContentView())
        newWindow.makeKeyAndOrderFront(nil)
    }
}
</code></pre>
<h2 id="-touch-bar-legacy"><a class="header" href="#-touch-bar-legacy">üéØ Touch Bar (Legacy)</a></h2>
<pre><code class="language-swift">extension NSTouchBar.CustomizationIdentifier {
    static let myApp = NSTouchBar.CustomizationIdentifier("com.myapp.touchbar")
}

extension NSTouchBarItem.Identifier {
    static let playButton = NSTouchBarItem.Identifier("com.myapp.play")
}

class TouchBarController: NSObject, NSTouchBarDelegate {
    func makeTouchBar() -&gt; NSTouchBar {
        let touchBar = NSTouchBar()
        touchBar.customizationIdentifier = .myApp
        touchBar.defaultItemIdentifiers = [.playButton]
        touchBar.delegate = self
        return touchBar
    }
    
    func touchBar(_ touchBar: NSTouchBar, makeItemForIdentifier identifier: NSTouchBarItem.Identifier) -&gt; NSTouchBarItem? {
        switch identifier {
        case .playButton:
            let button = NSButtonTouchBarItem(identifier: identifier, title: "Play", target: self, action: #selector(play))
            return button
        default:
            return nil
        }
    }
    
    @objc func play() {
        // Play action
    }
}
</code></pre>
<h2 id="-mac-catalyst"><a class="header" href="#-mac-catalyst">üé® Mac Catalyst</a></h2>
<p>Convert iOS app to macOS:</p>
<pre><code class="language-swift">// In target settings:
// General ‚Üí Deployment Info ‚Üí Mac (Designed for iPad)

// Platform-specific code
#if targetEnvironment(macCatalyst)
// Mac-specific code
#else
// iOS-specific code
#endif
</code></pre>
<h2 id="-best-practices-5"><a class="header" href="#-best-practices-5">üí° Best Practices</a></h2>
<h3 id="1-native-macos-patterns"><a class="header" href="#1-native-macos-patterns">1. Native macOS Patterns</a></h3>
<pre><code class="language-swift">// ‚úÖ Use NavigationSplitView (not TabView)
NavigationSplitView {
    SidebarView()
} detail: {
    DetailView()
}

// ‚úÖ Use toolbar (not bottom bar)
.toolbar {
    ToolbarItem {
        Button("Action") { }
    }
}
</code></pre>
<h3 id="2-keyboard-first"><a class="header" href="#2-keyboard-first">2. Keyboard First</a></h3>
<pre><code class="language-swift">// Add keyboard shortcuts for everything
.keyboardShortcut("n", modifiers: .command)
.keyboardShortcut("w", modifiers: .command)
.keyboardShortcut("q", modifiers: .command)
</code></pre>
<h3 id="3-window-restoration"><a class="header" href="#3-window-restoration">3. Window Restoration</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    @SceneStorage("selectedTab") private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            // Tabs
        }
    }
}
</code></pre>
<h2 id="-resources-2"><a class="header" href="#-resources-2">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/macos-release-notes">macOS Documentation</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/macos">Human Interface Guidelines</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - What's New in macOS</a></li>
</ul>
<h2 id="-next-steps-4"><a class="header" href="#-next-steps-4">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./ios.html">iOS 26 ‚Üí</a></li>
<li><a href="platforms/./watchos.html">watchOS 26 ‚Üí</a></li>
</ul>
<hr />
<p><strong>Pro tip</strong>: macOS users expect keyboard shortcuts. Add them everywhere!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watchos"><a class="header" href="#watchos">Watchos</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visionos-26"><a class="header" href="#visionos-26">visionOS 26</a></h1>
<blockquote>
<p><strong>Build spatial computing apps for Apple Vision Pro</strong></p>
</blockquote>
<h2 id="-what-makes-visionos-different"><a class="header" href="#-what-makes-visionos-different">üéØ What Makes visionOS Different</a></h2>
<ul>
<li><strong>3D Space</strong>: Apps exist in physical space</li>
<li><strong>Spatial Input</strong>: Eyes, hands, voice</li>
<li><strong>Immersion</strong>: From windows to full immersion</li>
<li><strong>Depth</strong>: Real depth perception</li>
</ul>
<h2 id="-your-first-visionos-app-10-min"><a class="header" href="#-your-first-visionos-app-10-min">üöÄ Your First visionOS App (10 min)</a></h2>
<pre><code class="language-swift">import SwiftUI
import RealityKit

@main
struct HelloVisionApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

struct ContentView: View {
    var body: some View {
        VStack(spacing: 30) {
            Text("Hello, Vision Pro!")
                .font(.extraLargeTitle)
            
            Model3D(named: "Scene") { model in
                model
                    .resizable()
                    .scaledToFit()
            } placeholder: {
                ProgressView()
            }
            .frame(depth: 300)
        }
        .padding()
    }
}
</code></pre>
<p><strong>New</strong>: <code>.frame(depth:)</code> adds 3D depth!</p>
<h2 id="-windows-volumes-and-spaces"><a class="header" href="#-windows-volumes-and-spaces">üé® Windows, Volumes, and Spaces</a></h2>
<h3 id="1-window-2d-content"><a class="header" href="#1-window-2d-content">1. Window (2D Content)</a></h3>
<pre><code class="language-swift">WindowGroup {
    ContentView()
}
</code></pre>
<p><strong>Use for</strong>: Settings, lists, forms</p>
<h3 id="2-volume-3d-content"><a class="header" href="#2-volume-3d-content">2. Volume (3D Content)</a></h3>
<pre><code class="language-swift">WindowGroup(id: "model") {
    Model3DView()
}
.windowStyle(.volumetric)
.defaultSize(width: 0.5, height: 0.5, depth: 0.5, in: .meters)
</code></pre>
<p><strong>Use for</strong>: 3D models, games, visualizations</p>
<h3 id="3-immersive-space-full-immersion"><a class="header" href="#3-immersive-space-full-immersion">3. Immersive Space (Full Immersion)</a></h3>
<pre><code class="language-swift">ImmersiveSpace(id: "immersive") {
    ImmersiveView()
}
.immersionStyle(selection: .constant(.full), in: .full)
</code></pre>
<p><strong>Use for</strong>: Games, experiences, meditation apps</p>
<h2 id="-complete-example-3d-gallery"><a class="header" href="#-complete-example-3d-gallery">üéØ Complete Example: 3D Gallery</a></h2>
<pre><code class="language-swift">import SwiftUI
import RealityKit

@main
struct GalleryApp: App {
    var body: some Scene {
        WindowGroup {
            GalleryView()
        }
        
        ImmersiveSpace(id: "gallery") {
            ImmersiveGalleryView()
        }
    }
}

struct GalleryView: View {
    @Environment(\.openImmersiveSpace) var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) var dismissImmersiveSpace
    @State private var isImmersive = false
    
    var body: some View {
        VStack(spacing: 20) {
            Text("3D Art Gallery")
                .font(.extraLargeTitle)
            
            Button(isImmersive ? "Exit Gallery" : "Enter Gallery") {
                Task {
                    if isImmersive {
                        await dismissImmersiveSpace()
                    } else {
                        await openImmersiveSpace(id: "gallery")
                    }
                    isImmersive.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

struct ImmersiveGalleryView: View {
    var body: some View {
        RealityView { content in
            // Create 3D scene
            let artwork1 = createArtwork(at: SIMD3(x: -1, y: 1.5, z: -2))
            let artwork2 = createArtwork(at: SIMD3(x: 0, y: 1.5, z: -2))
            let artwork3 = createArtwork(at: SIMD3(x: 1, y: 1.5, z: -2))
            
            content.add(artwork1)
            content.add(artwork2)
            content.add(artwork3)
        }
    }
    
    private func createArtwork(at position: SIMD3&lt;Float&gt;) -&gt; Entity {
        let mesh = MeshResource.generateBox(width: 0.5, height: 0.7, depth: 0.05)
        let material = SimpleMaterial(color: .blue, isMetallic: false)
        let entity = ModelEntity(mesh: mesh, materials: [material])
        entity.position = position
        return entity
    }
}
</code></pre>
<h2 id="-spatial-input"><a class="header" href="#-spatial-input">üëÅÔ∏è Spatial Input</a></h2>
<h3 id="eye-tracking"><a class="header" href="#eye-tracking">Eye Tracking</a></h3>
<pre><code class="language-swift">struct InteractiveView: View {
    @State private var isLookedAt = false
    
    var body: some View {
        RealityView { content in
            let entity = ModelEntity(mesh: .generateSphere(radius: 0.1))
            entity.components.set(InputTargetComponent())
            entity.components.set(HoverEffectComponent())
            content.add(entity)
        }
        .onContinuousHover { phase in
            switch phase {
            case .active:
                isLookedAt = true
            case .ended:
                isLookedAt = false
            }
        }
    }
}
</code></pre>
<h3 id="hand-gestures"><a class="header" href="#hand-gestures">Hand Gestures</a></h3>
<pre><code class="language-swift">struct GestureView: View {
    @State private var scale: Float = 1.0
    
    var body: some View {
        RealityView { content in
            let entity = ModelEntity(mesh: .generateBox(size: 0.2))
            entity.components.set(InputTargetComponent())
            content.add(entity)
        }
        .gesture(
            MagnifyGesture()
                .onChanged { value in
                    scale = Float(value.magnification)
                }
        )
    }
}
</code></pre>
<h2 id="-realitykit-basics"><a class="header" href="#-realitykit-basics">üéÆ RealityKit Basics</a></h2>
<h3 id="create-3d-objects"><a class="header" href="#create-3d-objects">Create 3D Objects</a></h3>
<pre><code class="language-swift">// Sphere
let sphere = ModelEntity(
    mesh: .generateSphere(radius: 0.1),
    materials: [SimpleMaterial(color: .red, isMetallic: true)]
)

// Box
let box = ModelEntity(
    mesh: .generateBox(size: 0.2),
    materials: [SimpleMaterial(color: .blue, isMetallic: false)]
)

// Custom mesh
let mesh = MeshResource.generateBox(width: 0.3, height: 0.2, depth: 0.1)
let entity = ModelEntity(mesh: mesh)
</code></pre>
<h3 id="positioning"><a class="header" href="#positioning">Positioning</a></h3>
<pre><code class="language-swift">entity.position = SIMD3(x: 0, y: 1.5, z: -2)
entity.orientation = simd_quatf(angle: .pi / 4, axis: [0, 1, 0])
entity.scale = SIMD3(repeating: 1.5)
</code></pre>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<pre><code class="language-swift">var transform = entity.transform
transform.translation.y += 0.5

entity.move(
    to: transform,
    relativeTo: nil,
    duration: 1.0,
    timingFunction: .easeInOut
)
</code></pre>
<h2 id="-spatial-anchors"><a class="header" href="#-spatial-anchors">üåç Spatial Anchors</a></h2>
<h3 id="place-objects-in-real-world"><a class="header" href="#place-objects-in-real-world">Place Objects in Real World</a></h3>
<pre><code class="language-swift">import ARKit

struct AnchoredView: View {
    var body: some View {
        RealityView { content in
            // Create anchor
            let anchor = AnchorEntity(.plane(.horizontal, classification: .floor, minimumBounds: [0.5, 0.5]))
            
            // Add object to anchor
            let entity = ModelEntity(mesh: .generateBox(size: 0.2))
            anchor.addChild(entity)
            
            content.add(anchor)
        }
    }
}
</code></pre>
<h2 id="-practical-example-solar-system"><a class="header" href="#-practical-example-solar-system">üéØ Practical Example: Solar System</a></h2>
<pre><code class="language-swift">struct SolarSystemView: View {
    var body: some View {
        RealityView { content in
            // Sun
            let sun = createPlanet(radius: 0.3, color: .yellow)
            sun.position = [0, 1.5, -2]
            content.add(sun)
            
            // Earth
            let earth = createPlanet(radius: 0.1, color: .blue)
            earth.position = [0.8, 1.5, -2]
            content.add(earth)
            
            // Orbit animation
            animateOrbit(earth, around: sun)
        }
    }
    
    private func createPlanet(radius: Float, color: UIColor) -&gt; ModelEntity {
        let mesh = MeshResource.generateSphere(radius: radius)
        let material = SimpleMaterial(color: color, isMetallic: false)
        return ModelEntity(mesh: mesh, materials: [material])
    }
    
    private func animateOrbit(_ planet: ModelEntity, around center: ModelEntity) {
        // Circular orbit animation
        let duration: TimeInterval = 10.0
        
        Timer.scheduledTimer(withTimeInterval: 0.016, repeats: true) { _ in
            let angle = Float(Date().timeIntervalSince1970.truncatingRemainder(dividingBy: duration) / duration * 2 * .pi)
            planet.position.x = center.position.x + 0.8 * cos(angle)
            planet.position.z = center.position.z + 0.8 * sin(angle)
        }
    }
}
</code></pre>
<h2 id="-materials-and-lighting"><a class="header" href="#-materials-and-lighting">üé® Materials and Lighting</a></h2>
<h3 id="physical-materials"><a class="header" href="#physical-materials">Physical Materials</a></h3>
<pre><code class="language-swift">var material = PhysicallyBasedMaterial()
material.baseColor = .init(tint: .blue)
material.roughness = 0.3
material.metallic = 0.8

let entity = ModelEntity(mesh: mesh, materials: [material])
</code></pre>
<h3 id="image-based-lighting"><a class="header" href="#image-based-lighting">Image-Based Lighting</a></h3>
<pre><code class="language-swift">// Add environment lighting
let environment = try await EnvironmentResource(named: "studio")
entity.components.set(ImageBasedLightComponent(source: .single(environment)))
</code></pre>
<h2 id="-passthrough-and-immersion"><a class="header" href="#-passthrough-and-immersion">üéØ Passthrough and Immersion</a></h2>
<pre><code class="language-swift">@main
struct ImmersiveApp: App {
    @State private var immersionLevel: ImmersionStyle = .mixed
    
    var body: some Scene {
        ImmersiveSpace(id: "space") {
            ContentView()
        }
        .immersionStyle(selection: $immersionLevel, in: .mixed, .progressive, .full)
    }
}
</code></pre>
<p><strong>Levels</strong>:</p>
<ul>
<li><code>.mixed</code>: See real world + virtual objects</li>
<li><code>.progressive</code>: Gradually fade real world</li>
<li><code>.full</code>: Complete virtual environment</li>
</ul>
<h2 id="-game-example-catch-the-balls"><a class="header" href="#-game-example-catch-the-balls">üéÆ Game Example: Catch the Balls</a></h2>
<pre><code class="language-swift">struct CatchGameView: View {
    @State private var score = 0
    
    var body: some View {
        RealityView { content in
            // Spawn balls
            Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
                let ball = createBall()
                content.add(ball)
                animateFall(ball)
            }
        } update: { content in
            // Update score display
        }
        .overlay(alignment: .top) {
            Text("Score: \(score)")
                .font(.extraLargeTitle)
                .padding()
        }
    }
    
    private func createBall() -&gt; ModelEntity {
        let ball = ModelEntity(
            mesh: .generateSphere(radius: 0.1),
            materials: [SimpleMaterial(color: .red, isMetallic: false)]
        )
        ball.position = SIMD3(
            x: Float.random(in: -1...1),
            y: 2,
            z: -2
        )
        ball.components.set(InputTargetComponent())
        return ball
    }
    
    private func animateFall(_ ball: ModelEntity) {
        var transform = ball.transform
        transform.translation.y = 0
        
        ball.move(to: transform, relativeTo: nil, duration: 3.0)
    }
}
</code></pre>
<h2 id="-best-practices-6"><a class="header" href="#-best-practices-6">üí° Best Practices</a></h2>
<h3 id="1-comfortable-viewing-distance"><a class="header" href="#1-comfortable-viewing-distance">1. Comfortable Viewing Distance</a></h3>
<pre><code class="language-swift">// Place content 1-3 meters away
entity.position.z = -2.0  // 2 meters
</code></pre>
<h3 id="2-appropriate-scale"><a class="header" href="#2-appropriate-scale">2. Appropriate Scale</a></h3>
<pre><code class="language-swift">// Real-world scale
let chair = ModelEntity(mesh: chairMesh)
chair.scale = SIMD3(repeating: 1.0)  // 1:1 scale
</code></pre>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<pre><code class="language-swift">// Use LOD (Level of Detail)
entity.components.set(ModelComponent(
    mesh: mesh,
    materials: materials
))

// Limit polygon count
// Target: &lt; 100K polygons per scene
</code></pre>
<h3 id="4-accessibility"><a class="header" href="#4-accessibility">4. Accessibility</a></h3>
<pre><code class="language-swift">// Add accessibility labels
entity.accessibilityLabel = "Red sphere"
entity.accessibilityHint = "Tap to interact"
</code></pre>
<h2 id="-testing-1"><a class="header" href="#-testing-1">üéØ Testing</a></h2>
<h3 id="simulator"><a class="header" href="#simulator">Simulator</a></h3>
<pre><code class="language-bash"># Run in visionOS Simulator
xcodebuild -scheme YourApp \
  -destination 'platform=visionOS Simulator,name=Apple Vision Pro'
</code></pre>
<h3 id="device"><a class="header" href="#device">Device</a></h3>
<ul>
<li>Requires Apple Vision Pro</li>
<li>Use Xcode wireless debugging</li>
<li>Test with real spatial input</li>
</ul>
<h2 id="-resources-3"><a class="header" href="#-resources-3">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/visionos">visionOS Documentation</a></li>
<li><a href="https://developer.apple.com/documentation/realitykit">RealityKit</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10066/">WWDC23 - Meet visionOS</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/designing-for-visionos">Human Interface Guidelines</a></li>
</ul>
<h2 id="-next-steps-5"><a class="header" href="#-next-steps-5">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./ios.html">iOS 26 ‚Üí</a></li>
<li><a href="platforms/../swiftui/essentials.html">SwiftUI Essentials ‚Üí</a></li>
</ul>
<hr />
<p><strong>Remember</strong>: Think in 3D space. Design for comfort. Test on device.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aso-optimization"><a class="header" href="#aso-optimization">ASO Optimization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-strategy"><a class="header" href="#feature-strategy">Feature Strategy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-management"><a class="header" href="#review-management">Review Management</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="launch-strategy"><a class="header" href="#launch-strategy">Launch Strategy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-store-guidelines"><a class="header" href="#app-store-guidelines">App Store Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-review-process"><a class="header" href="#app-review-process">App Review Process</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storekit--monetization"><a class="header" href="#storekit--monetization">StoreKit &amp; Monetization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testflight-beta-testing"><a class="header" href="#testflight-beta-testing">TestFlight Beta Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xcode-best-practices"><a class="header" href="#xcode-best-practices">Xcode Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-testing"><a class="header" href="#swift-testing">Swift Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xcode-cloud-cicd"><a class="header" href="#xcode-cloud-cicd">Xcode Cloud CI/CD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apples-accessibility-guidelines"><a class="header" href="#apples-accessibility-guidelines">Apple's Accessibility Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="voiceover-integration"><a class="header" href="#voiceover-integration">VoiceOver Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-type-support"><a class="header" href="#dynamic-type-support">Dynamic Type Support</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color--contrast"><a class="header" href="#color--contrast">Color &amp; Contrast</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="photo-editor-app"><a class="header" href="#photo-editor-app">Photo Editor App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscription-news-app"><a class="header" href="#subscription-news-app">Subscription News App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="social-media-app"><a class="header" href="#social-media-app">Social Media App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="productivity-app"><a class="header" href="#productivity-app">Productivity App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrumdinger-meeting-app"><a class="header" href="#scrumdinger-meeting-app">Scrumdinger (Meeting App)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="landmarks-swiftui-tutorial"><a class="header" href="#landmarks-swiftui-tutorial">Landmarks (SwiftUI Tutorial)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="earthquake-data-visualization"><a class="header" href="#earthquake-data-visualization">Earthquake (Data Visualization)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ml-classifier-core-ml"><a class="header" href="#ml-classifier-core-ml">ML Classifier (Core ML)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessibility-excellence"><a class="header" href="#accessibility-excellence">Accessibility Excellence</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internationalization"><a class="header" href="#internationalization">Internationalization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analytics--monitoring"><a class="header" href="#analytics--monitoring">Analytics &amp; Monitoring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-package-manager-1"><a class="header" href="#swift-package-manager-1">Swift Package Manager</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-frameworks"><a class="header" href="#custom-frameworks">Custom Frameworks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-intelligence-deep-dive"><a class="header" href="#apple-intelligence-deep-dive">Apple Intelligence Deep Dive</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui-performance-tips"><a class="header" href="#swiftui-performance-tips">SwiftUI Performance Tips</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-best-practices"><a class="header" href="#concurrency-best-practices">Concurrency Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-platform-development"><a class="header" href="#cross-platform-development">Cross-Platform Development</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-developer-resources"><a class="header" href="#apple-developer-resources">Apple Developer Resources</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wwdc-session-references"><a class="header" href="#wwdc-session-references">WWDC Session References</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community"><a class="header" href="#community">Community</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="certification-preparation"><a class="header" href="#certification-preparation">Certification Preparation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-generated-contentnnthis-directory-contains-content-automatically-generated-by-the-autonomous-agent"><a class="header" href="#auto-generated-contentnnthis-directory-contains-content-automatically-generated-by-the-autonomous-agent">Auto-Generated Content\n\nThis directory contains content automatically generated by the autonomous agent.</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
