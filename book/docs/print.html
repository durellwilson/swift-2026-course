<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swift &amp; Apple Platforms 2026: Complete Developer Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Production-ready Swift development for iOS 26, macOS 26, and all Apple platforms with ML, open-source frameworks, and monetization strategies">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Swift &amp; Apple Platforms 2026: Complete Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/durellwilson/swift-2026-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swift--apple-platforms-2026"><a class="header" href="#swift--apple-platforms-2026">Swift &amp; Apple Platforms 2026</a></h1>
<blockquote>
<p><strong>Production-ready development for iOS 26, macOS 26, and all Apple platforms</strong></p>
</blockquote>
<h2 id="-what-youll-learn"><a class="header" href="#-what-youll-learn">üéØ What You'll Learn</a></h2>
<p>This comprehensive guide covers everything you need to build, deploy, and monetize modern Apple platform applications in 2026:</p>
<ul>
<li>‚úÖ <strong>Swift 6.0</strong> - Latest language features, concurrency, and macros</li>
<li>‚úÖ <strong>SwiftUI</strong> - Declarative UI for all Apple platforms</li>
<li>‚úÖ <strong>Machine Learning</strong> - Core ML, Create ML, and Foundation Models</li>
<li>‚úÖ <strong>All Platforms</strong> - iOS, macOS, watchOS, iPadOS, tvOS, visionOS 26</li>
<li>‚úÖ <strong>Open Source</strong> - Swift packages, contributing, and community</li>
<li>‚úÖ <strong>Monetization</strong> - App Store optimization, IAP, subscriptions, GTM</li>
<li>‚úÖ <strong>Production</strong> - Architecture, testing, CI/CD, security</li>
</ul>
<h2 id="-who-this-is-for"><a class="header" href="#-who-this-is-for">üöÄ Who This Is For</a></h2>
<ul>
<li><strong>iOS Developers</strong> upgrading to latest platforms</li>
<li><strong>Cross-platform developers</strong> targeting Apple ecosystem</li>
<li><strong>ML Engineers</strong> integrating AI into apps</li>
<li><strong>Indie developers</strong> building monetizable products</li>
<li><strong>Open source contributors</strong> to Swift ecosystem</li>
</ul>
<h2 id="-platform-coverage"><a class="header" href="#-platform-coverage">üì± Platform Coverage</a></h2>
<h3 id="ios-26"><a class="header" href="#ios-26">iOS 26</a></h3>
<ul>
<li>New APIs and frameworks</li>
<li>iPhone-specific features</li>
<li>Performance optimizations</li>
</ul>
<h3 id="macos-26"><a class="header" href="#macos-26">macOS 26</a></h3>
<ul>
<li>Desktop app development</li>
<li>Mac Catalyst updates</li>
<li>System integration</li>
</ul>
<h3 id="watchos-26"><a class="header" href="#watchos-26">watchOS 26</a></h3>
<ul>
<li>Health &amp; fitness apps</li>
<li>Complications &amp; widgets</li>
<li>Always-on features</li>
</ul>
<h3 id="ipados-26"><a class="header" href="#ipados-26">iPadOS 26</a></h3>
<ul>
<li>Multi-window support</li>
<li>Pencil integration</li>
<li>Desktop-class features</li>
</ul>
<h3 id="tvos-26"><a class="header" href="#tvos-26">tvOS 26</a></h3>
<ul>
<li>Living room experiences</li>
<li>Remote interactions</li>
<li>Media playback</li>
</ul>
<h3 id="visionos-26"><a class="header" href="#visionos-26">visionOS 26</a></h3>
<ul>
<li>Spatial computing</li>
<li>3D interfaces</li>
<li>Mixed reality apps</li>
</ul>
<h2 id="-machine-learning-focus"><a class="header" href="#-machine-learning-focus">ü§ñ Machine Learning Focus</a></h2>
<h3 id="foundation-models"><a class="header" href="#foundation-models">Foundation Models</a></h3>
<ul>
<li>On-device LLMs</li>
<li>Vision transformers</li>
<li>Audio processing</li>
</ul>
<h3 id="core-ml-integration"><a class="header" href="#core-ml-integration">Core ML Integration</a></h3>
<ul>
<li>Model deployment</li>
<li>Performance optimization</li>
<li>Privacy-first ML</li>
</ul>
<h3 id="create-ml-workflows"><a class="header" href="#create-ml-workflows">Create ML Workflows</a></h3>
<ul>
<li>Training custom models</li>
<li>Data preparation</li>
<li>Model evaluation</li>
</ul>
<h2 id="-monetization-strategies"><a class="header" href="#-monetization-strategies">üí∞ Monetization Strategies</a></h2>
<h3 id="app-store-optimization"><a class="header" href="#app-store-optimization">App Store Optimization</a></h3>
<ul>
<li>ASO best practices</li>
<li>Keyword research</li>
<li>Conversion optimization</li>
</ul>
<h3 id="revenue-models"><a class="header" href="#revenue-models">Revenue Models</a></h3>
<ul>
<li>One-time purchases</li>
<li>Subscriptions</li>
<li>In-app purchases</li>
<li>Freemium strategies</li>
</ul>
<h3 id="analytics--gtm"><a class="header" href="#analytics--gtm">Analytics &amp; GTM</a></h3>
<ul>
<li>Google Tag Manager</li>
<li>Firebase Analytics</li>
<li>Custom event tracking</li>
<li>A/B testing</li>
</ul>
<h2 id="-development-tools"><a class="header" href="#-development-tools">üîß Development Tools</a></h2>
<h3 id="xcode-26"><a class="header" href="#xcode-26">Xcode 26</a></h3>
<ul>
<li>New IDE features</li>
<li>Cloud development</li>
<li>AI-assisted coding</li>
<li>Performance profiling</li>
</ul>
<h3 id="swift-package-manager"><a class="header" href="#swift-package-manager">Swift Package Manager</a></h3>
<ul>
<li>Dependency management</li>
<li>Package creation</li>
<li>Distribution strategies</li>
</ul>
<h3 id="testing--cicd"><a class="header" href="#testing--cicd">Testing &amp; CI/CD</a></h3>
<ul>
<li>XCTest &amp; Swift Testing</li>
<li>GitHub Actions</li>
<li>Xcode Cloud</li>
<li>Automated deployment</li>
</ul>
<h2 id="-course-structure"><a class="header" href="#-course-structure">üìö Course Structure</a></h2>
<p>Each chapter includes:</p>
<ul>
<li>üìñ <strong>Concepts</strong> - Theory and best practices</li>
<li>üíª <strong>Code Examples</strong> - Production-ready snippets</li>
<li>üéØ <strong>Projects</strong> - Hands-on implementations</li>
<li>üìä <strong>Case Studies</strong> - Real-world applications</li>
<li>üîó <strong>Resources</strong> - Official docs and community links</li>
</ul>
<h2 id="-prerequisites"><a class="header" href="#-prerequisites">üåü Prerequisites</a></h2>
<ul>
<li>Basic Swift knowledge</li>
<li>Xcode installed</li>
<li>Apple Developer account (for deployment)</li>
<li>macOS 15+ recommended</li>
</ul>
<h2 id="-learning-path"><a class="header" href="#-learning-path">üéì Learning Path</a></h2>
<ol>
<li>
<p><strong>Foundations</strong> (Weeks 1-2)</p>
<ul>
<li>Swift 6.0 features</li>
<li>SwiftUI basics</li>
<li>Platform overview</li>
</ul>
</li>
<li>
<p><strong>Frameworks</strong> (Weeks 3-4)</p>
<ul>
<li>SwiftData &amp; persistence</li>
<li>AppIntents &amp; Shortcuts</li>
<li>WidgetKit &amp; Live Activities</li>
</ul>
</li>
<li>
<p><strong>Machine Learning</strong> (Weeks 5-6)</p>
<ul>
<li>Core ML integration</li>
<li>Foundation models</li>
<li>Vision &amp; NLP</li>
</ul>
</li>
<li>
<p><strong>Production</strong> (Weeks 7-8)</p>
<ul>
<li>Architecture patterns</li>
<li>Testing strategies</li>
<li>Deployment &amp; monetization</li>
</ul>
</li>
</ol>
<h2 id="-community"><a class="header" href="#-community">ü§ù Community</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/durellwilson/swift-2026-course">durellwilson/swift-2026-course</a></li>
<li><strong>Discussions</strong>: Share projects and get help</li>
<li><strong>Issues</strong>: Report errors or suggest improvements</li>
<li><strong>Contributions</strong>: PRs welcome!</li>
</ul>
<hr />
<p><strong>Ready to build?</strong> Let's start with <a href="./swift/swift-6.html">Swift 6.0 Features ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-apples-develop-in-swift"><a class="header" href="#getting-started-with-apples-develop-in-swift">Getting Started with Apple's Develop in Swift</a></h1>
<blockquote>
<p>This course is designed to complement and extend Apple's official "Develop in Swift" educational framework.</p>
</blockquote>
<h2 id="-apples-educational-philosophy"><a class="header" href="#-apples-educational-philosophy">üçé Apple's Educational Philosophy</a></h2>
<p>Apple's "Develop in Swift" follows a progressive learning approach:</p>
<ol>
<li><strong>Swift Fundamentals</strong> - Core language concepts</li>
<li><strong>iOS App Development</strong> - Building real applications</li>
<li><strong>Advanced Features</strong> - Platform-specific capabilities</li>
<li><strong>Professional Skills</strong> - Industry best practices</li>
</ol>
<h2 id="-official-apple-resources"><a class="header" href="#-official-apple-resources">üìö Official Apple Resources</a></h2>
<h3 id="primary-resources"><a class="header" href="#primary-resources">Primary Resources</a></h3>
<ul>
<li><strong><a href="https://developer.apple.com/tutorials/develop-in-swift/">Develop in Swift Tutorials</a></strong> - Apple's main curriculum</li>
<li><strong><a href="https://developer.apple.com/swift-playgrounds/">Swift Playgrounds</a></strong> - Interactive learning</li>
<li><strong><a href="https://developer.apple.com/tutorials/swiftui">SwiftUI Tutorials</a></strong> - UI framework mastery</li>
<li><strong><a href="https://developer.apple.com/sample-code/">Sample Code</a></strong> - Real-world examples</li>
</ul>
<h3 id="supporting-materials"><a class="header" href="#supporting-materials">Supporting Materials</a></h3>
<ul>
<li><strong><a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a></strong> - Design principles</li>
<li><strong><a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a></strong> - Submission standards</li>
<li><strong><a href="https://developer.apple.com/accessibility/">Accessibility Guidelines</a></strong> - Inclusive design</li>
</ul>
<h2 id="-learning-objectives-apple-aligned"><a class="header" href="#-learning-objectives-apple-aligned">üéØ Learning Objectives (Apple-Aligned)</a></h2>
<p>By following Apple's methodology, you'll master:</p>
<h3 id="swift-language-proficiency"><a class="header" href="#swift-language-proficiency">Swift Language Proficiency</a></h3>
<ul>
<li>Variables, constants, and data types</li>
<li>Control flow and error handling</li>
<li>Functions, closures, and protocols</li>
<li>Object-oriented and protocol-oriented programming</li>
</ul>
<h3 id="ios-development-skills"><a class="header" href="#ios-development-skills">iOS Development Skills</a></h3>
<ul>
<li>SwiftUI declarative UI development</li>
<li>Data management with SwiftData</li>
<li>Networking and API integration</li>
<li>Testing and debugging workflows</li>
</ul>
<h3 id="apple-platform-integration"><a class="header" href="#apple-platform-integration">Apple Platform Integration</a></h3>
<ul>
<li>Core frameworks (CloudKit, Core ML, etc.)</li>
<li>Platform-specific features (widgets, shortcuts)</li>
<li>Accessibility and inclusive design</li>
<li>App Store optimization and distribution</li>
</ul>
<h2 id="-development-environment-setup"><a class="header" href="#-development-environment-setup">üõ† Development Environment Setup</a></h2>
<h3 id="required-tools-apple-ecosystem"><a class="header" href="#required-tools-apple-ecosystem">Required Tools (Apple Ecosystem)</a></h3>
<pre><code class="language-bash"># Xcode (latest version)
# Available from Mac App Store or Apple Developer

# Swift Playgrounds (optional but recommended)
# Available from Mac App Store

# Apple Developer Account
# Free tier available at developer.apple.com
</code></pre>
<h3 id="recommended-configuration"><a class="header" href="#recommended-configuration">Recommended Configuration</a></h3>
<ul>
<li><strong>macOS</strong>: Latest stable version</li>
<li><strong>Xcode</strong>: Latest stable release</li>
<li><strong>iOS Simulator</strong>: Multiple device types</li>
<li><strong>Apple ID</strong>: For testing and distribution</li>
</ul>
<h2 id="-sample-project-structure-apple-standard"><a class="header" href="#-sample-project-structure-apple-standard">üì± Sample Project Structure (Apple Standard)</a></h2>
<p>Apple recommends this project organization:</p>
<pre><code>MyApp/
‚îú‚îÄ‚îÄ MyApp.xcodeproj
‚îú‚îÄ‚îÄ MyApp/
‚îÇ   ‚îú‚îÄ‚îÄ App/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MyAppApp.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ContentView.swift
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataModel.swift
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DetailView.swift
‚îÇ   ‚îî‚îÄ‚îÄ Resources/
‚îÇ       ‚îî‚îÄ‚îÄ Assets.xcassets
‚îú‚îÄ‚îÄ MyAppTests/
‚îî‚îÄ‚îÄ MyAppUITests/
</code></pre>
<h2 id="-certification-path"><a class="header" href="#-certification-path">üéì Certification Path</a></h2>
<p>This course prepares you for:</p>
<ul>
<li><strong>Apple Developer Certification</strong> (when available)</li>
<li><strong>Swift Student Challenge</strong> participation</li>
<li><strong>WWDC Scholarship</strong> applications</li>
<li><strong>Professional iOS development</strong> roles</li>
</ul>
<h2 id="-how-to-use-this-course"><a class="header" href="#-how-to-use-this-course">üìñ How to Use This Course</a></h2>
<ol>
<li><strong>Start with Apple's tutorials</strong> - Build foundational knowledge</li>
<li><strong>Practice with Swift Playgrounds</strong> - Interactive learning</li>
<li><strong>Build sample projects</strong> - Apply concepts practically</li>
<li><strong>Extend with advanced topics</strong> - Go beyond basics</li>
<li><strong>Contribute to community</strong> - Share your learning</li>
</ol>
<h2 id="-next-steps"><a class="header" href="#-next-steps">üîó Next Steps</a></h2>
<p>Continue to <a href="apple-framework/./playgrounds.html">Swift Playgrounds Integration</a> to set up your interactive learning environment.</p>
<hr />
<p><em>This course content is designed to complement Apple's official educational materials and follows their recommended learning progression.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-developer-resources-2025"><a class="header" href="#apple-developer-resources-2025">Apple Developer Resources 2025</a></h1>
<blockquote>
<p>Stay current with Apple's latest development tools and frameworks</p>
</blockquote>
<h2 id="-whats-new-in-2025"><a class="header" href="#-whats-new-in-2025">üÜï What's New in 2025</a></h2>
<h3 id="swift-60-stable-release"><a class="header" href="#swift-60-stable-release">Swift 6.0 Stable Release</a></h3>
<ul>
<li><strong>Complete concurrency model</strong> with data race safety by default</li>
<li><strong>Typed throws</strong> for more precise error handling</li>
<li><strong>Noncopyable types</strong> for zero-copy performance</li>
<li><strong>Parameter packs</strong> for advanced generic programming</li>
</ul>
<h3 id="ios-18-features"><a class="header" href="#ios-18-features">iOS 18+ Features</a></h3>
<ul>
<li><strong>App Intents</strong> enhanced integration with Siri and Shortcuts</li>
<li><strong>WidgetKit</strong> interactive widgets and Live Activities</li>
<li><strong>SwiftData</strong> improvements and CloudKit sync</li>
<li><strong>Control Center</strong> customizable controls API</li>
</ul>
<h3 id="xcode-16-improvements"><a class="header" href="#xcode-16-improvements">Xcode 16+ Improvements</a></h3>
<ul>
<li><strong>Swift Testing</strong> framework built into Xcode</li>
<li><strong>Enhanced debugging</strong> for concurrency and memory issues</li>
<li><strong>Improved SwiftUI previews</strong> with better performance</li>
<li><strong>Xcode Cloud</strong> expanded CI/CD capabilities</li>
</ul>
<h2 id="-key-learning-resources"><a class="header" href="#-key-learning-resources">üì∫ Key Learning Resources</a></h2>
<h3 id="official-apple-documentation"><a class="header" href="#official-apple-documentation">Official Apple Documentation</a></h3>
<ul>
<li><strong><a href="https://swift.org">Swift.org</a></strong> - Language updates and evolution</li>
<li><strong><a href="https://developer.apple.com/documentation/">Developer Documentation</a></strong> - Framework references</li>
<li><strong><a href="https://developer.apple.com/videos/">WWDC Videos</a></strong> - Session recordings</li>
<li><strong><a href="https://developer.apple.com/sample-code/">Sample Code</a></strong> - Working examples</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><strong><a href="https://forums.swift.org">Swift Forums</a></strong> - Language discussions</li>
<li><strong><a href="https://developer.apple.com/forums/">Apple Developer Forums</a></strong> - Platform support</li>
<li><strong><a href="https://github.com/apple/swift">GitHub Swift</a></strong> - Open source development</li>
</ul>
<h2 id="-modern-development-patterns"><a class="header" href="#-modern-development-patterns">üîß Modern Development Patterns</a></h2>
<h3 id="concurrency-with-swift-6"><a class="header" href="#concurrency-with-swift-6">Concurrency with Swift 6</a></h3>
<pre><code class="language-swift">// Data race safety by default
actor DataStore {
    private var items: [String] = []
    
    func add(_ item: String) {
        items.append(item)
    }
    
    func getItems() -&gt; [String] {
        return items
    }
}

// Usage
let store = DataStore()
await store.add("New Item")
let items = await store.getItems()
</code></pre>
<h3 id="swiftui-with-observation"><a class="header" href="#swiftui-with-observation">SwiftUI with Observation</a></h3>
<pre><code class="language-swift">import SwiftUI
import Observation

@Observable
class AppModel {
    var items: [Item] = []
    var isLoading = false
    
    func loadItems() async {
        isLoading = true
        defer { isLoading = false }
        
        // Simulate network call
        try? await Task.sleep(for: .seconds(1))
        items = [Item(name: "Sample Item")]
    }
}

struct ContentView: View {
    @State private var model = AppModel()
    
    var body: some View {
        NavigationView {
            List(model.items) { item in
                Text(item.name)
            }
            .navigationTitle("Items")
            .task {
                await model.loadItems()
            }
            .overlay {
                if model.isLoading {
                    ProgressView()
                }
            }
        }
    }
}

struct Item: Identifiable {
    let id = UUID()
    let name: String
}
</code></pre>
<h3 id="app-intents-integration"><a class="header" href="#app-intents-integration">App Intents Integration</a></h3>
<pre><code class="language-swift">import AppIntents

struct AddItemIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Item"
    static var description = IntentDescription("Add a new item to your list")
    
    @Parameter(title: "Item Name")
    var itemName: String
    
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        // Add item to your app's data store
        await DataManager.shared.addItem(named: itemName)
        
        return .result(
            dialog: "Added \(itemName) to your list"
        )
    }
}

// Register in your App struct
@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
    
    init() {
        // Register app intents
        AppDependencyManager.shared.add(dependency: DataManager.shared)
    }
}
</code></pre>
<h2 id="-best-practices-for-2025"><a class="header" href="#-best-practices-for-2025">üéØ Best Practices for 2025</a></h2>
<h3 id="1-embrace-concurrency"><a class="header" href="#1-embrace-concurrency">1. Embrace Concurrency</a></h3>
<pre><code class="language-swift">// Use structured concurrency
func loadUserData() async throws -&gt; UserData {
    async let profile = loadProfile()
    async let preferences = loadPreferences()
    async let history = loadHistory()
    
    return try await UserData(
        profile: profile,
        preferences: preferences,
        history: history
    )
}
</code></pre>
<h3 id="2-leverage-swiftdata"><a class="header" href="#2-leverage-swiftdata">2. Leverage SwiftData</a></h3>
<pre><code class="language-swift">import SwiftData

@Model
class Task {
    var title: String
    var isCompleted: Bool
    var createdAt: Date
    
    init(title: String) {
        self.title = title
        self.isCompleted = false
        self.createdAt = Date()
    }
}

// In your App
@main
struct TaskApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: Task.self)
    }
}
</code></pre>
<h3 id="3-optimize-performance"><a class="header" href="#3-optimize-performance">3. Optimize Performance</a></h3>
<pre><code class="language-swift">// Use lazy loading for large datasets
struct LazyItemList: View {
    @State private var items: [Item] = []
    
    var body: some View {
        LazyVStack {
            ForEach(items) { item in
                ItemRow(item: item)
                    .onAppear {
                        if item == items.last {
                            loadMoreItems()
                        }
                    }
            }
        }
    }
    
    private func loadMoreItems() {
        // Load more items asynchronously
        Task {
            let newItems = await ItemService.loadMore()
            items.append(contentsOf: newItems)
        }
    }
}
</code></pre>
<h2 id="-platform-specific-updates"><a class="header" href="#-platform-specific-updates">üì± Platform-Specific Updates</a></h2>
<h3 id="ios-18"><a class="header" href="#ios-18">iOS 18+</a></h3>
<ul>
<li>Enhanced privacy controls</li>
<li>Improved accessibility features</li>
<li>Better battery optimization</li>
<li>Advanced camera capabilities</li>
</ul>
<h3 id="macos-sequoia"><a class="header" href="#macos-sequoia">macOS Sequoia</a></h3>
<ul>
<li>Desktop widgets support</li>
<li>Enhanced window management</li>
<li>Improved Metal performance</li>
<li>Better cross-platform compatibility</li>
</ul>
<h3 id="watchos-11"><a class="header" href="#watchos-11">watchOS 11</a></h3>
<ul>
<li>New health sensors support</li>
<li>Improved workout tracking</li>
<li>Enhanced complications</li>
<li>Better battery life</li>
</ul>
<h3 id="visionos-2"><a class="header" href="#visionos-2">visionOS 2</a></h3>
<ul>
<li>Improved hand tracking</li>
<li>Enhanced spatial audio</li>
<li>Better passthrough quality</li>
<li>New gesture patterns</li>
</ul>
<h2 id="-development-tools-1"><a class="header" href="#-development-tools-1">üõ† Development Tools</a></h2>
<h3 id="xcode-16-features"><a class="header" href="#xcode-16-features">Xcode 16 Features</a></h3>
<ul>
<li>Swift Testing integration</li>
<li>Enhanced code completion</li>
<li>Improved debugging tools</li>
<li>Better performance profiling</li>
</ul>
<h3 id="swift-package-manager-1"><a class="header" href="#swift-package-manager-1">Swift Package Manager</a></h3>
<ul>
<li>Improved dependency resolution</li>
<li>Better build performance</li>
<li>Enhanced security features</li>
<li>Cross-platform support</li>
</ul>
<h2 id="-recommended-learning-path"><a class="header" href="#-recommended-learning-path">üìö Recommended Learning Path</a></h2>
<h3 id="1-foundation-week-1-2"><a class="header" href="#1-foundation-week-1-2">1. Foundation (Week 1-2)</a></h3>
<ul>
<li>Swift 6.0 concurrency model</li>
<li>SwiftUI with Observation framework</li>
<li>Basic App Intents integration</li>
</ul>
<h3 id="2-intermediate-week-3-4"><a class="header" href="#2-intermediate-week-3-4">2. Intermediate (Week 3-4)</a></h3>
<ul>
<li>SwiftData for persistence</li>
<li>Advanced SwiftUI patterns</li>
<li>Testing with Swift Testing</li>
</ul>
<h3 id="3-advanced-week-5-6"><a class="header" href="#3-advanced-week-5-6">3. Advanced (Week 5-6)</a></h3>
<ul>
<li>Performance optimization</li>
<li>Cross-platform development</li>
<li>App Store optimization</li>
</ul>
<h3 id="4-production-week-7-8"><a class="header" href="#4-production-week-7-8">4. Production (Week 7-8)</a></h3>
<ul>
<li>CI/CD with Xcode Cloud</li>
<li>Security best practices</li>
<li>Monitoring and analytics</li>
</ul>
<hr />
<p><em>Stay updated with Apple's official documentation and WWDC sessions for the latest developments.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-playgrounds-integration"><a class="header" href="#swift-playgrounds-integration">Swift Playgrounds Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apples-learning-path"><a class="header" href="#apples-learning-path">Apple's Learning Path</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-language-basics"><a class="header" href="#swift-language-basics">Swift Language Basics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections--control-flow"><a class="header" href="#collections--control-flow">Collections &amp; Control Flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions--closures"><a class="header" href="#functions--closures">Functions &amp; Closures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures--classes"><a class="header" href="#structures--classes">Structures &amp; Classes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols--generics"><a class="header" href="#protocols--generics">Protocols &amp; Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency--actors"><a class="header" href="#concurrency--actors">Concurrency &amp; Actors</a></h1>
<blockquote>
<p><strong>Stop data races. Write safe concurrent code.</strong></p>
</blockquote>
<h2 id="-the-problem-were-solving"><a class="header" href="#-the-problem-were-solving">üéØ The Problem We're Solving</a></h2>
<pre><code class="language-swift">// ‚ùå This crashes randomly
class DataManager {
    var items: [String] = []
    
    func addItem(_ item: String) {
        items.append(item) // CRASH: Data race!
    }
}

// Multiple threads calling addItem() = üí•
</code></pre>
<p><strong>The fix</strong>: Actors.</p>
<h2 id="-actors-your-new-best-friend"><a class="header" href="#-actors-your-new-best-friend">üöÄ Actors: Your New Best Friend</a></h2>
<pre><code class="language-swift">// ‚úÖ This is safe
actor DataManager {
    private var items: [String] = []
    
    func addItem(_ item: String) {
        items.append(item) // Safe! Actor protects this
    }
    
    func getItems() -&gt; [String] {
        items
    }
}

// Usage
let manager = DataManager()
await manager.addItem("Hello") // Note the 'await'
let items = await manager.getItems()
</code></pre>
<p><strong>What just happened</strong>:</p>
<ul>
<li>Actor ensures only ONE task accesses <code>items</code> at a time</li>
<li><code>await</code> means "this might wait for other tasks to finish"</li>
<li>No crashes, no data races, no locks needed</li>
</ul>
<h2 id="-real-example-image-downloader"><a class="header" href="#-real-example-image-downloader">üì± Real Example: Image Downloader</a></h2>
<pre><code class="language-swift">actor ImageCache {
    private var cache: [URL: UIImage] = [:]
    private var inProgress: [URL: Task&lt;UIImage, Error&gt;] = [:]
    
    func image(for url: URL) async throws -&gt; UIImage {
        // Check cache first
        if let cached = cache[url] {
            return cached
        }
        
        // Check if already downloading
        if let task = inProgress[url] {
            return try await task.value
        }
        
        // Start new download
        let task = Task {
            let (data, _) = try await URLSession.shared.data(from: url)
            guard let image = UIImage(data: data) else {
                throw ImageError.invalidData
            }
            return image
        }
        
        inProgress[url] = task
        
        do {
            let image = try await task.value
            cache[url] = image
            inProgress[url] = nil
            return image
        } catch {
            inProgress[url] = nil
            throw error
        }
    }
}

enum ImageError: Error {
    case invalidData
}

// Usage in SwiftUI
struct ImageView: View {
    let url: URL
    @State private var image: UIImage?
    let cache = ImageCache()
    
    var body: some View {
        Group {
            if let image {
                Image(uiImage: image)
                    .resizable()
            } else {
                ProgressView()
            }
        }
        .task {
            image = try? await cache.image(for: url)
        }
    }
}
</code></pre>
<p><strong>Why this is powerful</strong>:</p>
<ul>
<li>No duplicate downloads (checks <code>inProgress</code>)</li>
<li>Thread-safe caching</li>
<li>Automatic cleanup</li>
<li>Simple to use</li>
</ul>
<h2 id="-asyncawait-basics"><a class="header" href="#-asyncawait-basics">üîÑ async/await Basics</a></h2>
<h3 id="before-callback-hell"><a class="header" href="#before-callback-hell">Before (Callback Hell)</a></h3>
<pre><code class="language-swift">// ‚ùå Pyramid of doom
func loadUserData(completion: @escaping (User?) -&gt; Void) {
    fetchUserID { userID in
        guard let userID else {
            completion(nil)
            return
        }
        
        fetchUserProfile(userID) { profile in
            guard let profile else {
                completion(nil)
                return
            }
            
            fetchUserPosts(userID) { posts in
                let user = User(profile: profile, posts: posts)
                completion(user)
            }
        }
    }
}
</code></pre>
<h3 id="after-clean"><a class="header" href="#after-clean">After (Clean)</a></h3>
<pre><code class="language-swift">// ‚úÖ Linear and readable
func loadUserData() async throws -&gt; User {
    let userID = try await fetchUserID()
    let profile = try await fetchUserProfile(userID)
    let posts = try await fetchUserPosts(userID)
    
    return User(profile: profile, posts: posts)
}
</code></pre>
<p><strong>Difference</strong>: Code reads top-to-bottom. No nesting. Errors propagate naturally.</p>
<h2 id="-parallel-execution"><a class="header" href="#-parallel-execution">‚ö° Parallel Execution</a></h2>
<h3 id="sequential-slow"><a class="header" href="#sequential-slow">Sequential (Slow)</a></h3>
<pre><code class="language-swift">// Takes 6 seconds total
func loadData() async throws -&gt; (User, Posts, Comments) {
    let user = try await fetchUser() // 2 seconds
    let posts = try await fetchPosts() // 2 seconds
    let comments = try await fetchComments() // 2 seconds
    
    return (user, posts, comments)
}
</code></pre>
<h3 id="parallel-fast"><a class="header" href="#parallel-fast">Parallel (Fast)</a></h3>
<pre><code class="language-swift">// Takes 2 seconds total (all at once!)
func loadData() async throws -&gt; (User, Posts, Comments) {
    async let user = fetchUser()
    async let posts = fetchPosts()
    async let comments = fetchComments()
    
    return try await (user, posts, comments)
}
</code></pre>
<p><strong>Key</strong>: <code>async let</code> starts tasks immediately. <code>await</code> waits for all to finish.</p>
<h2 id="-task-groups-for-dynamic-work"><a class="header" href="#-task-groups-for-dynamic-work">üéØ Task Groups for Dynamic Work</a></h2>
<pre><code class="language-swift">func downloadImages(urls: [URL]) async throws -&gt; [UIImage] {
    try await withThrowingTaskGroup(of: UIImage.self) { group in
        // Start all downloads
        for url in urls {
            group.addTask {
                let (data, _) = try await URLSession.shared.data(from: url)
                guard let image = UIImage(data: data) else {
                    throw ImageError.invalidData
                }
                return image
            }
        }
        
        // Collect results
        var images: [UIImage] = []
        for try await image in group {
            images.append(image)
        }
        return images
    }
}

// Download 100 images in parallel!
let images = try await downloadImages(urls: imageURLs)
</code></pre>
<p><strong>Use case</strong>: When you don't know how many tasks you need upfront.</p>
<h2 id="-mainactor-for-ui-updates"><a class="header" href="#-mainactor-for-ui-updates">üîí @MainActor for UI Updates</a></h2>
<pre><code class="language-swift">@MainActor
class ViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    func loadItems() async {
        isLoading = true
        
        // This runs on background
        let fetchedItems = await fetchItemsFromAPI()
        
        // This automatically runs on main thread
        items = fetchedItems
        isLoading = false
    }
}

// Usage
struct ContentView: View {
    @StateObject private var viewModel = ViewModel()
    
    var body: some View {
        List(viewModel.items) { item in
            Text(item.name)
        }
        .task {
            await viewModel.loadItems()
        }
    }
}
</code></pre>
<p><strong>Magic</strong>: <code>@MainActor</code> ensures ALL property updates happen on main thread. No more crashes!</p>
<h2 id="-real-pattern-network-manager"><a class="header" href="#-real-pattern-network-manager">üé® Real Pattern: Network Manager</a></h2>
<pre><code class="language-swift">actor NetworkManager {
    static let shared = NetworkManager()
    
    private var session: URLSession
    
    init() {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30
        session = URLSession(configuration: config)
    }
    
    func fetch&lt;T: Decodable&gt;(_ type: T.Type, from url: URL) async throws -&gt; T {
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    func post&lt;T: Encodable, R: Decodable&gt;(
        _ data: T,
        to url: URL,
        expecting: R.Type
    ) async throws -&gt; R {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(data)
        
        let (responseData, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(R.self, from: responseData)
    }
}

enum NetworkError: Error {
    case invalidResponse
}

// Usage
struct User: Codable {
    let id: Int
    let name: String
}

let user = try await NetworkManager.shared.fetch(User.self, from: userURL)
</code></pre>
<p><strong>Why actor</strong>: Multiple views can call this safely. No race conditions.</p>
<h2 id="-common-mistakes"><a class="header" href="#-common-mistakes">üö® Common Mistakes</a></h2>
<h3 id="1-forgetting-await"><a class="header" href="#1-forgetting-await">1. Forgetting await</a></h3>
<pre><code class="language-swift">actor Counter {
    var count = 0
    
    func increment() {
        count += 1
    }
}

let counter = Counter()
counter.increment() // ‚ùå Error: Call to actor method must be 'await'
await counter.increment() // ‚úÖ Correct
</code></pre>
<h3 id="2-blocking-the-main-thread"><a class="header" href="#2-blocking-the-main-thread">2. Blocking the Main Thread</a></h3>
<pre><code class="language-swift">// ‚ùå Bad: Blocks UI
func loadData() {
    Task {
        let data = await fetchData()
        // Process data...
    }
}

// ‚úÖ Good: Non-blocking
func loadData() async {
    let data = await fetchData()
    // Process data...
}
</code></pre>
<h3 id="3-not-using-task-for-fire-and-forget"><a class="header" href="#3-not-using-task-for-fire-and-forget">3. Not Using Task for Fire-and-Forget</a></h3>
<pre><code class="language-swift">// ‚ùå Bad: Doesn't actually run
func saveData() {
    async {
        await database.save(data)
    }
}

// ‚úÖ Good: Runs in background
func saveData() {
    Task {
        await database.save(data)
    }
}
</code></pre>
<h2 id="-practical-exercise"><a class="header" href="#-practical-exercise">üéØ Practical Exercise</a></h2>
<p>Build a weather app that:</p>
<ol>
<li>Fetches weather for multiple cities in parallel</li>
<li>Caches results</li>
<li>Updates UI safely</li>
</ol>
<pre><code class="language-swift">actor WeatherCache {
    private var cache: [String: Weather] = [:]
    
    func weather(for city: String) async throws -&gt; Weather {
        if let cached = cache[city] {
            return cached
        }
        
        let weather = try await fetchWeather(for: city)
        cache[city] = weather
        return weather
    }
    
    private func fetchWeather(for city: String) async throws -&gt; Weather {
        let url = URL(string: "https://api.weather.com/\(city)")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode(Weather.self, from: data)
    }
}

@MainActor
class WeatherViewModel: ObservableObject {
    @Published var weatherData: [String: Weather] = [:]
    private let cache = WeatherCache()
    
    func loadWeather(for cities: [String]) async {
        await withTaskGroup(of: (String, Weather?).self) { group in
            for city in cities {
                group.addTask {
                    let weather = try? await self.cache.weather(for: city)
                    return (city, weather)
                }
            }
            
            for await (city, weather) in group {
                if let weather {
                    weatherData[city] = weather
                }
            }
        }
    }
}

struct Weather: Codable {
    let temperature: Double
    let condition: String
}
</code></pre>
<p><strong>Try it</strong>: Add error handling, retry logic, and offline support.</p>
<h2 id="-performance-tips"><a class="header" href="#-performance-tips">üìä Performance Tips</a></h2>
<ol>
<li><strong>Use actors for shared state</strong> (not locks)</li>
<li><strong>Batch UI updates</strong> (don't update 100 times/second)</li>
<li><strong>Cancel tasks</strong> when views disappear</li>
<li><strong>Use async let</strong> for independent work</li>
<li><strong>Profile with Instruments</strong> (Time Profiler)</li>
</ol>
<h2 id="-next-steps-1"><a class="header" href="#-next-steps-1">üîó Next Steps</a></h2>
<ul>
<li><a href="swift/./macros.html">Macros ‚Üí</a> - Generate code at compile time</li>
<li><a href="swift/./memory.html">Memory Management ‚Üí</a> - Understand ownership</li>
</ul>
<hr />
<p><strong>Key takeaway</strong>: Actors + async/await = safe, fast, readable concurrent code. Use them everywhere.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-ios-app"><a class="header" href="#your-first-ios-app">Your First iOS App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui-essentials"><a class="header" href="#swiftui-essentials">SwiftUI Essentials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation--user-input"><a class="header" href="#navigation--user-input">Navigation &amp; User Input</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-data"><a class="header" href="#working-with-data">Working with Data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking--apis"><a class="header" href="#networking--apis">Networking &amp; APIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-intelligence-integration"><a class="header" href="#apple-intelligence-integration">Apple Intelligence Integration</a></h1>
<blockquote>
<p>Integrate Apple's AI capabilities using real frameworks available in iOS 18+</p>
</blockquote>
<h2 id="-what-is-apple-intelligence"><a class="header" href="#-what-is-apple-intelligence">üß† What is Apple Intelligence?</a></h2>
<p>Apple Intelligence is Apple's personal intelligence system that:</p>
<ul>
<li>Uses on-device processing for privacy</li>
<li>Integrates with Siri and system apps</li>
<li>Provides writing tools and smart replies</li>
<li>Works across iPhone, iPad, and Mac</li>
</ul>
<h2 id="-real-implementation-with-available-apis"><a class="header" href="#-real-implementation-with-available-apis">üîß Real Implementation with Available APIs</a></h2>
<h3 id="1-natural-language-processing"><a class="header" href="#1-natural-language-processing">1. Natural Language Processing</a></h3>
<p>Use the actual NaturalLanguage framework:</p>
<pre><code class="language-swift">import NaturalLanguage

class TextAnalyzer {
    func analyzeText(_ text: String) -&gt; TextAnalysis {
        let tagger = NLTagger(tagSchemes: [.sentimentScore, .language, .nameType])
        tagger.string = text
        
        // Get sentiment
        let sentiment = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)
        
        // Get language
        let language = tagger.dominantLanguage
        
        // Extract named entities
        let entities = extractEntities(from: text)
        
        return TextAnalysis(
            sentiment: sentiment?.rawValue,
            language: language?.rawValue,
            entities: entities
        )
    }
    
    private func extractEntities(from text: String) -&gt; [String] {
        let tagger = NLTagger(tagSchemes: [.nameType])
        tagger.string = text
        
        var entities: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .nameType) { tag, tokenRange in
            if let tag = tag {
                let entity = String(text[tokenRange])
                entities.append(entity)
            }
            return true
        }
        return entities
    }
}

struct TextAnalysis {
    let sentiment: String?
    let language: String?
    let entities: [String]
}
</code></pre>
<h3 id="2-app-intents-integration"><a class="header" href="#2-app-intents-integration">2. App Intents Integration</a></h3>
<p>Create Siri shortcuts that work with Apple Intelligence:</p>
<pre><code class="language-swift">import AppIntents

struct SummarizeTextIntent: AppIntent {
    static var title: LocalizedStringResource = "Summarize Text"
    static var description = IntentDescription("Summarize the provided text")
    
    @Parameter(title: "Text to Summarize")
    var inputText: String
    
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        // Use actual text processing
        let summary = await createSummary(from: inputText)
        
        return .result(
            value: summary,
            dialog: "Here's your summary"
        )
    }
    
    private func createSummary(from text: String) async -&gt; String {
        // Simple extractive summarization using NaturalLanguage
        let sentences = text.components(separatedBy: ". ")
        let keyPhrases = extractKeyPhrases(from: text)
        
        // Return sentences containing key phrases
        let importantSentences = sentences.filter { sentence in
            keyPhrases.contains { sentence.localizedCaseInsensitiveContains($0) }
        }
        
        return importantSentences.prefix(3).joined(separator: ". ")
    }
    
    private func extractKeyPhrases(from text: String) -&gt; [String] {
        let tagger = NLTagger(tagSchemes: [.lemma])
        tagger.string = text
        
        var phrases: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lemma) { tag, tokenRange in
            if let lemma = tag?.rawValue, lemma.count &gt; 4 {
                phrases.append(lemma)
            }
            return true
        }
        return Array(Set(phrases)).prefix(5).map { String($0) }
    }
}
</code></pre>
<h3 id="3-core-ml-integration"><a class="header" href="#3-core-ml-integration">3. Core ML Integration</a></h3>
<p>Use real Core ML for on-device intelligence:</p>
<pre><code class="language-swift">import CoreML
import Vision

class ImageAnalyzer {
    private var model: VNCoreMLModel?
    
    init() {
        setupModel()
    }
    
    private func setupModel() {
        guard let modelURL = Bundle.main.url(forResource: "MobileNetV2", withExtension: "mlmodelc"),
              let model = try? VNCoreMLModel(for: MLModel(contentsOf: modelURL)) else {
            print("Failed to load Core ML model")
            return
        }
        self.model = model
    }
    
    func analyzeImage(_ image: UIImage) async throws -&gt; [ImageClassification] {
        guard let model = model,
              let cgImage = image.cgImage else {
            throw AnalysisError.modelNotAvailable
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            let request = VNCoreMLRequest(model: model) { request, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                guard let results = request.results as? [VNClassificationObservation] else {
                    continuation.resume(returning: [])
                    return
                }
                
                let classifications = results.prefix(5).map { observation in
                    ImageClassification(
                        label: observation.identifier,
                        confidence: observation.confidence
                    )
                }
                
                continuation.resume(returning: classifications)
            }
            
            let handler = VNImageRequestHandler(cgImage: cgImage)
            try? handler.perform([request])
        }
    }
}

struct ImageClassification {
    let label: String
    let confidence: Float
}

enum AnalysisError: Error {
    case modelNotAvailable
}
</code></pre>
<h2 id="-swiftui-integration"><a class="header" href="#-swiftui-integration">üì± SwiftUI Integration</a></h2>
<h3 id="smart-text-input-with-real-apis"><a class="header" href="#smart-text-input-with-real-apis">Smart Text Input with Real APIs</a></h3>
<pre><code class="language-swift">import SwiftUI
import NaturalLanguage

struct SmartTextEditor: View {
    @State private var text = ""
    @State private var suggestions: [String] = []
    @State private var language: String = "Unknown"
    
    var body: some View {
        VStack {
            TextEditor(text: $text)
                .onChange(of: text) { newValue in
                    analyzeText(newValue)
                }
                .frame(minHeight: 200)
            
            HStack {
                Text("Language: \(language)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
            }
            
            if !suggestions.isEmpty {
                VStack(alignment: .leading) {
                    Text("Suggestions:")
                        .font(.headline)
                    
                    ForEach(suggestions, id: \.self) { suggestion in
                        Button(suggestion) {
                            text += " " + suggestion
                        }
                        .buttonStyle(.bordered)
                    }
                }
            }
        }
        .padding()
    }
    
    private func analyzeText(_ text: String) {
        guard !text.isEmpty else { return }
        
        // Detect language
        let recognizer = NLLanguageRecognizer()
        recognizer.processString(text)
        if let detectedLanguage = recognizer.dominantLanguage {
            language = Locale.current.localizedString(forLanguageCode: detectedLanguage.rawValue) ?? detectedLanguage.rawValue
        }
        
        // Generate simple suggestions based on text analysis
        generateSuggestions(for: text)
    }
    
    private func generateSuggestions(for text: String) {
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        var nouns: [String] = []
        tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lexicalClass) { tag, tokenRange in
            if tag == .noun {
                let noun = String(text[tokenRange])
                nouns.append(noun)
            }
            return true
        }
        
        // Simple suggestion logic
        suggestions = Array(Set(nouns)).prefix(3).map { "related to \($0)" }
    }
}
</code></pre>
<h2 id="-real-world-applications"><a class="header" href="#-real-world-applications">üéØ Real-World Applications</a></h2>
<h3 id="1-smart-note-taking-app"><a class="header" href="#1-smart-note-taking-app">1. Smart Note Taking App</a></h3>
<pre><code class="language-swift">import SwiftUI
import NaturalLanguage

struct SmartNotesApp: View {
    @State private var notes: [Note] = []
    @State private var searchText = ""
    
    var filteredNotes: [Note] {
        if searchText.isEmpty {
            return notes
        }
        return notes.filter { note in
            note.content.localizedCaseInsensitiveContains(searchText) ||
            note.tags.contains { $0.localizedCaseInsensitiveContains(searchText) }
        }
    }
    
    var body: some View {
        NavigationView {
            List {
                ForEach(filteredNotes) { note in
                    NoteRow(note: note)
                }
            }
            .searchable(text: $searchText)
            .navigationTitle("Smart Notes")
            .toolbar {
                Button("Add Note") {
                    addNewNote()
                }
            }
        }
    }
    
    private func addNewNote() {
        let newNote = Note(content: "New note", tags: [])
        notes.append(newNote)
    }
}

struct Note: Identifiable {
    let id = UUID()
    var content: String
    var tags: [String]
    let createdAt = Date()
    
    init(content: String, tags: [String] = []) {
        self.content = content
        self.tags = tags.isEmpty ? generateTags(from: content) : tags
    }
}

func generateTags(from content: String) -&gt; [String] {
    let tagger = NLTagger(tagSchemes: [.nameType, .lexicalClass])
    tagger.string = content
    
    var tags: [String] = []
    
    // Extract named entities as tags
    tagger.enumerateTags(in: content.startIndex..&lt;content.endIndex, unit: .word, scheme: .nameType) { tag, tokenRange in
        if let tag = tag, tag != .other {
            let entity = String(content[tokenRange])
            tags.append(entity.lowercased())
        }
        return true
    }
    
    return Array(Set(tags)).prefix(5).map { String($0) }
}

struct NoteRow: View {
    let note: Note
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(note.content)
                .lineLimit(2)
            
            HStack {
                ForEach(note.tags.prefix(3), id: \.self) { tag in
                    Text(tag)
                        .font(.caption)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.blue.opacity(0.2))
                        .cornerRadius(4)
                }
                
                Spacer()
                
                Text(note.createdAt, style: .date)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 2)
    }
}
</code></pre>
<h2 id="-privacy-best-practices"><a class="header" href="#-privacy-best-practices">üîí Privacy Best Practices</a></h2>
<h3 id="on-device-processing"><a class="header" href="#on-device-processing">On-Device Processing</a></h3>
<pre><code class="language-swift">class PrivacyFirstProcessor {
    func processText(_ text: String) -&gt; ProcessedResult {
        // All processing happens locally
        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text
        
        let sentiment = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)
        
        return ProcessedResult(
            sentiment: sentiment?.rawValue ?? "neutral",
            processedLocally: true
        )
    }
}

struct ProcessedResult {
    let sentiment: String
    let processedLocally: Bool
}
</code></pre>
<h2 id="-resources"><a class="header" href="#-resources">üìö Resources</a></h2>
<ul>
<li><strong><a href="https://developer.apple.com/documentation/naturallanguage">Natural Language Framework</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/coreml">Core ML Documentation</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/appintents">App Intents Framework</a></strong></li>
<li><strong><a href="https://developer.apple.com/documentation/vision">Vision Framework</a></strong></li>
</ul>
<hr />
<p><em>This implementation uses real Apple frameworks available today, not fictional APIs.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-ml-8-features"><a class="header" href="#core-ml-8-features">Core ML 8 Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-device-processing-1"><a class="header" href="#on-device-processing-1">On-Device Processing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="siri-app-intents"><a class="header" href="#siri-app-intents">Siri App Intents</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftdata"><a class="header" href="#swiftdata">SwiftData</a></h1>
<blockquote>
<p><strong>Build a notes app with persistence in 10 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">üéØ What You'll Build</a></h2>
<p>A fully functional notes app with:</p>
<ul>
<li>‚úÖ Create, read, update, delete</li>
<li>‚úÖ Automatic persistence</li>
<li>‚úÖ Search</li>
<li>‚úÖ Sorting</li>
<li>‚úÖ Relationships</li>
</ul>
<p><strong>Zero SQL. Zero boilerplate.</strong></p>
<h2 id="-step-1-define-your-model-2-min"><a class="header" href="#-step-1-define-your-model-2-min">üöÄ Step 1: Define Your Model (2 min)</a></h2>
<pre><code class="language-swift">import SwiftData
import Foundation

@Model
final class Note {
    var title: String
    var content: String
    var createdAt: Date
    var isFavorite: Bool
    
    init(title: String, content: String = "") {
        self.title = title
        self.content = content
        self.createdAt = Date()
        self.isFavorite = false
    }
}
</code></pre>
<p><strong>That's it.</strong> SwiftData handles:</p>
<ul>
<li>Database schema</li>
<li>Migrations</li>
<li>Relationships</li>
<li>Queries</li>
</ul>
<h2 id="-step-2-setup-app-1-min"><a class="header" href="#-step-2-setup-app-1-min">üì± Step 2: Setup App (1 min)</a></h2>
<pre><code class="language-swift">import SwiftUI
import SwiftData

@main
struct NotesApp: App {
    var body: some Scene {
        WindowGroup {
            NotesListView()
        }
        .modelContainer(for: Note.self)
    }
}
</code></pre>
<p><strong>Done.</strong> Database is ready.</p>
<h2 id="-step-3-create-notes-3-min"><a class="header" href="#-step-3-create-notes-3-min">üìù Step 3: Create Notes (3 min)</a></h2>
<pre><code class="language-swift">struct NotesListView: View {
    @Environment(\.modelContext) private var context
    @Query(sort: \Note.createdAt, order: .reverse) private var notes: [Note]
    @State private var showingAddNote = false
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(notes) { note in
                    NavigationLink(value: note) {
                        NoteRow(note: note)
                    }
                }
                .onDelete(perform: deleteNotes)
            }
            .navigationTitle("Notes")
            .navigationDestination(for: Note.self) { note in
                NoteDetailView(note: note)
            }
            .toolbar {
                Button {
                    showingAddNote = true
                } label: {
                    Image(systemName: "plus")
                }
            }
            .sheet(isPresented: $showingAddNote) {
                AddNoteView()
            }
        }
    }
    
    private func deleteNotes(at offsets: IndexSet) {
        for index in offsets {
            context.delete(notes[index])
        }
    }
}

struct NoteRow: View {
    let note: Note
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(note.title)
                    .font(.headline)
                
                if note.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundStyle(.yellow)
                }
            }
            
            Text(note.content)
                .font(.subheadline)
                .foregroundStyle(.secondary)
                .lineLimit(2)
            
            Text(note.createdAt, style: .relative)
                .font(.caption)
                .foregroundStyle(.tertiary)
        }
    }
}
</code></pre>
<p><strong>Key points</strong>:</p>
<ul>
<li><code>@Query</code> automatically fetches and updates</li>
<li><code>@Environment(\.modelContext)</code> for CRUD operations</li>
<li>Changes save automatically</li>
</ul>
<h2 id="-step-4-edit-notes-2-min"><a class="header" href="#-step-4-edit-notes-2-min">‚úèÔ∏è Step 4: Edit Notes (2 min)</a></h2>
<pre><code class="language-swift">struct NoteDetailView: View {
    @Bindable var note: Note
    
    var body: some View {
        Form {
            TextField("Title", text: $note.title)
            
            TextEditor(text: $note.content)
                .frame(minHeight: 200)
            
            Toggle("Favorite", isOn: $note.isFavorite)
        }
        .navigationTitle("Edit Note")
    }
}
</code></pre>
<p><strong>Magic</strong>: <code>@Bindable</code> + two-way binding = auto-save!</p>
<h2 id="-step-5-add-notes-2-min"><a class="header" href="#-step-5-add-notes-2-min">‚ûï Step 5: Add Notes (2 min)</a></h2>
<pre><code class="language-swift">struct AddNoteView: View {
    @Environment(\.modelContext) private var context
    @Environment(\.dismiss) private var dismiss
    
    @State private var title = ""
    @State private var content = ""
    
    var body: some View {
        NavigationStack {
            Form {
                TextField("Title", text: $title)
                TextEditor(text: $content)
                    .frame(minHeight: 200)
            }
            .navigationTitle("New Note")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        saveNote()
                    }
                    .disabled(title.isEmpty)
                }
            }
        }
    }
    
    private func saveNote() {
        let note = Note(title: title, content: content)
        context.insert(note)
        dismiss()
    }
}
</code></pre>
<h2 id="-advanced-queries"><a class="header" href="#-advanced-queries">üîç Advanced Queries</a></h2>
<h3 id="filter-by-favorite"><a class="header" href="#filter-by-favorite">Filter by Favorite</a></h3>
<pre><code class="language-swift">@Query(
    filter: #Predicate&lt;Note&gt; { $0.isFavorite },
    sort: \Note.createdAt,
    order: .reverse
) 
private var favoriteNotes: [Note]
</code></pre>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<pre><code class="language-swift">struct SearchableNotesView: View {
    @Query private var notes: [Note]
    @State private var searchText = ""
    
    var filteredNotes: [Note] {
        if searchText.isEmpty {
            return notes
        }
        return notes.filter { note in
            note.title.localizedCaseInsensitiveContains(searchText) ||
            note.content.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    var body: some View {
        List(filteredNotes) { note in
            NoteRow(note: note)
        }
        .searchable(text: $searchText)
    }
}
</code></pre>
<h3 id="dynamic-sorting"><a class="header" href="#dynamic-sorting">Dynamic Sorting</a></h3>
<pre><code class="language-swift">struct SortableNotesView: View {
    @State private var sortOrder = SortOrder.date
    
    var body: some View {
        NotesListContent(sortOrder: sortOrder)
            .toolbar {
                Menu {
                    Picker("Sort", selection: $sortOrder) {
                        Text("Date").tag(SortOrder.date)
                        Text("Title").tag(SortOrder.title)
                        Text("Favorites").tag(SortOrder.favorite)
                    }
                } label: {
                    Image(systemName: "arrow.up.arrow.down")
                }
            }
    }
}

enum SortOrder {
    case date, title, favorite
}

struct NotesListContent: View {
    let sortOrder: SortOrder
    
    @Query private var notes: [Note]
    
    init(sortOrder: SortOrder) {
        self.sortOrder = sortOrder
        
        switch sortOrder {
        case .date:
            _notes = Query(sort: \Note.createdAt, order: .reverse)
        case .title:
            _notes = Query(sort: \Note.title)
        case .favorite:
            _notes = Query(sort: \Note.isFavorite, order: .reverse)
        }
    }
    
    var body: some View {
        List(notes) { note in
            NoteRow(note: note)
        }
    }
}
</code></pre>
<h2 id="-relationships"><a class="header" href="#-relationships">üîó Relationships</a></h2>
<h3 id="one-to-many-folders--notes"><a class="header" href="#one-to-many-folders--notes">One-to-Many (Folders ‚Üí Notes)</a></h3>
<pre><code class="language-swift">@Model
final class Folder {
    var name: String
    @Relationship(deleteRule: .cascade) var notes: [Note] = []
    
    init(name: String) {
        self.name = name
    }
}

@Model
final class Note {
    var title: String
    var content: String
    var folder: Folder?
    
    init(title: String, content: String = "", folder: Folder? = nil) {
        self.title = title
        self.content = content
        self.folder = folder
    }
}

// Usage
let folder = Folder(name: "Work")
let note = Note(title: "Meeting notes", folder: folder)
context.insert(folder)
context.insert(note)
</code></pre>
<p><strong>Delete rule</strong>: When folder is deleted, all notes are deleted too.</p>
<h3 id="many-to-many-notes--tags"><a class="header" href="#many-to-many-notes--tags">Many-to-Many (Notes ‚Üî Tags)</a></h3>
<pre><code class="language-swift">@Model
final class Tag {
    var name: String
    var notes: [Note] = []
    
    init(name: String) {
        self.name = name
    }
}

@Model
final class Note {
    var title: String
    var tags: [Tag] = []
    
    init(title: String) {
        self.title = title
    }
}

// Usage
let swift = Tag(name: "Swift")
let ios = Tag(name: "iOS")

let note = Note(title: "SwiftUI Tips")
note.tags = [swift, ios]

context.insert(note)
</code></pre>
<h2 id="-advanced-features"><a class="header" href="#-advanced-features">üéØ Advanced Features</a></h2>
<h3 id="computed-properties"><a class="header" href="#computed-properties">Computed Properties</a></h3>
<pre><code class="language-swift">@Model
final class Note {
    var title: String
    var content: String
    var createdAt: Date
    
    @Transient
    var wordCount: Int {
        content.split(separator: " ").count
    }
    
    @Transient
    var isLong: Bool {
        wordCount &gt; 500
    }
}
</code></pre>
<p><strong><code>@Transient</code></strong>: Not saved to database, computed on-the-fly.</p>
<h3 id="unique-constraints"><a class="header" href="#unique-constraints">Unique Constraints</a></h3>
<pre><code class="language-swift">@Model
final class User {
    @Attribute(.unique) var email: String
    var name: String
    
    init(email: String, name: String) {
        self.email = email
        self.name = name
    }
}
</code></pre>
<h3 id="custom-migrations"><a class="header" href="#custom-migrations">Custom Migrations</a></h3>
<pre><code class="language-swift">enum NotesSchemaV2: VersionedSchema {
    static var versionIdentifier = Schema.Version(2, 0, 0)
    
    static var models: [any PersistentModel.Type] {
        [Note.self, Folder.self]
    }
}

let migrationPlan = SchemaMigrationPlan(
    schemas: [NotesSchemaV1.self, NotesSchemaV2.self],
    stages: [
        MigrationStage.lightweight(fromVersion: NotesSchemaV1.self, toVersion: NotesSchemaV2.self)
    ]
)
</code></pre>
<h2 id="-performance-tips-1"><a class="header" href="#-performance-tips-1">üöÄ Performance Tips</a></h2>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<pre><code class="language-swift">func deleteAllNotes() {
    let descriptor = FetchDescriptor&lt;Note&gt;()
    let notes = try? context.fetch(descriptor)
    
    notes?.forEach { context.delete($0) }
    try? context.save()
}
</code></pre>
<h3 id="lazy-loading"><a class="header" href="#lazy-loading">Lazy Loading</a></h3>
<pre><code class="language-swift">@Model
final class Note {
    var title: String
    
    // Only load when accessed
    @Relationship(deleteRule: .cascade, minimumModelCount: 0)
    var attachments: [Attachment] = []
}
</code></pre>
<h3 id="indexing"><a class="header" href="#indexing">Indexing</a></h3>
<pre><code class="language-swift">@Model
final class Note {
    @Attribute(.indexed) var createdAt: Date
    var title: String
}
</code></pre>
<h2 id="-testing-with-swiftdata"><a class="header" href="#-testing-with-swiftdata">üß™ Testing with SwiftData</a></h2>
<pre><code class="language-swift">@Test
func testNoteCreation() throws {
    // Create in-memory container
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try ModelContainer(for: Note.self, configurations: config)
    let context = ModelContext(container)
    
    // Create note
    let note = Note(title: "Test")
    context.insert(note)
    
    // Fetch
    let descriptor = FetchDescriptor&lt;Note&gt;()
    let notes = try context.fetch(descriptor)
    
    #expect(notes.count == 1)
    #expect(notes[0].title == "Test")
}
</code></pre>
<h2 id="-common-patterns"><a class="header" href="#-common-patterns">üí° Common Patterns</a></h2>
<h3 id="undoredo"><a class="header" href="#undoredo">Undo/Redo</a></h3>
<pre><code class="language-swift">struct NoteDetailView: View {
    @Environment(\.modelContext) private var context
    @Bindable var note: Note
    
    var body: some View {
        Form {
            TextField("Title", text: $note.title)
        }
        .toolbar {
            Button("Undo") {
                context.undoManager?.undo()
            }
            .disabled(!(context.undoManager?.canUndo ?? false))
        }
    }
}
</code></pre>
<h3 id="batch-updates"><a class="header" href="#batch-updates">Batch Updates</a></h3>
<pre><code class="language-swift">func markAllAsRead() {
    let descriptor = FetchDescriptor&lt;Note&gt;(
        predicate: #Predicate { !$0.isRead }
    )
    
    let unreadNotes = try? context.fetch(descriptor)
    unreadNotes?.forEach { $0.isRead = true }
}
</code></pre>
<h3 id="export-data"><a class="header" href="#export-data">Export Data</a></h3>
<pre><code class="language-swift">func exportNotes() -&gt; Data? {
    let descriptor = FetchDescriptor&lt;Note&gt;()
    guard let notes = try? context.fetch(descriptor) else {
        return nil
    }
    
    let exportData = notes.map { note in
        [
            "title": note.title,
            "content": note.content,
            "createdAt": note.createdAt.ISO8601Format()
        ]
    }
    
    return try? JSONSerialization.data(withJSONObject: exportData)
}
</code></pre>
<h2 id="-real-app-example"><a class="header" href="#-real-app-example">üéØ Real App Example</a></h2>
<pre><code class="language-swift">// Complete notes app with folders
@main
struct NotesApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: [Note.self, Folder.self])
    }
}

struct ContentView: View {
    @Query private var folders: [Folder]
    @Environment(\.modelContext) private var context
    
    var body: some View {
        NavigationSplitView {
            // Sidebar
            List(folders) { folder in
                NavigationLink(value: folder) {
                    Label(folder.name, systemImage: "folder")
                }
            }
            .navigationTitle("Folders")
        } detail: { folder in
            // Notes list
            NotesListView(folder: folder)
        }
    }
}
</code></pre>
<h2 id="-resources-1"><a class="header" href="#-resources-1">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/swiftdata">SwiftData Documentation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10187/">WWDC23 - Meet SwiftData</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10154/">WWDC23 - Build an app with SwiftData</a></li>
</ul>
<h2 id="-next-steps-2"><a class="header" href="#-next-steps-2">üîó Next Steps</a></h2>
<ul>
<li><a href="frameworks/./swiftcharts.html">SwiftCharts ‚Üí</a> - Visualize your data</li>
<li><a href="frameworks/./cloudkit.html">CloudKit ‚Üí</a> - Sync across devices</li>
</ul>
<hr />
<p><strong>Bottom line</strong>: SwiftData = Core Data without the pain. Use it for everything.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloudkit"><a class="header" href="#cloudkit">Cloudkit</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-ml-machine-learning"><a class="header" href="#core-ml-machine-learning">Core ML (Machine Learning)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgetkit"><a class="header" href="#widgetkit">WidgetKit</a></h1>
<blockquote>
<p><strong>Build a weather widget in 20 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build-1"><a class="header" href="#-what-youll-build-1">üéØ What You'll Build</a></h2>
<p>A home screen widget that:</p>
<ul>
<li>‚úÖ Shows live data</li>
<li>‚úÖ Updates automatically</li>
<li>‚úÖ Multiple sizes</li>
<li>‚úÖ Interactive buttons</li>
<li>‚úÖ Deep links to app</li>
</ul>
<h2 id="-step-1-create-widget-extension"><a class="header" href="#-step-1-create-widget-extension">üöÄ Step 1: Create Widget Extension</a></h2>
<p>In Xcode: <strong>File ‚Üí New ‚Üí Target ‚Üí Widget Extension</strong></p>
<p>Name it: <code>WeatherWidget</code></p>
<h2 id="-step-2-basic-widget"><a class="header" href="#-step-2-basic-widget">üì± Step 2: Basic Widget</a></h2>
<pre><code class="language-swift">import WidgetKit
import SwiftUI

struct WeatherWidget: Widget {
    let kind: String = "WeatherWidget"
    
    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider()) { entry in
            WeatherWidgetView(entry: entry)
        }
        .configurationDisplayName("Weather")
        .description("Current weather conditions")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}

struct WeatherEntry: TimelineEntry {
    let date: Date
    let temperature: Int
    let condition: String
    let icon: String
}

struct Provider: TimelineProvider {
    func placeholder(in context: Context) -&gt; WeatherEntry {
        WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    }
    
    func getSnapshot(in context: Context, completion: @escaping (WeatherEntry) -&gt; Void) {
        let entry = WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
        completion(entry)
    }
    
    func getTimeline(in context: Context, completion: @escaping (Timeline&lt;WeatherEntry&gt;) -&gt; Void) {
        Task {
            let weather = try await fetchWeather()
            let entry = WeatherEntry(
                date: Date(),
                temperature: weather.temperature,
                condition: weather.condition,
                icon: weather.icon
            )
            
            // Update every 15 minutes
            let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: Date())!
            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
            completion(timeline)
        }
    }
    
    private func fetchWeather() async throws -&gt; Weather {
        // Fetch from API
        Weather(temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    }
}

struct WeatherWidgetView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Image(systemName: entry.icon)
                .font(.largeTitle)
            Text("\(entry.temperature)¬∞")
                .font(.title)
            Text(entry.condition)
                .font(.caption)
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct Weather {
    let temperature: Int
    let condition: String
    let icon: String
}
</code></pre>
<h2 id="-multiple-sizes"><a class="header" href="#-multiple-sizes">üé® Multiple Sizes</a></h2>
<pre><code class="language-swift">struct WeatherWidgetView: View {
    let entry: WeatherEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        switch family {
        case .systemSmall:
            SmallWeatherView(entry: entry)
        case .systemMedium:
            MediumWeatherView(entry: entry)
        case .systemLarge:
            LargeWeatherView(entry: entry)
        default:
            SmallWeatherView(entry: entry)
        }
    }
}

struct SmallWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: entry.icon)
                .font(.system(size: 40))
            Text("\(entry.temperature)¬∞")
                .font(.system(size: 36, weight: .bold))
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct MediumWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text("\(entry.temperature)¬∞")
                    .font(.system(size: 48, weight: .bold))
                Text(entry.condition)
                    .font(.title3)
            }
            
            Spacer()
            
            Image(systemName: entry.icon)
                .font(.system(size: 60))
        }
        .padding()
        .containerBackground(.blue.gradient, for: .widget)
    }
}

struct LargeWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack(spacing: 20) {
            HStack {
                Text("\(entry.temperature)¬∞")
                    .font(.system(size: 72, weight: .bold))
                Image(systemName: entry.icon)
                    .font(.system(size: 72))
            }
            
            Text(entry.condition)
                .font(.title)
            
            // Hourly forecast
            HStack {
                ForEach(0..&lt;5) { hour in
                    VStack {
                        Text("\(hour + 1)h")
                            .font(.caption)
                        Image(systemName: "cloud.fill")
                        Text("70¬∞")
                            .font(.caption)
                    }
                }
            }
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}
</code></pre>
<h2 id="-interactive-widgets"><a class="header" href="#-interactive-widgets">üîÑ Interactive Widgets</a></h2>
<pre><code class="language-swift">import AppIntents

struct RefreshWeatherIntent: AppIntent {
    static var title: LocalizedStringResource = "Refresh Weather"
    
    func perform() async throws -&gt; some IntentResult {
        // Trigger widget refresh
        WidgetCenter.shared.reloadAllTimelines()
        return .result()
    }
}

struct InteractiveWeatherView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Text("\(entry.temperature)¬∞")
                .font(.largeTitle)
            
            Button(intent: RefreshWeatherIntent()) {
                Label("Refresh", systemImage: "arrow.clockwise")
            }
            .buttonStyle(.bordered)
        }
        .containerBackground(.blue.gradient, for: .widget)
    }
}
</code></pre>
<h2 id="-deep-links"><a class="header" href="#-deep-links">üéØ Deep Links</a></h2>
<pre><code class="language-swift">struct WeatherWidgetView: View {
    let entry: WeatherEntry
    
    var body: some View {
        VStack {
            Text("\(entry.temperature)¬∞")
                .font(.largeTitle)
        }
        .containerBackground(.blue.gradient, for: .widget)
        .widgetURL(URL(string: "myapp://weather")!)
    }
}

// In main app
.onOpenURL { url in
    if url.scheme == "myapp", url.host == "weather" {
        // Navigate to weather screen
    }
}
</code></pre>
<h2 id="-app-intent-configuration"><a class="header" href="#-app-intent-configuration">üìä App Intent Configuration</a></h2>
<pre><code class="language-swift">struct WeatherWidget: Widget {
    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: "WeatherWidget",
            intent: WeatherConfigIntent.self,
            provider: Provider()
        ) { entry in
            WeatherWidgetView(entry: entry)
        }
    }
}

struct WeatherConfigIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "Weather Location"
    
    @Parameter(title: "City")
    var city: String?
}
</code></pre>
<h2 id="-lock-screen-widgets"><a class="header" href="#-lock-screen-widgets">üé® Lock Screen Widgets</a></h2>
<pre><code class="language-swift">struct LockScreenWidget: Widget {
    var body: some WidgetConfiguration {
        StaticConfiguration(kind: "LockScreen", provider: Provider()) { entry in
            LockScreenView(entry: entry)
        }
        .supportedFamilies([
            .accessoryCircular,
            .accessoryRectangular,
            .accessoryInline
        ])
    }
}

struct LockScreenView: View {
    let entry: WeatherEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        switch family {
        case .accessoryCircular:
            Gauge(value: Double(entry.temperature), in: 0...100) {
                Image(systemName: entry.icon)
            }
            
        case .accessoryRectangular:
            HStack {
                Image(systemName: entry.icon)
                VStack(alignment: .leading) {
                    Text("\(entry.temperature)¬∞")
                        .font(.headline)
                    Text(entry.condition)
                        .font(.caption)
                }
            }
            
        case .accessoryInline:
            Text("\(entry.temperature)¬∞ \(entry.condition)")
            
        default:
            EmptyView()
        }
    }
}
</code></pre>
<h2 id="-live-activities"><a class="header" href="#-live-activities">üîÑ Live Activities</a></h2>
<pre><code class="language-swift">import ActivityKit

struct WeatherActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var temperature: Int
        var condition: String
    }
    
    var city: String
}

// Start activity
func startWeatherActivity() throws {
    let attributes = WeatherActivityAttributes(city: "Detroit")
    let state = WeatherActivityAttributes.ContentState(
        temperature: 72,
        condition: "Sunny"
    )
    
    let activity = try Activity.request(
        attributes: attributes,
        content: .init(state: state, staleDate: nil)
    )
}

// Widget for Live Activity
struct WeatherActivityWidget: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: WeatherActivityAttributes.self) { context in
            // Lock screen UI
            HStack {
                Image(systemName: "sun.max.fill")
                VStack(alignment: .leading) {
                    Text("\(context.state.temperature)¬∞")
                    Text(context.state.condition)
                }
            }
        } dynamicIsland: { context in
            DynamicIsland {
                DynamicIslandExpandedRegion(.leading) {
                    Image(systemName: "sun.max.fill")
                }
                DynamicIslandExpandedRegion(.trailing) {
                    Text("\(context.state.temperature)¬∞")
                }
                DynamicIslandExpandedRegion(.bottom) {
                    Text(context.state.condition)
                }
            } compactLeading: {
                Image(systemName: "sun.max.fill")
            } compactTrailing: {
                Text("\(context.state.temperature)¬∞")
            } minimal: {
                Image(systemName: "sun.max.fill")
            }
        }
    }
}
</code></pre>
<h2 id="-shared-data"><a class="header" href="#-shared-data">üéØ Shared Data</a></h2>
<pre><code class="language-swift">// In app and widget
let sharedDefaults = UserDefaults(suiteName: "group.com.yourapp.weather")!

// Save in app
sharedDefaults.set(72, forKey: "temperature")

// Read in widget
let temperature = sharedDefaults.integer(forKey: "temperature")
</code></pre>
<h2 id="-timeline-strategies"><a class="header" href="#-timeline-strategies">üìä Timeline Strategies</a></h2>
<pre><code class="language-swift">// Update every hour
let timeline = Timeline(entries: [entry], policy: .after(Date().addingTimeInterval(3600)))

// Update at specific time
let midnight = Calendar.current.startOfDay(for: Date().addingTimeInterval(86400))
let timeline = Timeline(entries: [entry], policy: .after(midnight))

// Never update (static)
let timeline = Timeline(entries: [entry], policy: .never)

// Update ASAP
let timeline = Timeline(entries: [entry], policy: .atEnd)
</code></pre>
<h2 id="-best-practices"><a class="header" href="#-best-practices">üé® Best Practices</a></h2>
<h3 id="1-keep-it-simple"><a class="header" href="#1-keep-it-simple">1. Keep It Simple</a></h3>
<pre><code class="language-swift">// ‚úÖ Good: Clear at a glance
Text("\(temperature)¬∞")
    .font(.largeTitle)

// ‚ùå Bad: Too much info
VStack {
    Text("Temperature: \(temperature)¬∞F")
    Text("Feels like: \(feelsLike)¬∞F")
    Text("Humidity: \(humidity)%")
    Text("Wind: \(wind) mph")
}
</code></pre>
<h3 id="2-use-placeholders"><a class="header" href="#2-use-placeholders">2. Use Placeholders</a></h3>
<pre><code class="language-swift">func placeholder(in context: Context) -&gt; WeatherEntry {
    WeatherEntry(
        date: Date(),
        temperature: 72,
        condition: "Sunny",
        icon: "sun.max.fill"
    )
}
</code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<pre><code class="language-swift">func getTimeline(in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; Void) {
    Task {
        do {
            let weather = try await fetchWeather()
            let entry = WeatherEntry(from: weather)
            completion(Timeline(entries: [entry], policy: .after(Date().addingTimeInterval(900))))
        } catch {
            // Show cached data or placeholder
            let fallback = WeatherEntry(date: Date(), temperature: 72, condition: "Unavailable", icon: "exclamationmark.triangle")
            completion(Timeline(entries: [fallback], policy: .after(Date().addingTimeInterval(300))))
        }
    }
}
</code></pre>
<h2 id="-testing"><a class="header" href="#-testing">üöÄ Testing</a></h2>
<pre><code class="language-swift">// Preview
#Preview(as: .systemSmall) {
    WeatherWidget()
} timeline: {
    WeatherEntry(date: Date(), temperature: 72, condition: "Sunny", icon: "sun.max.fill")
    WeatherEntry(date: Date(), temperature: 68, condition: "Cloudy", icon: "cloud.fill")
}
</code></pre>
<h2 id="-performance-tips-2"><a class="header" href="#-performance-tips-2">üí° Performance Tips</a></h2>
<ol>
<li><strong>Limit network calls</strong> - Cache data</li>
<li><strong>Use App Groups</strong> - Share data efficiently</li>
<li><strong>Optimize images</strong> - Use SF Symbols when possible</li>
<li><strong>Keep timelines short</strong> - 5-10 entries max</li>
<li><strong>Test on device</strong> - Simulator doesn't show true performance</li>
</ol>
<h2 id="-resources-2"><a class="header" href="#-resources-2">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/widgetkit">WidgetKit Documentation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10028/">WWDC23 - Bring widgets to life</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/widgets">Human Interface Guidelines</a></li>
</ul>
<h2 id="-next-steps-3"><a class="header" href="#-next-steps-3">üîó Next Steps</a></h2>
<ul>
<li><a href="frameworks/./appintents.html">AppIntents ‚Üí</a></li>
<li><a href="frameworks/./swiftdata.html">SwiftData ‚Üí</a></li>
</ul>
<hr />
<p><strong>Try it</strong>: Add a widget to your app. Users love home screen widgets!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-intents"><a class="header" href="#app-intents">App Intents</a></h1>
<blockquote>
<p><strong>Add Siri and Shortcuts support in 15 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build-2"><a class="header" href="#-what-youll-build-2">üéØ What You'll Build</a></h2>
<p>An app that works with:</p>
<ul>
<li>‚úÖ Siri voice commands</li>
<li>‚úÖ Shortcuts app</li>
<li>‚úÖ Spotlight search</li>
<li>‚úÖ Control Center widgets</li>
</ul>
<h2 id="-your-first-intent-5-min"><a class="header" href="#-your-first-intent-5-min">üöÄ Your First Intent (5 min)</a></h2>
<pre><code class="language-swift">import AppIntents

struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    static var description = IntentDescription("Adds a new task to your list")
    
    @Parameter(title: "Task Title")
    var title: String
    
    @Parameter(title: "Priority", default: .medium)
    var priority: Priority
    
    @MainActor
    func perform() async throws -&gt; some IntentResult {
        // Add task to your app
        let task = Task(title: title, priority: priority)
        TaskManager.shared.add(task)
        
        return .result(dialog: "Added '\(title)' to your tasks")
    }
}

enum Priority: String, AppEnum {
    case low, medium, high
    
    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Priority")
    static var caseDisplayRepresentations: [Priority: DisplayRepresentation] = [
        .low: "Low",
        .medium: "Medium",
        .high: "High"
    ]
}
</code></pre>
<p><strong>That's it!</strong> Now users can say: <em>"Hey Siri, add task Buy milk in MyApp"</em></p>
<h2 id="-register-shortcuts"><a class="header" href="#-register-shortcuts">üì± Register Shortcuts</a></h2>
<pre><code class="language-swift">struct TaskAppShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: AddTaskIntent(),
            phrases: [
                "Add a task in \(.applicationName)",
                "Create task in \(.applicationName)",
                "New task in \(.applicationName)"
            ],
            shortTitle: "Add Task",
            systemImageName: "plus.circle"
        )
    }
}
</code></pre>
<h2 id="-complete-example-coffee-order"><a class="header" href="#-complete-example-coffee-order">üéØ Complete Example: Coffee Order</a></h2>
<pre><code class="language-swift">import AppIntents

// Coffee size enum
enum CoffeeSize: String, AppEnum {
    case small, medium, large
    
    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Size")
    static var caseDisplayRepresentations: [CoffeeSize: DisplayRepresentation] = [
        .small: DisplayRepresentation(title: "Small", subtitle: "8 oz"),
        .medium: DisplayRepresentation(title: "Medium", subtitle: "12 oz"),
        .large: DisplayRepresentation(title: "Large", subtitle: "16 oz")
    ]
}

// Order intent
struct OrderCoffeeIntent: AppIntent {
    static var title: LocalizedStringResource = "Order Coffee"
    static var description = IntentDescription("Order your favorite coffee")
    static var openAppWhenRun: Bool = false  // Runs in background
    
    @Parameter(title: "Coffee Type")
    var coffeeType: String
    
    @Parameter(title: "Size", default: .medium)
    var size: CoffeeSize
    
    @Parameter(title: "Add milk", default: false)
    var addMilk: Bool
    
    @MainActor
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        // Place order
        let order = CoffeeOrder(
            type: coffeeType,
            size: size,
            addMilk: addMilk
        )
        
        try await CoffeeService.shared.placeOrder(order)
        
        let response = "Your \(size.rawValue) \(coffeeType) is being prepared"
        return .result(dialog: IntentDialog(response))
    }
}

// Shortcuts
struct CoffeeShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: OrderCoffeeIntent(),
            phrases: [
                "Order coffee in \(.applicationName)",
                "Get me a coffee from \(.applicationName)",
                "I need coffee from \(.applicationName)"
            ],
            shortTitle: "Order Coffee",
            systemImageName: "cup.and.saucer.fill"
        )
    }
}
</code></pre>
<p><strong>Usage</strong>: <em>"Hey Siri, order coffee latte large with milk in CoffeeApp"</em></p>
<h2 id="-entity-queries"><a class="header" href="#-entity-queries">üé® Entity Queries</a></h2>
<pre><code class="language-swift">// Define entity
struct TaskEntity: AppEntity {
    var id: UUID
    var title: String
    var isCompleted: Bool
    
    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Task")
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(
            title: "\(title)",
            subtitle: isCompleted ? "Completed" : "Pending"
        )
    }
}

// Query provider
struct TaskQuery: EntityQuery {
    func entities(for identifiers: [UUID]) async throws -&gt; [TaskEntity] {
        TaskManager.shared.tasks.filter { identifiers.contains($0.id) }
    }
    
    func suggestedEntities() async throws -&gt; [TaskEntity] {
        Array(TaskManager.shared.tasks.prefix(5))
    }
}

// Use in intent
struct CompleteTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Complete Task"
    
    @Parameter(title: "Task")
    var task: TaskEntity
    
    func perform() async throws -&gt; some IntentResult {
        TaskManager.shared.complete(task.id)
        return .result(dialog: "Marked '\(task.title)' as complete")
    }
}
</code></pre>
<h2 id="-spotlight-integration"><a class="header" href="#-spotlight-integration">üîç Spotlight Integration</a></h2>
<pre><code class="language-swift">import CoreSpotlight

extension TaskEntity: IndexedEntity {
    var attributeSet: CSSearchableItemAttributeSet {
        let attributes = CSSearchableItemAttributeSet(contentType: .text)
        attributes.title = title
        attributes.contentDescription = isCompleted ? "Completed" : "Pending"
        return attributes
    }
}

// Index tasks
func indexTasks() {
    let items = TaskManager.shared.tasks.map { task in
        CSSearchableItem(
            uniqueIdentifier: task.id.uuidString,
            domainIdentifier: "tasks",
            attributeSet: task.attributeSet
        )
    }
    
    CSSearchableIndex.default().indexSearchableItems(items)
}
</code></pre>
<h2 id="-interactive-widgets-1"><a class="header" href="#-interactive-widgets-1">üéØ Interactive Widgets</a></h2>
<pre><code class="language-swift">import WidgetKit
import AppIntents

struct ToggleTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Toggle Task"
    
    @Parameter(title: "Task ID")
    var taskID: String
    
    func perform() async throws -&gt; some IntentResult {
        TaskManager.shared.toggle(UUID(uuidString: taskID)!)
        return .result()
    }
}

// In widget
struct TaskWidgetView: View {
    let task: Task
    
    var body: some View {
        HStack {
            Text(task.title)
            
            Spacer()
            
            Button(intent: ToggleTaskIntent(taskID: task.id.uuidString)) {
                Image(systemName: task.isCompleted ? "checkmark.circle.fill" : "circle")
            }
            .buttonStyle(.plain)
        }
    }
}
</code></pre>
<h2 id="-focus-filters"><a class="header" href="#-focus-filters">üé® Focus Filters</a></h2>
<pre><code class="language-swift">struct WorkFocusFilter: SetFocusFilterIntent {
    static var title: LocalizedStringResource = "Work Focus"
    
    @Parameter(title: "Show Work Tasks")
    var showWorkTasks: Bool
    
    func perform() async throws -&gt; some IntentResult {
        TaskManager.shared.filterByWork = showWorkTasks
        return .result()
    }
}
</code></pre>
<h2 id="-live-activities-1"><a class="header" href="#-live-activities-1">üöÄ Live Activities</a></h2>
<pre><code class="language-swift">struct TaskActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var completedCount: Int
        var totalCount: Int
    }
    
    var projectName: String
}

struct UpdateTaskProgressIntent: AppIntent {
    static var title: LocalizedStringResource = "Update Progress"
    
    func perform() async throws -&gt; some IntentResult {
        // Update Live Activity
        let activity = Activity&lt;TaskActivityAttributes&gt;.activities.first
        await activity?.update(
            .init(state: .init(completedCount: 5, totalCount: 10), staleDate: nil)
        )
        
        return .result()
    }
}
</code></pre>
<h2 id="-parameter-summaries"><a class="header" href="#-parameter-summaries">üéØ Parameter Summaries</a></h2>
<pre><code class="language-swift">struct SendMessageIntent: AppIntent {
    static var title: LocalizedStringResource = "Send Message"
    
    @Parameter(title: "Recipient")
    var recipient: String
    
    @Parameter(title: "Message")
    var message: String
    
    static var parameterSummary: some ParameterSummary {
        Summary("Send \(\.$message) to \(\.$recipient)")
    }
    
    func perform() async throws -&gt; some IntentResult {
        // Send message
        return .result(dialog: "Message sent to \(recipient)")
    }
}
</code></pre>
<h2 id="-custom-dialogs"><a class="header" href="#-custom-dialogs">üé® Custom Dialogs</a></h2>
<pre><code class="language-swift">struct BookFlightIntent: AppIntent {
    static var title: LocalizedStringResource = "Book Flight"
    
    @Parameter(title: "Destination")
    var destination: String
    
    @Parameter(title: "Date")
    var date: Date
    
    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {
        let flight = try await FlightService.search(to: destination, on: date)
        
        // Custom dialog with options
        let dialog = IntentDialog(
            "Found a flight to \(destination) for $\(flight.price). Book it?",
            options: ["Yes", "No", "Show alternatives"]
        )
        
        return .result(dialog: dialog)
    }
}
</code></pre>
<h2 id="-error-handling"><a class="header" href="#-error-handling">üéØ Error Handling</a></h2>
<pre><code class="language-swift">enum OrderError: Error, CustomLocalizedStringResourceConvertible {
    case outOfStock
    case invalidPayment
    
    var localizedStringResource: LocalizedStringResource {
        switch self {
        case .outOfStock:
            return "Sorry, that item is out of stock"
        case .invalidPayment:
            return "Payment method declined"
        }
    }
}

struct OrderIntent: AppIntent {
    func perform() async throws -&gt; some IntentResult {
        guard ItemService.isInStock(item) else {
            throw OrderError.outOfStock
        }
        
        // Process order
        return .result(dialog: "Order placed!")
    }
}
</code></pre>
<h2 id="-best-practices-1"><a class="header" href="#-best-practices-1">üí° Best Practices</a></h2>
<h3 id="1-clear-phrases"><a class="header" href="#1-clear-phrases">1. Clear Phrases</a></h3>
<pre><code class="language-swift">// ‚úÖ Good: Natural language
"Order coffee in MyApp"
"Get me a coffee from MyApp"

// ‚ùå Bad: Robotic
"Execute coffee order function"
</code></pre>
<h3 id="2-sensible-defaults"><a class="header" href="#2-sensible-defaults">2. Sensible Defaults</a></h3>
<pre><code class="language-swift">@Parameter(title: "Size", default: .medium)  // ‚úÖ
@Parameter(title: "Size")  // ‚ùå User must specify
</code></pre>
<h3 id="3-background-execution"><a class="header" href="#3-background-execution">3. Background Execution</a></h3>
<pre><code class="language-swift">// For quick actions
static var openAppWhenRun: Bool = false

// For complex UI
static var openAppWhenRun: Bool = true
</code></pre>
<h3 id="4-helpful-descriptions"><a class="header" href="#4-helpful-descriptions">4. Helpful Descriptions</a></h3>
<pre><code class="language-swift">static var description = IntentDescription(
    "Adds a new task to your list",
    categoryName: "Tasks",
    searchKeywords: ["todo", "reminder", "task"]
)
</code></pre>
<h2 id="-testing-1"><a class="header" href="#-testing-1">üéØ Testing</a></h2>
<h3 id="shortcuts-app"><a class="header" href="#shortcuts-app">Shortcuts App</a></h3>
<ol>
<li>Open Shortcuts app</li>
<li>Create new shortcut</li>
<li>Search for your app</li>
<li>Add your intent</li>
<li>Test with different parameters</li>
</ol>
<h3 id="siri"><a class="header" href="#siri">Siri</a></h3>
<pre><code>"Hey Siri, add task Buy milk in MyApp"
"Hey Siri, order coffee in CoffeeApp"
</code></pre>
<h3 id="xcode"><a class="header" href="#xcode">Xcode</a></h3>
<pre><code class="language-swift">// Test in code
let intent = AddTaskIntent()
intent.title = "Test Task"
intent.priority = .high

let result = try await intent.perform()
print(result)
</code></pre>
<h2 id="-resources-3"><a class="header" href="#-resources-3">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/appintents">App Intents Documentation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10032/">WWDC23 - Dive into App Intents</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/siri">Human Interface Guidelines</a></li>
</ul>
<h2 id="-next-steps-4"><a class="header" href="#-next-steps-4">üîó Next Steps</a></h2>
<ul>
<li><a href="frameworks/./widgetkit.html">WidgetKit ‚Üí</a></li>
<li><a href="frameworks/./swiftdata.html">SwiftData ‚Üí</a></li>
</ul>
<hr />
<p><strong>Pro tip</strong>: Start with 1-2 simple intents. Add more based on user feedback.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftcharts"><a class="header" href="#swiftcharts">Swiftcharts</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-testing-framework"><a class="header" href="#swift-testing-framework">Swift Testing Framework</a></h1>
<blockquote>
<p>Modern testing with Swift's new testing framework introduced in Xcode 16</p>
</blockquote>
<h2 id="-introduction"><a class="header" href="#-introduction">üß™ Introduction</a></h2>
<p>Swift Testing is Apple's modern testing framework that provides:</p>
<ul>
<li>Cleaner syntax with <code>@Test</code> macro</li>
<li>Better error messages and diagnostics</li>
<li>Parallel test execution</li>
<li>Improved Xcode integration</li>
</ul>
<h2 id="-basic-testing"><a class="header" href="#-basic-testing">üöÄ Basic Testing</a></h2>
<h3 id="simple-tests"><a class="header" href="#simple-tests">Simple Tests</a></h3>
<pre><code class="language-swift">import Testing

@Test func basicMath() {
    #expect(2 + 2 == 4)
    #expect(10 - 5 == 5)
}

@Test func stringOperations() {
    let text = "Hello, Swift!"
    #expect(text.contains("Swift"))
    #expect(text.count == 13)
}
</code></pre>
<h3 id="parameterized-tests"><a class="header" href="#parameterized-tests">Parameterized Tests</a></h3>
<pre><code class="language-swift">@Test(arguments: [
    (input: 0, expected: 1),
    (input: 1, expected: 1), 
    (input: 5, expected: 120)
])
func factorial(input: Int, expected: Int) {
    #expect(factorial(input) == expected)
}

func factorial(_ n: Int) -&gt; Int {
    guard n &gt; 1 else { return 1 }
    return n * factorial(n - 1)
}
</code></pre>
<h2 id="-advanced-features-1"><a class="header" href="#-advanced-features-1">üîß Advanced Features</a></h2>
<h3 id="async-testing"><a class="header" href="#async-testing">Async Testing</a></h3>
<pre><code class="language-swift">@Test func networkRequest() async throws {
    let url = URL(string: "https://httpbin.org/json")!
    let (data, response) = try await URLSession.shared.data(from: url)
    
    #expect(data.count &gt; 0)
    
    let httpResponse = try #require(response as? HTTPURLResponse)
    #expect(httpResponse.statusCode == 200)
}
</code></pre>
<h3 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h3>
<pre><code class="language-swift">enum ValidationError: Error {
    case invalidEmail
    case tooShort
}

func validateEmail(_ email: String) throws {
    guard email.contains("@") else {
        throw ValidationError.invalidEmail
    }
}

@Test func errorHandling() {
    #expect(throws: ValidationError.invalidEmail) {
        try validateEmail("invalid-email")
    }
    
    #expect(throws: Never.self) {
        try validateEmail("valid@example.com")
    }
}
</code></pre>
<h3 id="conditional-tests"><a class="header" href="#conditional-tests">Conditional Tests</a></h3>
<pre><code class="language-swift">@Test(.enabled(if: ProcessInfo.processInfo.environment["CI"] == nil))
func localOnlyTest() {
    // This test only runs locally, not in CI
    #expect(true)
}
</code></pre>
<h2 id="-swiftui-testing"><a class="header" href="#-swiftui-testing">üì± SwiftUI Testing</a></h2>
<h3 id="view-testing"><a class="header" href="#view-testing">View Testing</a></h3>
<pre><code class="language-swift">import Testing
import SwiftUI

struct ContentView: View {
    @State private var count = 0
    
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1
            }
        }
    }
}

@Test @MainActor 
func contentViewTest() {
    let view = ContentView()
    // Basic view creation test
    #expect(view.body != nil)
}
</code></pre>
<h3 id="model-testing"><a class="header" href="#model-testing">Model Testing</a></h3>
<pre><code class="language-swift">@Observable
class Counter {
    var value = 0
    
    func increment() {
        value += 1
    }
    
    func decrement() {
        value -= 1
    }
}

@Test func counterModel() {
    let counter = Counter()
    
    #expect(counter.value == 0)
    
    counter.increment()
    #expect(counter.value == 1)
    
    counter.decrement()
    #expect(counter.value == 0)
}
</code></pre>
<h2 id="-real-world-testing-patterns"><a class="header" href="#-real-world-testing-patterns">üéØ Real-World Testing Patterns</a></h2>
<h3 id="service-testing-with-mocks"><a class="header" href="#service-testing-with-mocks">Service Testing with Mocks</a></h3>
<pre><code class="language-swift">protocol NetworkService {
    func fetchUser(id: Int) async throws -&gt; User
}

struct User: Codable, Equatable {
    let id: Int
    let name: String
}

class MockNetworkService: NetworkService {
    var shouldFail = false
    
    func fetchUser(id: Int) async throws -&gt; User {
        if shouldFail {
            throw URLError(.notConnectedToInternet)
        }
        return User(id: id, name: "Test User")
    }
}

class UserRepository {
    private let networkService: NetworkService
    
    init(networkService: NetworkService) {
        self.networkService = networkService
    }
    
    func getUser(id: Int) async throws -&gt; User {
        return try await networkService.fetchUser(id: id)
    }
}

@Test func userRepositorySuccess() async throws {
    let mockService = MockNetworkService()
    let repository = UserRepository(networkService: mockService)
    
    let user = try await repository.getUser(id: 1)
    
    #expect(user.id == 1)
    #expect(user.name == "Test User")
}

@Test func userRepositoryFailure() async {
    let mockService = MockNetworkService()
    mockService.shouldFail = true
    let repository = UserRepository(networkService: mockService)
    
    await #expect(throws: URLError.self) {
        try await repository.getUser(id: 1)
    }
}
</code></pre>
<h3 id="core-data-testing"><a class="header" href="#core-data-testing">Core Data Testing</a></h3>
<pre><code class="language-swift">import CoreData

@Test func coreDataOperations() throws {
    // Create in-memory store for testing
    let container = NSPersistentContainer(name: "DataModel")
    let description = NSPersistentStoreDescription()
    description.type = NSInMemoryStoreType
    container.persistentStoreDescriptions = [description]
    
    container.loadPersistentStores { _, error in
        #expect(error == nil)
    }
    
    let context = container.viewContext
    
    // Create test entity (assuming you have a Person entity)
    let person = NSEntityDescription.insertNewObject(forEntityName: "Person", into: context)
    person.setValue("John Doe", forKey: "name")
    person.setValue(30, forKey: "age")
    
    try context.save()
    
    // Fetch and verify
    let request = NSFetchRequest&lt;NSManagedObject&gt;(entityName: "Person")
    let results = try context.fetch(request)
    
    #expect(results.count == 1)
    #expect(results.first?.value(forKey: "name") as? String == "John Doe")
}
</code></pre>
<h2 id="-test-organization"><a class="header" href="#-test-organization">üîç Test Organization</a></h2>
<h3 id="test-suites"><a class="header" href="#test-suites">Test Suites</a></h3>
<pre><code class="language-swift">@Suite("Authentication Tests")
struct AuthenticationTests {
    
    @Test func validLogin() async throws {
        let auth = AuthService()
        let result = try await auth.login(email: "test@example.com", password: "password123")
        #expect(result.isSuccess)
    }
    
    @Test func invalidCredentials() async {
        let auth = AuthService()
        await #expect(throws: AuthError.invalidCredentials) {
            try await auth.login(email: "test@example.com", password: "wrong")
        }
    }
}

class AuthService {
    func login(email: String, password: String) async throws -&gt; LoginResult {
        // Simulate authentication
        if email == "test@example.com" &amp;&amp; password == "password123" {
            return LoginResult(isSuccess: true, token: "abc123")
        } else {
            throw AuthError.invalidCredentials
        }
    }
}

struct LoginResult {
    let isSuccess: Bool
    let token: String?
}

enum AuthError: Error {
    case invalidCredentials
}
</code></pre>
<h3 id="setup-and-teardown"><a class="header" href="#setup-and-teardown">Setup and Teardown</a></h3>
<pre><code class="language-swift">@Suite("Database Tests") 
struct DatabaseTests {
    let database: TestDatabase
    
    init() throws {
        database = try TestDatabase()
    }
    
    @Test func insertRecord() throws {
        let record = TestRecord(id: 1, name: "Test")
        try database.insert(record)
        
        let retrieved = try database.fetch(id: 1)
        #expect(retrieved?.name == "Test")
    }
    
    @Test func deleteRecord() throws {
        let record = TestRecord(id: 2, name: "Delete Me")
        try database.insert(record)
        try database.delete(id: 2)
        
        let retrieved = try database.fetch(id: 2)
        #expect(retrieved == nil)
    }
}

class TestDatabase {
    private var records: [Int: TestRecord] = [:]
    
    func insert(_ record: TestRecord) throws {
        records[record.id] = record
    }
    
    func fetch(id: Int) throws -&gt; TestRecord? {
        return records[id]
    }
    
    func delete(id: Int) throws {
        records.removeValue(forKey: id)
    }
}

struct TestRecord: Equatable {
    let id: Int
    let name: String
}
</code></pre>
<h2 id="-performance-testing"><a class="header" href="#-performance-testing">üìä Performance Testing</a></h2>
<h3 id="timing-tests"><a class="header" href="#timing-tests">Timing Tests</a></h3>
<pre><code class="language-swift">@Test func performanceTest() {
    let startTime = CFAbsoluteTimeGetCurrent()
    
    // Perform operation
    let result = expensiveOperation()
    
    let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
    
    #expect(timeElapsed &lt; 1.0) // Should complete within 1 second
    #expect(result.count &gt; 0)
}

func expensiveOperation() -&gt; [Int] {
    return (0..&lt;100_000).map { $0 * 2 }
}
</code></pre>
<h2 id="-migration-from-xctest"><a class="header" href="#-migration-from-xctest">üõ† Migration from XCTest</a></h2>
<h3 id="assertion-mapping"><a class="header" href="#assertion-mapping">Assertion Mapping</a></h3>
<pre><code class="language-swift">// XCTest -&gt; Swift Testing
XCTAssertEqual(a, b)           // #expect(a == b)
XCTAssertTrue(condition)       // #expect(condition)
XCTAssertFalse(condition)      // #expect(!condition)
XCTAssertNil(value)           // #expect(value == nil)
XCTAssertNotNil(value)        // #expect(value != nil)
XCTAssertThrowsError(try f()) // #expect(throws: Error.self) { try f() }
</code></pre>
<h3 id="class-based-to-function-based"><a class="header" href="#class-based-to-function-based">Class-based to Function-based</a></h3>
<pre><code class="language-swift">// XCTest (old)
class MyTests: XCTestCase {
    func testExample() {
        XCTAssertEqual(2 + 2, 4)
    }
}

// Swift Testing (new)
@Test func example() {
    #expect(2 + 2 == 4)
}
</code></pre>
<h2 id="-best-practices-2"><a class="header" href="#-best-practices-2">üéì Best Practices</a></h2>
<h3 id="1-descriptive-test-names"><a class="header" href="#1-descriptive-test-names">1. Descriptive Test Names</a></h3>
<pre><code class="language-swift">@Test("User can create account with valid email and password")
func userAccountCreation() {
    // Test implementation
}
</code></pre>
<h3 id="2-arrange-act-assert-pattern"><a class="header" href="#2-arrange-act-assert-pattern">2. Arrange-Act-Assert Pattern</a></h3>
<pre><code class="language-swift">@Test func shoppingCartTotal() {
    // Arrange
    let cart = ShoppingCart()
    cart.add(Item(price: 10.00))
    cart.add(Item(price: 15.50))
    
    // Act
    let total = cart.calculateTotal()
    
    // Assert
    #expect(total == 25.50)
}
</code></pre>
<h3 id="3-test-data-builders"><a class="header" href="#3-test-data-builders">3. Test Data Builders</a></h3>
<pre><code class="language-swift">struct UserBuilder {
    private var name = "Default Name"
    private var email = "default@example.com"
    
    func withName(_ name: String) -&gt; UserBuilder {
        var builder = self
        builder.name = name
        return builder
    }
    
    func withEmail(_ email: String) -&gt; UserBuilder {
        var builder = self
        builder.email = email
        return builder
    }
    
    func build() -&gt; User {
        return User(name: name, email: email)
    }
}

@Test func userValidation() {
    let user = UserBuilder()
        .withName("John Doe")
        .withEmail("john@example.com")
        .build()
    
    #expect(user.isValid)
}
</code></pre>
<hr />
<p><em>Swift Testing provides a modern, clean way to test your Swift code with better tooling and syntax.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency--data-race-safety"><a class="header" href="#concurrency--data-race-safety">Concurrency &amp; Data Race Safety</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typed-throws"><a class="header" href="#typed-throws">Typed Throws</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noncopyable-types"><a class="header" href="#noncopyable-types">Noncopyable Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apples-accessibility-guidelines"><a class="header" href="#apples-accessibility-guidelines">Apple's Accessibility Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="voiceover-integration"><a class="header" href="#voiceover-integration">VoiceOver Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-type-support"><a class="header" href="#dynamic-type-support">Dynamic Type Support</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color--contrast"><a class="header" href="#color--contrast">Color &amp; Contrast</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-26-1"><a class="header" href="#ios-26-1">iOS 26</a></h1>
<blockquote>
<p><strong>Latest features and APIs for iPhone development</strong></p>
</blockquote>
<h2 id="-whats-new-in-ios-26"><a class="header" href="#-whats-new-in-ios-26">üéØ What's New in iOS 26</a></h2>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<ul>
<li>Xcode 26+</li>
<li>Swift 6.0+</li>
<li>Deployment target: iOS 26.0+</li>
</ul>
<p><strong>Official</strong>: <a href="https://developer.apple.com/documentation/ios-ipados-release-notes">iOS 26 Release Notes</a></p>
<h2 id="-new-frameworks"><a class="header" href="#-new-frameworks">üì± New Frameworks</a></h2>
<h3 id="1-enhanced-swiftdata"><a class="header" href="#1-enhanced-swiftdata">1. Enhanced SwiftData</a></h3>
<pre><code class="language-swift">import SwiftData

@Model
final class Task {
    var title: String
    var isCompleted: Bool
    var priority: Priority
    var dueDate: Date?
    
    // iOS 26: Computed properties with @Transient
    @Transient
    var isOverdue: Bool {
        guard let dueDate else { return false }
        return dueDate &lt; Date() &amp;&amp; !isCompleted
    }
    
    init(title: String, priority: Priority = .medium) {
        self.title = title
        self.isCompleted = false
        self.priority = priority
    }
}

enum Priority: String, Codable {
    case low, medium, high
}

// Usage in SwiftUI
struct TaskListView: View {
    @Query(sort: \Task.dueDate) private var tasks: [Task]
    @Environment(\.modelContext) private var context
    
    var body: some View {
        List {
            ForEach(tasks) { task in
                TaskRow(task: task)
            }
            .onDelete(perform: deleteTasks)
        }
    }
    
    private func deleteTasks(at offsets: IndexSet) {
        for index in offsets {
            context.delete(tasks[index])
        }
    }
}
</code></pre>
<p><strong>Documentation</strong>: <a href="https://developer.apple.com/documentation/swiftdata">SwiftData</a></p>
<h3 id="2-app-intents-20"><a class="header" href="#2-app-intents-20">2. App Intents 2.0</a></h3>
<pre><code class="language-swift">import AppIntents

struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "Add Task"
    static var description = IntentDescription("Adds a new task to your list")
    
    @Parameter(title: "Task Title")
    var title: String
    
    @Parameter(title: "Priority", default: .medium)
    var priority: Priority
    
    @MainActor
    func perform() async throws -&gt; some IntentResult {
        let task = Task(title: title, priority: priority)
        // Save task
        
        return .result(dialog: "Added task: \(title)")
    }
}

// Shortcuts support
struct TaskAppShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: AddTaskIntent(),
            phrases: [
                "Add a task in \(.applicationName)",
                "Create task in \(.applicationName)"
            ],
            shortTitle: "Add Task",
            systemImageName: "plus.circle"
        )
    }
}
</code></pre>
<p><strong>WWDC</strong>: <a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - App Intents Deep Dive</a></p>
<h3 id="3-live-activities-enhancement"><a class="header" href="#3-live-activities-enhancement">3. Live Activities Enhancement</a></h3>
<pre><code class="language-swift">import ActivityKit

struct TaskActivityAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var completedCount: Int
        var totalCount: Int
        var currentTask: String
    }
    
    var projectName: String
}

// Start Live Activity
func startTaskActivity() throws {
    let attributes = TaskActivityAttributes(projectName: "Work Project")
    let initialState = TaskActivityAttributes.ContentState(
        completedCount: 0,
        totalCount: 10,
        currentTask: "Review code"
    )
    
    let activity = try Activity.request(
        attributes: attributes,
        content: .init(state: initialState, staleDate: nil)
    )
}

// Update Live Activity
func updateActivity(_ activity: Activity&lt;TaskActivityAttributes&gt;) async {
    let updatedState = TaskActivityAttributes.ContentState(
        completedCount: 5,
        totalCount: 10,
        currentTask: "Write tests"
    )
    
    await activity.update(
        .init(state: updatedState, staleDate: nil)
    )
}
</code></pre>
<p><strong>Guide</strong>: <a href="https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities">Live Activities</a></p>
<h2 id="-ui-enhancements"><a class="header" href="#-ui-enhancements">üé® UI Enhancements</a></h2>
<h3 id="dynamic-island-integration"><a class="header" href="#dynamic-island-integration">Dynamic Island Integration</a></h3>
<pre><code class="language-swift">struct TaskActivityWidget: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: TaskActivityAttributes.self) { context in
            // Lock screen/banner UI
            HStack {
                Image(systemName: "checkmark.circle.fill")
                VStack(alignment: .leading) {
                    Text(context.state.currentTask)
                        .font(.headline)
                    Text("\(context.state.completedCount)/\(context.state.totalCount) completed")
                        .font(.caption)
                }
            }
        } dynamicIsland: { context in
            DynamicIsland {
                // Expanded UI
                DynamicIslandExpandedRegion(.leading) {
                    Image(systemName: "list.bullet")
                }
                DynamicIslandExpandedRegion(.trailing) {
                    Text("\(context.state.completedCount)/\(context.state.totalCount)")
                }
                DynamicIslandExpandedRegion(.bottom) {
                    Text(context.state.currentTask)
                }
            } compactLeading: {
                Image(systemName: "checkmark.circle")
            } compactTrailing: {
                Text("\(context.state.completedCount)")
            } minimal: {
                Image(systemName: "checkmark")
            }
        }
    }
}
</code></pre>
<h3 id="storekit-3-views"><a class="header" href="#storekit-3-views">StoreKit 3 Views</a></h3>
<pre><code class="language-swift">import StoreKit

struct SubscriptionView: View {
    @State private var subscriptions: [Product] = []
    
    var body: some View {
        SubscriptionStoreView(groupID: "premium_features") {
            // Custom marketing content
            VStack {
                Image("premium_icon")
                Text("Unlock Premium Features")
                    .font(.title)
            }
        }
        .subscriptionStoreButtonLabel(.multiline)
        .subscriptionStorePickerItemBackground(.thinMaterial)
        .storeButton(.visible, for: .restorePurchases)
    }
}
</code></pre>
<p><strong>Documentation</strong>: <a href="https://developer.apple.com/documentation/storekit/storekitviews">StoreKit Views</a></p>
<h2 id="-privacy--security"><a class="header" href="#-privacy--security">üîê Privacy &amp; Security</a></h2>
<h3 id="app-privacy-report"><a class="header" href="#app-privacy-report">App Privacy Report</a></h3>
<pre><code class="language-swift">import AppTrackingTransparency

class PrivacyManager {
    func requestTracking() async -&gt; Bool {
        await ATTrackingManager.requestTrackingAuthorization() == .authorized
    }
    
    func checkStatus() -&gt; ATTrackingManager.AuthorizationStatus {
        ATTrackingManager.trackingAuthorizationStatus
    }
}
</code></pre>
<h3 id="sensitive-content-analysis"><a class="header" href="#sensitive-content-analysis">Sensitive Content Analysis</a></h3>
<pre><code class="language-swift">import SensitiveContentAnalysis

actor ContentAnalyzer {
    private let analyzer = SCSensitivityAnalyzer()
    
    func analyzeImage(_ image: UIImage) async throws -&gt; Bool {
        let policy = SCSensitivityAnalysisPolicy()
        
        let result = try await analyzer.analyzeImage(
            image.cgImage!,
            policy: policy
        )
        
        return result.isSensitive
    }
}
</code></pre>
<p><strong>Privacy Guide</strong>: <a href="https://developer.apple.com/documentation/uikit/protecting-the-user-s-privacy">User Privacy and Data Use</a></p>
<h2 id="-performance"><a class="header" href="#-performance">üìä Performance</a></h2>
<h3 id="metrickit-20"><a class="header" href="#metrickit-20">MetricKit 2.0</a></h3>
<pre><code class="language-swift">import MetricKit

class MetricsManager: NSObject, MXMetricManagerSubscriber {
    override init() {
        super.init()
        MXMetricManager.shared.add(self)
    }
    
    func didReceive(_ payloads: [MXMetricPayload]) {
        for payload in payloads {
            // CPU metrics
            if let cpuMetrics = payload.cpuMetrics {
                print("CPU Time: \(cpuMetrics.cumulativeCPUTime)")
            }
            
            // Memory metrics
            if let memoryMetrics = payload.memoryMetrics {
                print("Peak Memory: \(memoryMetrics.peakMemoryUsage)")
            }
            
            // Network metrics
            if let networkMetrics = payload.networkTransferMetrics {
                print("Cellular: \(networkMetrics.cumulativeCellularDownload)")
            }
        }
    }
}
</code></pre>
<p><strong>WWDC</strong>: <a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Optimize App Performance</a></p>
<h2 id="-gaming"><a class="header" href="#-gaming">üéÆ Gaming</a></h2>
<h3 id="game-controller-support"><a class="header" href="#game-controller-support">Game Controller Support</a></h3>
<pre><code class="language-swift">import GameController

class GameControllerManager: ObservableObject {
    @Published var isConnected = false
    
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(controllerConnected),
            name: .GCControllerDidConnect,
            object: nil
        )
    }
    
    @objc private func controllerConnected(_ notification: Notification) {
        guard let controller = notification.object as? GCController else {
            return
        }
        
        isConnected = true
        setupController(controller)
    }
    
    private func setupController(_ controller: GCController) {
        controller.extendedGamepad?.buttonA.valueChangedHandler = { button, value, pressed in
            if pressed {
                print("Button A pressed")
            }
        }
    }
}
</code></pre>
<h2 id="-device-features"><a class="header" href="#-device-features">üì± Device Features</a></h2>
<h3 id="iphone-16-pro-features"><a class="header" href="#iphone-16-pro-features">iPhone 16 Pro Features</a></h3>
<pre><code class="language-swift">import UIKit

class DeviceCapabilities {
    static var supportsProMotion: Bool {
        UIScreen.main.maximumFramesPerSecond &gt;= 120
    }
    
    static var supportsAlwaysOn: Bool {
        // Check for always-on display support
        if #available(iOS 26, *) {
            return UIDevice.current.userInterfaceIdiom == .phone
        }
        return false
    }
    
    static var hasActionButton: Bool {
        // iPhone 15 Pro and later
        return UIDevice.current.model.contains("iPhone16")
    }
}
</code></pre>
<h3 id="camera-control-api"><a class="header" href="#camera-control-api">Camera Control API</a></h3>
<pre><code class="language-swift">import AVFoundation

class CameraController: NSObject {
    private let captureSession = AVCaptureSession()
    
    func setupCamera() throws {
        guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {
            throw CameraError.deviceNotAvailable
        }
        
        let input = try AVCaptureDeviceInput(device: camera)
        
        if captureSession.canAddInput(input) {
            captureSession.addInput(input)
        }
        
        // Configure for high quality
        captureSession.sessionPreset = .photo
        
        // Enable ProRAW if available
        if camera.activeFormat.isAppleProRAWSupported {
            camera.activeFormat.isAppleProRAWEnabled = true
        }
    }
}

enum CameraError: Error {
    case deviceNotAvailable
}
</code></pre>
<h2 id="-networking"><a class="header" href="#-networking">üåê Networking</a></h2>
<h3 id="urlsession-enhancements"><a class="header" href="#urlsession-enhancements">URLSession Enhancements</a></h3>
<pre><code class="language-swift">import Foundation

actor NetworkManager {
    func fetchData&lt;T: Decodable&gt;(from url: URL) async throws -&gt; T {
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    // Upload with progress
    func upload(data: Data, to url: URL) async throws -&gt; Double {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        
        let (_, response) = try await URLSession.shared.upload(for: request, from: data)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.uploadFailed
        }
        
        return 1.0
    }
}

enum NetworkError: Error {
    case invalidResponse
    case uploadFailed
}
</code></pre>
<h2 id="-best-practices-3"><a class="header" href="#-best-practices-3">üéØ Best Practices</a></h2>
<h3 id="1-adopt-latest-apis"><a class="header" href="#1-adopt-latest-apis">1. Adopt Latest APIs</a></h3>
<pre><code class="language-swift">// ‚úÖ Use modern async/await
func loadData() async throws -&gt; [Item] {
    try await fetchItems()
}

// ‚ùå Avoid completion handlers
func loadData(completion: @escaping ([Item]) -&gt; Void) {
    // Old style
}
</code></pre>
<h3 id="2-support-dark-mode"><a class="header" href="#2-support-dark-mode">2. Support Dark Mode</a></h3>
<pre><code class="language-swift">struct ThemedView: View {
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        Text("Adaptive")
            .foregroundStyle(colorScheme == .dark ? .white : .black)
            .background(Color(uiColor: .systemBackground))
    }
}
</code></pre>
<h3 id="3-optimize-for-battery"><a class="header" href="#3-optimize-for-battery">3. Optimize for Battery</a></h3>
<pre><code class="language-swift">import UIKit

class BatteryOptimizer {
    func optimizeForLowPower() {
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            // Reduce animations
            UIView.setAnimationsEnabled(false)
            
            // Reduce network requests
            // Pause background tasks
        }
    }
}
</code></pre>
<h2 id="-official-resources"><a class="header" href="#-official-resources">üìö Official Resources</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><a href="https://developer.apple.com/documentation/ios-ipados-release-notes">iOS Developer Documentation</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios">Human Interface Guidelines</a></li>
<li><a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a></li>
</ul>
<h3 id="wwdc-sessions"><a class="header" href="#wwdc-sessions">WWDC Sessions</a></h3>
<ul>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Platforms State of the Union</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - What's New in iOS</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - Design for iOS</a></li>
</ul>
<h3 id="sample-code"><a class="header" href="#sample-code">Sample Code</a></h3>
<ul>
<li><a href="https://developer.apple.com/sample-code/ios/">iOS Sample Apps</a></li>
<li><a href="https://developer.apple.com/tutorials/swiftui">SwiftUI Tutorials</a></li>
</ul>
<h2 id="-next-steps-5"><a class="header" href="#-next-steps-5">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./macos.html">macOS 26 ‚Üí</a></li>
<li><a href="platforms/./watchos.html">watchOS 26 ‚Üí</a></li>
<li><a href="platforms/./ipados.html">iPadOS 26 ‚Üí</a></li>
</ul>
<hr />
<p><strong>Sources</strong>:</p>
<ul>
<li>Apple Developer Documentation (2025)</li>
<li>iOS 26 Release Notes</li>
<li>WWDC 2025 Sessions</li>
<li>Human Interface Guidelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-26-1"><a class="header" href="#macos-26-1">macOS 26</a></h1>
<blockquote>
<p><strong>Build a menu bar app in 25 minutes</strong></p>
</blockquote>
<h2 id="-what-youll-build-3"><a class="header" href="#-what-youll-build-3">üéØ What You'll Build</a></h2>
<p>A menu bar utility that:</p>
<ul>
<li>‚úÖ Lives in menu bar</li>
<li>‚úÖ Shows quick info</li>
<li>‚úÖ Global keyboard shortcuts</li>
<li>‚úÖ Native macOS feel</li>
</ul>
<h2 id="-step-1-menu-bar-app"><a class="header" href="#-step-1-menu-bar-app">üöÄ Step 1: Menu Bar App</a></h2>
<pre><code class="language-swift">import SwiftUI

@main
struct MenuBarApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        Settings {
            SettingsView()
        }
    }
}

class AppDelegate: NSObject, NSApplicationDelegate {
    var statusItem: NSStatusItem?
    var popover: NSPopover?
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        // Create menu bar item
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        if let button = statusItem?.button {
            button.image = NSImage(systemSymbolName: "cloud.fill", accessibilityDescription: "Weather")
            button.action = #selector(togglePopover)
            button.target = self
        }
        
        // Create popover
        popover = NSPopover()
        popover?.contentSize = NSSize(width: 300, height: 400)
        popover?.behavior = .transient
        popover?.contentViewController = NSHostingController(rootView: PopoverView())
    }
    
    @objc func togglePopover() {
        guard let button = statusItem?.button else { return }
        
        if let popover = popover {
            if popover.isShown {
                popover.performClose(nil)
            } else {
                popover.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
            }
        }
    }
}

struct PopoverView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("72¬∞")
                .font(.system(size: 60, weight: .bold))
            Text("Sunny")
                .font(.title2)
            
            Divider()
            
            Button("Quit") {
                NSApplication.shared.terminate(nil)
            }
        }
        .padding()
    }
}
</code></pre>
<h2 id="-native-macos-ui"><a class="header" href="#-native-macos-ui">üé® Native macOS UI</a></h2>
<h3 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        NavigationSplitView {
            SidebarView()
        } detail: {
            DetailView()
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                Button {
                    NSApp.keyWindow?.firstResponder?.tryToPerform(#selector(NSSplitViewController.toggleSidebar(_:)), with: nil)
                } label: {
                    Image(systemName: "sidebar.left")
                }
            }
            
            ToolbarItem {
                Button("Add") {
                    // Add action
                }
            }
        }
    }
}
</code></pre>
<h3 id="window-management"><a class="header" href="#window-management">Window Management</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Text("Main Content")
            .frame(minWidth: 600, minHeight: 400)
            .onAppear {
                // Set window properties
                if let window = NSApplication.shared.windows.first {
                    window.title = "My App"
                    window.styleMask.insert(.fullSizeContentView)
                    window.titlebarAppearsTransparent = true
                }
            }
    }
}
</code></pre>
<h3 id="context-menus"><a class="header" href="#context-menus">Context Menus</a></h3>
<pre><code class="language-swift">struct ItemView: View {
    let item: Item
    
    var body: some View {
        Text(item.name)
            .contextMenu {
                Button("Edit") {
                    // Edit action
                }
                Button("Duplicate") {
                    // Duplicate action
                }
                Divider()
                Button("Delete", role: .destructive) {
                    // Delete action
                }
            }
    }
}
</code></pre>
<h2 id="-keyboard-shortcuts"><a class="header" href="#-keyboard-shortcuts">‚å®Ô∏è Keyboard Shortcuts</a></h2>
<pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Text("Content")
            .onAppear {
                setupKeyboardShortcuts()
            }
    }
    
    private func setupKeyboardShortcuts() {
        // Command+N for new item
        NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
            if event.modifierFlags.contains(.command) &amp;&amp; event.charactersIgnoringModifiers == "n" {
                createNewItem()
                return nil
            }
            return event
        }
    }
    
    private func createNewItem() {
        // Create new item
    }
}

// Or use SwiftUI commands
struct ContentView: View {
    var body: some View {
        Text("Content")
    }
}

extension ContentView {
    @CommandsBuilder
    var commands: some Commands {
        CommandMenu("Items") {
            Button("New Item") {
                createNewItem()
            }
            .keyboardShortcut("n", modifiers: .command)
            
            Button("Delete Item") {
                deleteItem()
            }
            .keyboardShortcut(.delete, modifiers: .command)
        }
    }
}
</code></pre>
<h2 id="-file-operations"><a class="header" href="#-file-operations">üéØ File Operations</a></h2>
<h3 id="open-file"><a class="header" href="#open-file">Open File</a></h3>
<pre><code class="language-swift">struct FileOpenerView: View {
    @State private var fileContent = ""
    
    var body: some View {
        VStack {
            Text(fileContent)
            
            Button("Open File") {
                openFile()
            }
        }
    }
    
    private func openFile() {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.allowedContentTypes = [.text]
        
        if panel.runModal() == .OK, let url = panel.url {
            fileContent = (try? String(contentsOf: url)) ?? "Error reading file"
        }
    }
}
</code></pre>
<h3 id="save-file"><a class="header" href="#save-file">Save File</a></h3>
<pre><code class="language-swift">private func saveFile(content: String) {
    let panel = NSSavePanel()
    panel.allowedContentTypes = [.text]
    panel.nameFieldStringValue = "document.txt"
    
    if panel.runModal() == .OK, let url = panel.url {
        try? content.write(to: url, atomically: true, encoding: .utf8)
    }
}
</code></pre>
<h2 id="-drag-and-drop"><a class="header" href="#-drag-and-drop">üé® Drag and Drop</a></h2>
<pre><code class="language-swift">struct DropZoneView: View {
    @State private var droppedFiles: [URL] = []
    
    var body: some View {
        VStack {
            Text("Drop files here")
                .frame(width: 300, height: 200)
                .background(.gray.opacity(0.2))
                .cornerRadius(10)
                .onDrop(of: [.fileURL], isTargeted: nil) { providers in
                    handleDrop(providers: providers)
                    return true
                }
            
            List(droppedFiles, id: \.self) { url in
                Text(url.lastPathComponent)
            }
        }
    }
    
    private func handleDrop(providers: [NSItemProvider]) {
        for provider in providers {
            provider.loadItem(forTypeIdentifier: "public.file-url", options: nil) { item, error in
                if let data = item as? Data,
                   let url = URL(dataRepresentation: data, relativeTo: nil) {
                    DispatchQueue.main.async {
                        droppedFiles.append(url)
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="-system-integration"><a class="header" href="#-system-integration">üéØ System Integration</a></h2>
<h3 id="notifications"><a class="header" href="#notifications">Notifications</a></h3>
<pre><code class="language-swift">import UserNotifications

func sendNotification() {
    let content = UNMutableNotificationContent()
    content.title = "Task Complete"
    content.body = "Your export is ready"
    content.sound = .default
    
    let request = UNNotificationRequest(
        identifier: UUID().uuidString,
        content: content,
        trigger: nil
    )
    
    UNUserNotificationCenter.current().add(request)
}
</code></pre>
<h3 id="dock-badge"><a class="header" href="#dock-badge">Dock Badge</a></h3>
<pre><code class="language-swift">// Set badge
NSApp.dockTile.badgeLabel = "5"

// Clear badge
NSApp.dockTile.badgeLabel = nil
</code></pre>
<h3 id="launch-at-login"><a class="header" href="#launch-at-login">Launch at Login</a></h3>
<pre><code class="language-swift">import ServiceManagement

func enableLaunchAtLogin() {
    try? SMAppService.mainApp.register()
}

func disableLaunchAtLogin() {
    try? SMAppService.mainApp.unregister()
}

var isLaunchAtLoginEnabled: Bool {
    SMAppService.mainApp.status == .enabled
}
</code></pre>
<h2 id="-multi-window-support"><a class="header" href="#-multi-window-support">üé® Multi-Window Support</a></h2>
<pre><code class="language-swift">@main
struct MultiWindowApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Window") {
                    openNewWindow()
                }
                .keyboardShortcut("n", modifiers: .command)
            }
        }
    }
    
    private func openNewWindow() {
        let newWindow = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 600, height: 400),
            styleMask: [.titled, .closable, .miniaturizable, .resizable],
            backing: .buffered,
            defer: false
        )
        newWindow.center()
        newWindow.contentView = NSHostingView(rootView: ContentView())
        newWindow.makeKeyAndOrderFront(nil)
    }
}
</code></pre>
<h2 id="-touch-bar-legacy"><a class="header" href="#-touch-bar-legacy">üéØ Touch Bar (Legacy)</a></h2>
<pre><code class="language-swift">extension NSTouchBar.CustomizationIdentifier {
    static let myApp = NSTouchBar.CustomizationIdentifier("com.myapp.touchbar")
}

extension NSTouchBarItem.Identifier {
    static let playButton = NSTouchBarItem.Identifier("com.myapp.play")
}

class TouchBarController: NSObject, NSTouchBarDelegate {
    func makeTouchBar() -&gt; NSTouchBar {
        let touchBar = NSTouchBar()
        touchBar.customizationIdentifier = .myApp
        touchBar.defaultItemIdentifiers = [.playButton]
        touchBar.delegate = self
        return touchBar
    }
    
    func touchBar(_ touchBar: NSTouchBar, makeItemForIdentifier identifier: NSTouchBarItem.Identifier) -&gt; NSTouchBarItem? {
        switch identifier {
        case .playButton:
            let button = NSButtonTouchBarItem(identifier: identifier, title: "Play", target: self, action: #selector(play))
            return button
        default:
            return nil
        }
    }
    
    @objc func play() {
        // Play action
    }
}
</code></pre>
<h2 id="-mac-catalyst"><a class="header" href="#-mac-catalyst">üé® Mac Catalyst</a></h2>
<p>Convert iOS app to macOS:</p>
<pre><code class="language-swift">// In target settings:
// General ‚Üí Deployment Info ‚Üí Mac (Designed for iPad)

// Platform-specific code
#if targetEnvironment(macCatalyst)
// Mac-specific code
#else
// iOS-specific code
#endif
</code></pre>
<h2 id="-best-practices-4"><a class="header" href="#-best-practices-4">üí° Best Practices</a></h2>
<h3 id="1-native-macos-patterns"><a class="header" href="#1-native-macos-patterns">1. Native macOS Patterns</a></h3>
<pre><code class="language-swift">// ‚úÖ Use NavigationSplitView (not TabView)
NavigationSplitView {
    SidebarView()
} detail: {
    DetailView()
}

// ‚úÖ Use toolbar (not bottom bar)
.toolbar {
    ToolbarItem {
        Button("Action") { }
    }
}
</code></pre>
<h3 id="2-keyboard-first"><a class="header" href="#2-keyboard-first">2. Keyboard First</a></h3>
<pre><code class="language-swift">// Add keyboard shortcuts for everything
.keyboardShortcut("n", modifiers: .command)
.keyboardShortcut("w", modifiers: .command)
.keyboardShortcut("q", modifiers: .command)
</code></pre>
<h3 id="3-window-restoration"><a class="header" href="#3-window-restoration">3. Window Restoration</a></h3>
<pre><code class="language-swift">struct ContentView: View {
    @SceneStorage("selectedTab") private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            // Tabs
        }
    }
}
</code></pre>
<h2 id="-resources-4"><a class="header" href="#-resources-4">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/macos-release-notes">macOS Documentation</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/macos">Human Interface Guidelines</a></li>
<li><a href="https://developer.apple.com/videos/wwdc2025/">WWDC25 - What's New in macOS</a></li>
</ul>
<h2 id="-next-steps-6"><a class="header" href="#-next-steps-6">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./ios.html">iOS 26 ‚Üí</a></li>
<li><a href="platforms/./watchos.html">watchOS 26 ‚Üí</a></li>
</ul>
<hr />
<p><strong>Pro tip</strong>: macOS users expect keyboard shortcuts. Add them everywhere!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watchos"><a class="header" href="#watchos">Watchos</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visionos-26-1"><a class="header" href="#visionos-26-1">visionOS 26</a></h1>
<blockquote>
<p><strong>Build spatial computing apps for Apple Vision Pro</strong></p>
</blockquote>
<h2 id="-what-makes-visionos-different"><a class="header" href="#-what-makes-visionos-different">üéØ What Makes visionOS Different</a></h2>
<ul>
<li><strong>3D Space</strong>: Apps exist in physical space</li>
<li><strong>Spatial Input</strong>: Eyes, hands, voice</li>
<li><strong>Immersion</strong>: From windows to full immersion</li>
<li><strong>Depth</strong>: Real depth perception</li>
</ul>
<h2 id="-your-first-visionos-app-10-min"><a class="header" href="#-your-first-visionos-app-10-min">üöÄ Your First visionOS App (10 min)</a></h2>
<pre><code class="language-swift">import SwiftUI
import RealityKit

@main
struct HelloVisionApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

struct ContentView: View {
    var body: some View {
        VStack(spacing: 30) {
            Text("Hello, Vision Pro!")
                .font(.extraLargeTitle)
            
            Model3D(named: "Scene") { model in
                model
                    .resizable()
                    .scaledToFit()
            } placeholder: {
                ProgressView()
            }
            .frame(depth: 300)
        }
        .padding()
    }
}
</code></pre>
<p><strong>New</strong>: <code>.frame(depth:)</code> adds 3D depth!</p>
<h2 id="-windows-volumes-and-spaces"><a class="header" href="#-windows-volumes-and-spaces">üé® Windows, Volumes, and Spaces</a></h2>
<h3 id="1-window-2d-content"><a class="header" href="#1-window-2d-content">1. Window (2D Content)</a></h3>
<pre><code class="language-swift">WindowGroup {
    ContentView()
}
</code></pre>
<p><strong>Use for</strong>: Settings, lists, forms</p>
<h3 id="2-volume-3d-content"><a class="header" href="#2-volume-3d-content">2. Volume (3D Content)</a></h3>
<pre><code class="language-swift">WindowGroup(id: "model") {
    Model3DView()
}
.windowStyle(.volumetric)
.defaultSize(width: 0.5, height: 0.5, depth: 0.5, in: .meters)
</code></pre>
<p><strong>Use for</strong>: 3D models, games, visualizations</p>
<h3 id="3-immersive-space-full-immersion"><a class="header" href="#3-immersive-space-full-immersion">3. Immersive Space (Full Immersion)</a></h3>
<pre><code class="language-swift">ImmersiveSpace(id: "immersive") {
    ImmersiveView()
}
.immersionStyle(selection: .constant(.full), in: .full)
</code></pre>
<p><strong>Use for</strong>: Games, experiences, meditation apps</p>
<h2 id="-complete-example-3d-gallery"><a class="header" href="#-complete-example-3d-gallery">üéØ Complete Example: 3D Gallery</a></h2>
<pre><code class="language-swift">import SwiftUI
import RealityKit

@main
struct GalleryApp: App {
    var body: some Scene {
        WindowGroup {
            GalleryView()
        }
        
        ImmersiveSpace(id: "gallery") {
            ImmersiveGalleryView()
        }
    }
}

struct GalleryView: View {
    @Environment(\.openImmersiveSpace) var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) var dismissImmersiveSpace
    @State private var isImmersive = false
    
    var body: some View {
        VStack(spacing: 20) {
            Text("3D Art Gallery")
                .font(.extraLargeTitle)
            
            Button(isImmersive ? "Exit Gallery" : "Enter Gallery") {
                Task {
                    if isImmersive {
                        await dismissImmersiveSpace()
                    } else {
                        await openImmersiveSpace(id: "gallery")
                    }
                    isImmersive.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

struct ImmersiveGalleryView: View {
    var body: some View {
        RealityView { content in
            // Create 3D scene
            let artwork1 = createArtwork(at: SIMD3(x: -1, y: 1.5, z: -2))
            let artwork2 = createArtwork(at: SIMD3(x: 0, y: 1.5, z: -2))
            let artwork3 = createArtwork(at: SIMD3(x: 1, y: 1.5, z: -2))
            
            content.add(artwork1)
            content.add(artwork2)
            content.add(artwork3)
        }
    }
    
    private func createArtwork(at position: SIMD3&lt;Float&gt;) -&gt; Entity {
        let mesh = MeshResource.generateBox(width: 0.5, height: 0.7, depth: 0.05)
        let material = SimpleMaterial(color: .blue, isMetallic: false)
        let entity = ModelEntity(mesh: mesh, materials: [material])
        entity.position = position
        return entity
    }
}
</code></pre>
<h2 id="-spatial-input"><a class="header" href="#-spatial-input">üëÅÔ∏è Spatial Input</a></h2>
<h3 id="eye-tracking"><a class="header" href="#eye-tracking">Eye Tracking</a></h3>
<pre><code class="language-swift">struct InteractiveView: View {
    @State private var isLookedAt = false
    
    var body: some View {
        RealityView { content in
            let entity = ModelEntity(mesh: .generateSphere(radius: 0.1))
            entity.components.set(InputTargetComponent())
            entity.components.set(HoverEffectComponent())
            content.add(entity)
        }
        .onContinuousHover { phase in
            switch phase {
            case .active:
                isLookedAt = true
            case .ended:
                isLookedAt = false
            }
        }
    }
}
</code></pre>
<h3 id="hand-gestures"><a class="header" href="#hand-gestures">Hand Gestures</a></h3>
<pre><code class="language-swift">struct GestureView: View {
    @State private var scale: Float = 1.0
    
    var body: some View {
        RealityView { content in
            let entity = ModelEntity(mesh: .generateBox(size: 0.2))
            entity.components.set(InputTargetComponent())
            content.add(entity)
        }
        .gesture(
            MagnifyGesture()
                .onChanged { value in
                    scale = Float(value.magnification)
                }
        )
    }
}
</code></pre>
<h2 id="-realitykit-basics"><a class="header" href="#-realitykit-basics">üéÆ RealityKit Basics</a></h2>
<h3 id="create-3d-objects"><a class="header" href="#create-3d-objects">Create 3D Objects</a></h3>
<pre><code class="language-swift">// Sphere
let sphere = ModelEntity(
    mesh: .generateSphere(radius: 0.1),
    materials: [SimpleMaterial(color: .red, isMetallic: true)]
)

// Box
let box = ModelEntity(
    mesh: .generateBox(size: 0.2),
    materials: [SimpleMaterial(color: .blue, isMetallic: false)]
)

// Custom mesh
let mesh = MeshResource.generateBox(width: 0.3, height: 0.2, depth: 0.1)
let entity = ModelEntity(mesh: mesh)
</code></pre>
<h3 id="positioning"><a class="header" href="#positioning">Positioning</a></h3>
<pre><code class="language-swift">entity.position = SIMD3(x: 0, y: 1.5, z: -2)
entity.orientation = simd_quatf(angle: .pi / 4, axis: [0, 1, 0])
entity.scale = SIMD3(repeating: 1.5)
</code></pre>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<pre><code class="language-swift">var transform = entity.transform
transform.translation.y += 0.5

entity.move(
    to: transform,
    relativeTo: nil,
    duration: 1.0,
    timingFunction: .easeInOut
)
</code></pre>
<h2 id="-spatial-anchors"><a class="header" href="#-spatial-anchors">üåç Spatial Anchors</a></h2>
<h3 id="place-objects-in-real-world"><a class="header" href="#place-objects-in-real-world">Place Objects in Real World</a></h3>
<pre><code class="language-swift">import ARKit

struct AnchoredView: View {
    var body: some View {
        RealityView { content in
            // Create anchor
            let anchor = AnchorEntity(.plane(.horizontal, classification: .floor, minimumBounds: [0.5, 0.5]))
            
            // Add object to anchor
            let entity = ModelEntity(mesh: .generateBox(size: 0.2))
            anchor.addChild(entity)
            
            content.add(anchor)
        }
    }
}
</code></pre>
<h2 id="-practical-example-solar-system"><a class="header" href="#-practical-example-solar-system">üéØ Practical Example: Solar System</a></h2>
<pre><code class="language-swift">struct SolarSystemView: View {
    var body: some View {
        RealityView { content in
            // Sun
            let sun = createPlanet(radius: 0.3, color: .yellow)
            sun.position = [0, 1.5, -2]
            content.add(sun)
            
            // Earth
            let earth = createPlanet(radius: 0.1, color: .blue)
            earth.position = [0.8, 1.5, -2]
            content.add(earth)
            
            // Orbit animation
            animateOrbit(earth, around: sun)
        }
    }
    
    private func createPlanet(radius: Float, color: UIColor) -&gt; ModelEntity {
        let mesh = MeshResource.generateSphere(radius: radius)
        let material = SimpleMaterial(color: color, isMetallic: false)
        return ModelEntity(mesh: mesh, materials: [material])
    }
    
    private func animateOrbit(_ planet: ModelEntity, around center: ModelEntity) {
        // Circular orbit animation
        let duration: TimeInterval = 10.0
        
        Timer.scheduledTimer(withTimeInterval: 0.016, repeats: true) { _ in
            let angle = Float(Date().timeIntervalSince1970.truncatingRemainder(dividingBy: duration) / duration * 2 * .pi)
            planet.position.x = center.position.x + 0.8 * cos(angle)
            planet.position.z = center.position.z + 0.8 * sin(angle)
        }
    }
}
</code></pre>
<h2 id="-materials-and-lighting"><a class="header" href="#-materials-and-lighting">üé® Materials and Lighting</a></h2>
<h3 id="physical-materials"><a class="header" href="#physical-materials">Physical Materials</a></h3>
<pre><code class="language-swift">var material = PhysicallyBasedMaterial()
material.baseColor = .init(tint: .blue)
material.roughness = 0.3
material.metallic = 0.8

let entity = ModelEntity(mesh: mesh, materials: [material])
</code></pre>
<h3 id="image-based-lighting"><a class="header" href="#image-based-lighting">Image-Based Lighting</a></h3>
<pre><code class="language-swift">// Add environment lighting
let environment = try await EnvironmentResource(named: "studio")
entity.components.set(ImageBasedLightComponent(source: .single(environment)))
</code></pre>
<h2 id="-passthrough-and-immersion"><a class="header" href="#-passthrough-and-immersion">üéØ Passthrough and Immersion</a></h2>
<pre><code class="language-swift">@main
struct ImmersiveApp: App {
    @State private var immersionLevel: ImmersionStyle = .mixed
    
    var body: some Scene {
        ImmersiveSpace(id: "space") {
            ContentView()
        }
        .immersionStyle(selection: $immersionLevel, in: .mixed, .progressive, .full)
    }
}
</code></pre>
<p><strong>Levels</strong>:</p>
<ul>
<li><code>.mixed</code>: See real world + virtual objects</li>
<li><code>.progressive</code>: Gradually fade real world</li>
<li><code>.full</code>: Complete virtual environment</li>
</ul>
<h2 id="-game-example-catch-the-balls"><a class="header" href="#-game-example-catch-the-balls">üéÆ Game Example: Catch the Balls</a></h2>
<pre><code class="language-swift">struct CatchGameView: View {
    @State private var score = 0
    
    var body: some View {
        RealityView { content in
            // Spawn balls
            Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
                let ball = createBall()
                content.add(ball)
                animateFall(ball)
            }
        } update: { content in
            // Update score display
        }
        .overlay(alignment: .top) {
            Text("Score: \(score)")
                .font(.extraLargeTitle)
                .padding()
        }
    }
    
    private func createBall() -&gt; ModelEntity {
        let ball = ModelEntity(
            mesh: .generateSphere(radius: 0.1),
            materials: [SimpleMaterial(color: .red, isMetallic: false)]
        )
        ball.position = SIMD3(
            x: Float.random(in: -1...1),
            y: 2,
            z: -2
        )
        ball.components.set(InputTargetComponent())
        return ball
    }
    
    private func animateFall(_ ball: ModelEntity) {
        var transform = ball.transform
        transform.translation.y = 0
        
        ball.move(to: transform, relativeTo: nil, duration: 3.0)
    }
}
</code></pre>
<h2 id="-best-practices-5"><a class="header" href="#-best-practices-5">üí° Best Practices</a></h2>
<h3 id="1-comfortable-viewing-distance"><a class="header" href="#1-comfortable-viewing-distance">1. Comfortable Viewing Distance</a></h3>
<pre><code class="language-swift">// Place content 1-3 meters away
entity.position.z = -2.0  // 2 meters
</code></pre>
<h3 id="2-appropriate-scale"><a class="header" href="#2-appropriate-scale">2. Appropriate Scale</a></h3>
<pre><code class="language-swift">// Real-world scale
let chair = ModelEntity(mesh: chairMesh)
chair.scale = SIMD3(repeating: 1.0)  // 1:1 scale
</code></pre>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<pre><code class="language-swift">// Use LOD (Level of Detail)
entity.components.set(ModelComponent(
    mesh: mesh,
    materials: materials
))

// Limit polygon count
// Target: &lt; 100K polygons per scene
</code></pre>
<h3 id="4-accessibility"><a class="header" href="#4-accessibility">4. Accessibility</a></h3>
<pre><code class="language-swift">// Add accessibility labels
entity.accessibilityLabel = "Red sphere"
entity.accessibilityHint = "Tap to interact"
</code></pre>
<h2 id="-testing-2"><a class="header" href="#-testing-2">üéØ Testing</a></h2>
<h3 id="simulator"><a class="header" href="#simulator">Simulator</a></h3>
<pre><code class="language-bash"># Run in visionOS Simulator
xcodebuild -scheme YourApp \
  -destination 'platform=visionOS Simulator,name=Apple Vision Pro'
</code></pre>
<h3 id="device"><a class="header" href="#device">Device</a></h3>
<ul>
<li>Requires Apple Vision Pro</li>
<li>Use Xcode wireless debugging</li>
<li>Test with real spatial input</li>
</ul>
<h2 id="-resources-5"><a class="header" href="#-resources-5">üìö Resources</a></h2>
<ul>
<li><a href="https://developer.apple.com/documentation/visionos">visionOS Documentation</a></li>
<li><a href="https://developer.apple.com/documentation/realitykit">RealityKit</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2023/10066/">WWDC23 - Meet visionOS</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/designing-for-visionos">Human Interface Guidelines</a></li>
</ul>
<h2 id="-next-steps-7"><a class="header" href="#-next-steps-7">üîó Next Steps</a></h2>
<ul>
<li><a href="platforms/./ios.html">iOS 26 ‚Üí</a></li>
<li><a href="platforms/../swiftui/essentials.html">SwiftUI Essentials ‚Üí</a></li>
</ul>
<hr />
<p><strong>Remember</strong>: Think in 3D space. Design for comfort. Test on device.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xcode-best-practices"><a class="header" href="#xcode-best-practices">Xcode Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-testing"><a class="header" href="#swift-testing">Swift Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xcode-cloud-cicd"><a class="header" href="#xcode-cloud-cicd">Xcode Cloud CI/CD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-store-guidelines"><a class="header" href="#app-store-guidelines">App Store Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-review-process"><a class="header" href="#app-review-process">App Review Process</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storekit--monetization"><a class="header" href="#storekit--monetization">StoreKit &amp; Monetization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testflight-beta-testing"><a class="header" href="#testflight-beta-testing">TestFlight Beta Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-package-manager-2"><a class="header" href="#swift-package-manager-2">Swift Package Manager</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-frameworks"><a class="header" href="#custom-frameworks">Custom Frameworks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrumdinger-meeting-app"><a class="header" href="#scrumdinger-meeting-app">Scrumdinger (Meeting App)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="landmarks-swiftui-tutorial"><a class="header" href="#landmarks-swiftui-tutorial">Landmarks (SwiftUI Tutorial)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="earthquake-data-visualization"><a class="header" href="#earthquake-data-visualization">Earthquake (Data Visualization)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ml-classifier-core-ml"><a class="header" href="#ml-classifier-core-ml">ML Classifier (Core ML)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-intelligence-deep-dive"><a class="header" href="#apple-intelligence-deep-dive">Apple Intelligence Deep Dive</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui-performance-tips"><a class="header" href="#swiftui-performance-tips">SwiftUI Performance Tips</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-best-practices"><a class="header" href="#concurrency-best-practices">Concurrency Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-platform-development"><a class="header" href="#cross-platform-development">Cross-Platform Development</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-developer-resources"><a class="header" href="#apple-developer-resources">Apple Developer Resources</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wwdc-session-references"><a class="header" href="#wwdc-session-references">WWDC Session References</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community"><a class="header" href="#community">Community</a></h1>
<blockquote>
<p>Coming soon - comprehensive guide with code examples and best practices</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="certification-preparation"><a class="header" href="#certification-preparation">Certification Preparation</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
